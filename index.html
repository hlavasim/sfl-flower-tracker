<!DOCTYPE html>
<html lang="cs">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SFL Collection Tracker</title>
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Ccircle cx='32' cy='32' r='10' fill='%23614126'/%3E%3Cg fill='%23FFD700'%3E%3Cellipse cx='32' cy='14' rx='7' ry='12'/%3E%3Cellipse cx='32' cy='50' rx='7' ry='12'/%3E%3Cellipse cx='14' cy='32' rx='12' ry='7'/%3E%3Cellipse cx='50' cy='32' rx='12' ry='7'/%3E%3Cellipse cx='19' cy='19' rx='7' ry='12' transform='rotate(-45 19 19)'/%3E%3Cellipse cx='45' cy='45' rx='7' ry='12' transform='rotate(-45 45 45)'/%3E%3Cellipse cx='45' cy='19' rx='7' ry='12' transform='rotate(45 45 19)'/%3E%3Cellipse cx='19' cy='45' rx='7' ry='12' transform='rotate(45 19 45)'/%3E%3C/g%3E%3Ccircle cx='32' cy='32' r='8' fill='%23614126'/%3E%3C/svg%3E">
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-darkest: #0d0906;
      --bg-dark: #1a0e08;
      --bg-medium: #2c1810;
      --bg-light: #3e2415;
      --bg-card: #2a1a0f;
      --bg-card-alt: #231509;
      --border-dark: #000;
      --border-brown: #5c3a1e;
      --border-light: #8b6914;
      --text-primary: #f0e6d2;
      --text-secondary: #c4a882;
      --text-dim: #9a8060;
      --green: #30D158;
      --red: #FF6B6B;
      --yellow: #FFD60A;
      --blue: #5DADE2;
      --sunpetal: #FFD700;
      --bloom: #FF69B4;
      --lily: #B07CD8;
      --edelweiss: #87CEEB;
      --gladiolus: #FF6347;
      --lavender: #C8A2C8;
      --clover: #2ECC71;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: var(--bg-darkest);
      color: var(--text-primary);
      font-family: 'Courier New', monospace;
      min-height: 100vh;
      image-rendering: pixelated;
    }

    .pixel-font { font-family: 'Press Start 2P', cursive; }

    .pixel-panel {
      background: var(--bg-medium);
      border: 4px solid var(--border-brown);
      box-shadow:
        inset 3px 3px 0 rgba(255,255,255,0.08),
        inset -3px -3px 0 rgba(0,0,0,0.25),
        0 0 0 3px var(--border-dark),
        6px 6px 0 rgba(0,0,0,0.4);
    }

    .container {
      max-width: 960px;
      margin: 0 auto;
      padding: 12px;
    }

    /* ‚îÄ‚îÄ Nav Bar ‚îÄ‚îÄ */
    .nav-bar {
      display: flex;
      align-items: stretch;
      margin-bottom: 12px;
      background: var(--bg-dark);
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
    }
    .nav-link {
      font-family: 'Press Start 2P', cursive;
      font-size: 10px;
      color: var(--text-secondary);
      background: none;
      border: none;
      padding: 14px 16px;
      cursor: pointer;
      white-space: nowrap;
      border-bottom: 3px solid transparent;
      transition: color 0.15s, border-color 0.15s;
      min-height: 44px;
      display: flex;
      align-items: center;
    }
    .nav-link:hover { color: var(--text-primary); }
    .nav-link.active {
      color: var(--sunpetal);
      border-bottom-color: var(--sunpetal);
    }
    .nav-link.help-btn {
      margin-left: auto;
      font-size: 14px;
      padding: 14px 18px;
    }

    /* ‚îÄ‚îÄ Header ‚îÄ‚îÄ */
    .header {
      text-align: center;
      padding: 20px 16px;
      margin-bottom: 16px;
      background: linear-gradient(180deg, #3e2415 0%, #2c1810 100%);
      position: relative;
      overflow: hidden;
    }
    .header::before {
      content: '';
      position: absolute;
      top: 0; left: 0; right: 0;
      height: 4px;
      background: repeating-linear-gradient(90deg, var(--sunpetal) 0 8px, transparent 8px 16px);
    }
    .header h1 {
      font-size: 16px;
      letter-spacing: 1px;
      color: var(--sunpetal);
      text-shadow: 2px 2px 0 #000, 0 0 8px rgba(255,215,0,0.3);
      margin-bottom: 8px;
    }
    .header .farm-id {
      font-size: 12px;
      color: var(--text-secondary);
    }

    /* ‚îÄ‚îÄ Summary bar ‚îÄ‚îÄ */
    .summary-bar {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      justify-content: center;
      padding: 14px 16px;
      margin-bottom: 16px;
      background: var(--bg-dark);
    }
    .summary-stat {
      text-align: center;
      min-width: 100px;
    }
    .summary-stat .label {
      font-size: 10px;
      color: var(--text-dim);
      margin-bottom: 4px;
      letter-spacing: 0.5px;
    }
    .summary-stat .value {
      font-size: 16px;
      font-weight: bold;
    }
    .summary-stat .value.complete { color: var(--green); }
    .summary-stat .value.pending { color: var(--yellow); }
    .summary-stat .value.time { color: var(--blue); }

    /* ‚îÄ‚îÄ Progress overview ‚îÄ‚îÄ */
    .progress-overview {
      padding: 12px 16px;
      margin-bottom: 16px;
    }
    .progress-label {
      display: flex;
      justify-content: space-between;
      font-size: 11px;
      margin-bottom: 6px;
      color: var(--text-secondary);
    }
    .progress-bar-outer {
      background: #111;
      border: 3px solid #000;
      height: 20px;
      position: relative;
      box-shadow: inset 2px 2px 0 rgba(0,0,0,0.6);
    }
    .progress-bar-fill {
      height: 100%;
      transition: width 0.8s ease-out;
      position: relative;
    }
    .progress-bar-fill.green {
      background: linear-gradient(180deg, #4ade80 0%, #22c55e 40%, #16a34a 100%);
      box-shadow: inset 0 2px 0 rgba(255,255,255,0.25), inset 0 -2px 0 rgba(0,0,0,0.2);
    }
    .progress-bar-fill::after {
      content: '';
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: repeating-linear-gradient(
        90deg,
        transparent 0 6px,
        rgba(0,0,0,0.12) 6px 8px
      );
    }

    /* ‚îÄ‚îÄ Seed section ‚îÄ‚îÄ */
    .seed-section {
      margin-bottom: 20px;
    }
    .seed-header {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 14px;
      background: var(--bg-dark);
      border: 3px solid var(--border-dark);
      border-bottom: none;
      box-shadow: inset 3px 3px 0 rgba(255,255,255,0.05);
    }
    .seed-icon {
      width: 28px;
      height: 28px;
      image-rendering: pixelated;
      filter: drop-shadow(1px 1px 0 #000);
    }
    .seed-header h2 {
      font-size: 13px;
      flex: 1;
    }
    .seed-meta {
      font-size: 10px;
      color: var(--text-dim);
      text-align: right;
    }
    .seed-meta span { display: block; margin-top: 2px; }
    .seed-badge {
      display: inline-block;
      padding: 2px 6px;
      font-size: 9px;
      border: 2px solid;
      margin-left: 4px;
    }

    /* ‚îÄ‚îÄ Flower grid ‚îÄ‚îÄ */
    .flower-grid {
      border: 3px solid var(--border-dark);
    }

    /* ‚îÄ‚îÄ Flower row ‚îÄ‚îÄ */
    .flower-row {
      display: grid;
      grid-template-columns: 36px 1fr 100px 140px;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      border-bottom: 2px solid rgba(0,0,0,0.4);
      transition: background 0.15s;
      min-height: 48px;
      cursor: pointer;
    }
    .flower-row:nth-child(even) { background: var(--bg-card); }
    .flower-row:nth-child(odd) { background: var(--bg-card-alt); }
    .flower-row:hover { background: #382210; }
    .flower-row.complete { opacity: 0.55; }
    .flower-row.complete:hover { opacity: 0.85; }

    .flower-img-wrap {
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }
    .flower-img {
      width: 28px;
      height: 28px;
      image-rendering: pixelated;
      filter: drop-shadow(1px 1px 0 rgba(0,0,0,0.6));
    }
    .flower-color-dot {
      width: 14px;
      height: 14px;
      border: 2px solid #000;
      box-shadow: inset 2px 2px 0 rgba(255,255,255,0.3);
    }

    .flower-info { min-width: 0; }
    .flower-name {
      font-size: 13px;
      font-weight: bold;
      color: var(--text-primary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .flower-chain {
      font-size: 11px;
      color: var(--text-dim);
      margin-top: 2px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .flower-chain .input-flower { color: var(--yellow); }
    .flower-chain .consumed-by { color: #c87d38; }

    .flower-progress { min-width: 0; }
    .flower-bar-outer {
      background: #111;
      border: 2px solid #000;
      height: 12px;
      box-shadow: inset 1px 1px 0 rgba(0,0,0,0.5);
      margin-bottom: 3px;
    }
    .flower-bar-fill {
      height: 100%;
      transition: width 0.6s;
    }
    .flower-bar-fill.bar-green {
      background: linear-gradient(180deg, #4ade80, #16a34a);
    }
    .flower-bar-fill.bar-yellow {
      background: linear-gradient(180deg, #fbbf24, #d97706);
    }
    .flower-bar-fill.bar-red {
      background: linear-gradient(180deg, #f87171, #dc2626);
    }
    .flower-count {
      font-size: 11px;
      display: flex;
      justify-content: space-between;
    }
    .flower-count .have { color: var(--text-secondary); }
    .flower-count .pending { color: var(--green); font-size: 10px; }

    .flower-time {
      text-align: right;
      font-size: 11px;
      color: var(--text-dim);
    }
    .flower-time .remaining-count { color: var(--yellow); font-size: 12px; }
    .flower-time .remaining-time { color: var(--text-dim); margin-top: 2px; }
    .flower-time .done { color: var(--green); font-size: 12px; }

    /* ‚îÄ‚îÄ Loading ‚îÄ‚îÄ */
    .loading-screen {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 60vh;
      gap: 20px;
    }
    .loading-flower {
      font-size: 48px;
      animation: bounce 1s ease-in-out infinite;
    }
    @keyframes bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-12px); }
    }
    .loading-text {
      font-size: 12px;
      color: var(--text-secondary);
      animation: blink 1.2s step-end infinite;
    }
    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }

    /* ‚îÄ‚îÄ Error ‚îÄ‚îÄ */
    .error-screen {
      text-align: center;
      padding: 40px 20px;
    }
    .error-screen .icon { font-size: 40px; margin-bottom: 12px; }
    .error-screen h2 { font-size: 14px; color: var(--red); margin-bottom: 8px; }
    .error-screen p { font-size: 11px; color: var(--text-secondary); max-width: 400px; margin: 0 auto 16px; }

    /* ‚îÄ‚îÄ Footer ‚îÄ‚îÄ */
    .footer {
      text-align: center;
      padding: 16px;
      margin-top: 8px;
    }
    .refresh-btn {
      font-family: 'Press Start 2P', cursive;
      font-size: 11px;
      color: var(--text-primary);
      background: var(--bg-light);
      border: 3px solid var(--border-brown);
      padding: 8px 18px;
      cursor: pointer;
      box-shadow:
        inset 2px 2px 0 rgba(255,255,255,0.1),
        inset -2px -2px 0 rgba(0,0,0,0.3),
        3px 3px 0 #000;
      transition: transform 0.1s;
    }
    .refresh-btn:hover { background: #4a2e18; }
    .refresh-btn:active {
      transform: translate(2px, 2px);
      box-shadow: inset 2px 2px 0 rgba(0,0,0,0.3), inset -2px -2px 0 rgba(255,255,255,0.1);
    }
    .timestamp {
      font-size: 10px;
      color: var(--text-dim);
      margin-top: 10px;
    }

    /* ‚îÄ‚îÄ Tooltip for consumed-by ‚îÄ‚îÄ */
    .consumed-tag {
      display: inline-block;
      font-size: 9px;
      padding: 1px 4px;
      margin-left: 3px;
      border: 1px solid #5c3a1e;
      background: rgba(92,58,30,0.3);
      color: #c87d38;
      vertical-align: middle;
    }

    /* ‚îÄ‚îÄ Config bar ‚îÄ‚îÄ */
    .config-bar {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: flex-end;
      padding: 14px 16px;
      margin-bottom: 16px;
      background: var(--bg-dark);
    }
    .config-field {
      display: flex;
      flex-direction: column;
      gap: 4px;
      flex: 1;
      min-width: 120px;
    }
    .config-field.small { flex: 0 0 100px; min-width: 80px; }
    .config-field label {
      font-size: 9px;
      color: var(--text-dim);
      letter-spacing: 0.5px;
    }
    .config-field input {
      font-family: 'Courier New', monospace;
      font-size: 12px;
      padding: 6px 10px;
      color: var(--text-primary);
      background: #111;
      border: 3px solid var(--border-brown);
      box-shadow: inset 2px 2px 0 rgba(0,0,0,0.5);
      outline: none;
      width: 100%;
    }
    .config-field input:focus {
      border-color: var(--sunpetal);
      box-shadow: inset 2px 2px 0 rgba(0,0,0,0.5), 0 0 6px rgba(255,215,0,0.2);
    }
    .config-field input::placeholder { color: var(--text-dim); }
    .config-go {
      font-family: 'Press Start 2P', cursive;
      font-size: 11px;
      color: #fff;
      background: #2d6a30;
      border: 3px solid #1a4a1c;
      padding: 8px 16px;
      cursor: pointer;
      box-shadow: inset 2px 2px 0 rgba(255,255,255,0.15), inset -2px -2px 0 rgba(0,0,0,0.3), 3px 3px 0 #000;
      white-space: nowrap;
      transition: transform 0.1s;
    }
    .config-go:hover { background: #38833c; }
    .config-go:active {
      transform: translate(2px, 2px);
      box-shadow: inset 2px 2px 0 rgba(0,0,0,0.3);
    }

    /* ‚îÄ‚îÄ Config collapsed ‚îÄ‚îÄ */
    .config-collapsed {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 16px;
      padding: 10px 16px;
      margin-bottom: 16px;
      background: var(--bg-dark);
      cursor: pointer;
      font-size: 10px;
      color: var(--text-secondary);
    }
    .config-collapsed:hover { background: var(--bg-medium); }
    .config-toggle {
      color: var(--sunpetal);
      font-size: 9px;
    }

    /* ‚îÄ‚îÄ Donate section ‚îÄ‚îÄ */
    .donate-section {
      margin-top: 20px;
      padding: 20px 16px;
      text-align: center;
      background: linear-gradient(180deg, #2c1810 0%, #1a0e08 100%);
    }
    .donate-section h3 {
      font-size: 12px;
      color: var(--sunpetal);
      margin-bottom: 12px;
      text-shadow: 1px 1px 0 #000;
    }
    .donate-section p {
      font-size: 11px;
      color: var(--text-secondary);
      margin-bottom: 12px;
      line-height: 1.6;
    }
    .donate-qr {
      display: inline-block;
      padding: 8px;
      background: #fff;
      border: 4px solid var(--border-brown);
      box-shadow: 0 0 0 3px #000, 4px 4px 0 rgba(0,0,0,0.4);
      margin-bottom: 12px;
    }
    .donate-qr img {
      display: block;
      width: 140px;
      height: 140px;
      image-rendering: pixelated;
    }
    .donate-addr-wrap {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: #111;
      border: 3px solid var(--border-brown);
      padding: 6px 10px;
      max-width: 100%;
      box-shadow: inset 2px 2px 0 rgba(0,0,0,0.5);
    }
    .donate-addr {
      font-family: 'Courier New', monospace;
      font-size: 12px;
      color: var(--text-primary);
      word-break: break-all;
      user-select: all;
    }
    .donate-copy {
      font-family: 'Press Start 2P', cursive;
      font-size: 9px;
      color: var(--text-primary);
      background: var(--bg-light);
      border: 2px solid var(--border-brown);
      padding: 4px 8px;
      cursor: pointer;
      white-space: nowrap;
      flex-shrink: 0;
    }
    .donate-copy:hover { background: #4a2e18; }
    .donate-chain-label {
      font-size: 10px;
      color: var(--text-dim);
      margin-top: 8px;
    }

    /* ‚îÄ‚îÄ Currently Growing section ‚îÄ‚îÄ */
    .growing-section {
      margin-bottom: 16px;
      padding: 14px 16px;
      background: var(--bg-dark);
    }
    .growing-title {
      font-size: 11px;
      color: var(--sunpetal);
      text-align: center;
      margin-bottom: 10px;
      text-shadow: 1px 1px 0 #000;
    }
    .growing-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
    }
    .growing-bed {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      background: rgba(255,215,0,0.06);
      border: 2px solid rgba(92,58,30,0.5);
    }
    .growing-bed.empty-bed {
      opacity: 0.35;
      background: rgba(0,0,0,0.2);
    }
    .growing-bed-img {
      width: 28px;
      height: 28px;
      image-rendering: pixelated;
      filter: drop-shadow(1px 1px 0 #000);
      flex-shrink: 0;
    }
    .growing-bed-info { flex: 1; min-width: 0; }
    .growing-bed-name {
      font-size: 11px;
      font-weight: bold;
      color: var(--text-primary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .growing-bed-detail {
      font-size: 9px;
      color: var(--text-secondary);
      margin-top: 2px;
    }
    .growing-bed-time {
      font-family: 'Press Start 2P', cursive;
      font-size: 9px;
      text-align: right;
      white-space: nowrap;
      flex-shrink: 0;
    }
    .growing-bed-time.ready { color: var(--green); }
    .growing-bed-time.growing { color: var(--yellow); }

    /* ‚îÄ‚îÄ Chain detail (clickable rows) ‚îÄ‚îÄ */
    .chain-detail {
      padding: 10px 12px 10px 52px;
      background: rgba(0,0,0,0.3);
      border-bottom: 2px solid rgba(0,0,0,0.4);
      font-size: 11px;
      color: var(--text-secondary);
      line-height: 1.6;
    }
    .chain-detail .chain-step {
      padding-left: 14px;
      border-left: 2px solid rgba(92,58,30,0.5);
      margin-top: 4px;
    }
    .chain-detail .chain-flower { color: var(--yellow); }
    .chain-detail .chain-crop { color: var(--text-secondary); }
    .chain-detail .chain-seed { color: var(--blue); }
    .chain-detail .chain-have { color: var(--green); }
    .chain-detail .chain-need { color: var(--red); }

    /* ‚îÄ‚îÄ Petal Blessed panel ‚îÄ‚îÄ */
    .petal-blessed-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      width: 100%;
      padding: 12px 16px;
      margin-bottom: 16px;
      font-family: 'Press Start 2P', cursive;
      font-size: 11px;
      color: #fff;
      background: linear-gradient(180deg, #6b21a8 0%, #4c1d95 50%, #3b0764 100%);
      border: 4px solid #7c3aed;
      cursor: pointer;
      box-shadow:
        inset 3px 3px 0 rgba(255,255,255,0.15),
        inset -3px -3px 0 rgba(0,0,0,0.3),
        0 0 0 3px #000,
        0 0 16px rgba(124,58,237,0.3);
      transition: transform 0.1s;
      text-shadow: 1px 1px 0 #000;
    }
    .petal-blessed-btn:hover {
      background: linear-gradient(180deg, #7c3aed 0%, #5b21b6 50%, #4c1d95 100%);
      box-shadow:
        inset 3px 3px 0 rgba(255,255,255,0.2),
        inset -3px -3px 0 rgba(0,0,0,0.3),
        0 0 0 3px #000,
        0 0 24px rgba(124,58,237,0.5);
    }
    .petal-blessed-btn:active {
      transform: translate(2px, 2px);
    }
    .pb-cooldown #pb-timer {
      color: #c084fc;
      font-size: 12px;
    }
    .petal-blessed-panel {
      margin-bottom: 16px;
      padding: 16px;
      background: linear-gradient(180deg, #2e1065 0%, #1e0a3c 100%);
      border: 4px solid #7c3aed;
      box-shadow: 0 0 0 3px #000, 0 0 20px rgba(124,58,237,0.25);
    }
    .petal-blessed-panel h3 {
      font-size: 12px;
      color: #c084fc;
      text-align: center;
      margin-bottom: 4px;
      text-shadow: 0 0 8px rgba(192,132,252,0.4);
    }
    .petal-blessed-panel .pb-subtitle {
      font-size: 10px;
      color: var(--text-dim);
      text-align: center;
      margin-bottom: 14px;
    }
    .pb-bed {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      margin-bottom: 6px;
      background: rgba(124,58,237,0.1);
      border: 2px solid rgba(124,58,237,0.3);
    }
    .pb-bed-num {
      font-family: 'Press Start 2P', cursive;
      font-size: 12px;
      color: #7c3aed;
      min-width: 24px;
    }
    .pb-bed-img {
      width: 28px;
      height: 28px;
      image-rendering: pixelated;
      filter: drop-shadow(1px 1px 0 #000);
    }
    .pb-bed-info { flex: 1; min-width: 0; }
    .pb-bed-name {
      font-size: 12px;
      font-weight: bold;
      color: var(--text-primary);
    }
    .pb-bed-recipe {
      font-size: 10px;
      color: var(--text-secondary);
      margin-top: 2px;
    }
    .pb-bed-time {
      font-family: 'Press Start 2P', cursive;
      font-size: 10px;
      color: #c084fc;
      text-align: right;
      white-space: nowrap;
    }
    .pb-bed-time .saved { color: var(--green); }
    .pb-close {
      display: block;
      margin: 12px auto 0;
      font-family: 'Press Start 2P', cursive;
      font-size: 9px;
      color: var(--text-secondary);
      background: transparent;
      border: 2px solid rgba(124,58,237,0.3);
      padding: 6px 16px;
      cursor: pointer;
    }
    .pb-close:hover { border-color: #7c3aed; color: #c084fc; }

    /* ‚îÄ‚îÄ Hub cards ‚îÄ‚îÄ */
    .hub-cards {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 16px;
      margin-top: 16px;
    }
    .hub-card {
      padding: 24px 16px;
      text-align: center;
      cursor: pointer;
      transition: transform 0.15s, box-shadow 0.15s;
    }
    .hub-card:hover {
      transform: translateY(-3px);
    }
    .hub-card-icon {
      font-size: 40px;
      margin-bottom: 10px;
    }
    .hub-card h3 {
      font-size: 13px;
      color: var(--sunpetal);
      margin-bottom: 8px;
      text-shadow: 1px 1px 0 #000;
    }
    .hub-card-count {
      font-size: 10px;
      color: var(--text-secondary);
    }
    .hub-card-progress {
      font-size: 11px;
      color: var(--green);
      margin-top: 8px;
    }

    /* ‚îÄ‚îÄ Help Modal ‚îÄ‚îÄ */
    .modal-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.85);
      z-index: 10000;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }
    .modal-content {
      max-width: 520px;
      width: 100%;
      padding: 24px;
      max-height: 80vh;
      overflow-y: auto;
    }
    .modal-content h2 {
      font-size: 14px;
      color: var(--sunpetal);
      text-align: center;
      margin-bottom: 16px;
      text-shadow: 1px 1px 0 #000;
    }
    .modal-content h3 {
      font-size: 10px;
      color: var(--sunpetal);
      margin: 14px 0 6px;
    }
    .modal-content p {
      font-size: 10px;
      color: var(--text-secondary);
      line-height: 1.8;
      margin-bottom: 8px;
    }
    .modal-content a {
      color: var(--sunpetal);
      text-decoration: none;
    }
    .modal-content a:hover { text-decoration: underline; }
    .modal-close {
      display: block;
      margin: 20px auto 0;
      font-family: 'Press Start 2P', cursive;
      font-size: 10px;
      color: var(--text-primary);
      background: var(--bg-light);
      border: 3px solid var(--border-brown);
      padding: 10px 24px;
      cursor: pointer;
      box-shadow: inset 2px 2px 0 rgba(255,255,255,0.1), 3px 3px 0 #000;
    }
    .modal-close:hover { background: #4a2e18; }

    /* ‚îÄ‚îÄ Scanline overlay (subtle) ‚îÄ‚îÄ */
    body::after {
      content: '';
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      pointer-events: none;
      background: repeating-linear-gradient(
        0deg,
        transparent 0 3px,
        rgba(0,0,0,0.03) 3px 4px
      );
      z-index: 9999;
    }

    /* ‚îÄ‚îÄ Bumpkin page ‚îÄ‚îÄ */
    .bumpkin-dev-banner {
      text-align: center;
      padding: 10px 12px;
      margin-bottom: 12px;
      background: rgba(255,214,10,0.1);
      border-color: rgba(255,214,10,0.4);
      font-size: 10px;
      color: var(--yellow);
    }
    .bumpkin-xp-section {
      padding: 20px 16px;
      margin-bottom: 16px;
      text-align: center;
    }
    .bumpkin-level-big {
      font-size: 32px;
      color: var(--sunpetal);
      text-shadow: 2px 2px 0 #000, 0 0 12px rgba(255,215,0,0.3);
    }
    .bumpkin-xp-info {
      font-size: 11px;
      color: var(--text-secondary);
      margin: 8px 0 12px;
      line-height: 1.8;
    }
    .bumpkin-buildings-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 12px;
      margin-bottom: 16px;
    }
    .bumpkin-building-card { padding: 14px; }
    .bumpkin-building-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 10px;
    }
    .bumpkin-building-name { font-size: 12px; color: var(--sunpetal); }
    .bumpkin-building-count { font-size: 9px; color: var(--text-dim); }
    .bumpkin-recipe-select {
      width: 100%;
      font-family: 'Courier New', monospace;
      font-size: 11px;
      padding: 6px 8px;
      color: var(--text-primary);
      background: #111;
      border: 3px solid var(--border-brown);
      box-shadow: inset 2px 2px 0 rgba(0,0,0,0.5);
      margin-bottom: 8px;
      outline: none;
    }
    .bumpkin-recipe-select:focus {
      border-color: var(--sunpetal);
    }
    .bumpkin-recipe-stats {
      font-size: 10px;
      color: var(--text-secondary);
      line-height: 1.8;
    }
    .bumpkin-summary {
      padding: 20px 16px;
      margin-bottom: 16px;
      text-align: center;
    }
    .bumpkin-days-big {
      font-size: 28px;
      color: var(--green);
      text-shadow: 2px 2px 0 #000;
      margin: 8px 0;
    }
    .bumpkin-boosts {
      padding: 12px 16px;
      margin-bottom: 12px;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 0 20px;
      font-size: 9px;
    }
    .bumpkin-boosts-col h4 {
      font-size: 10px;
      margin-bottom: 6px;
      padding-bottom: 4px;
      border-bottom: 2px solid rgba(92,58,30,0.4);
    }
    .bumpkin-boosts-col .boost-row {
      display: flex;
      justify-content: space-between;
      padding: 3px 0;
      color: var(--text-secondary);
    }
    .bumpkin-boosts-col .boost-row .boost-val {
      color: var(--text-dim);
      white-space: nowrap;
    }

    /* ‚îÄ‚îÄ Treasury page ‚îÄ‚îÄ */
    .treasury-header {
      text-align: center;
      padding: 20px 16px;
      margin-bottom: 16px;
      background: linear-gradient(180deg, #3e2415 0%, #2c1810 100%);
    }
    .treasury-total {
      font-size: 28px;
      color: var(--sunpetal);
      text-shadow: 2px 2px 0 #000, 0 0 12px rgba(255,215,0,0.3);
      margin: 8px 0 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }
    .treasury-total img {
      width: 28px; height: 28px;
      image-rendering: pixelated;
      filter: drop-shadow(1px 1px 0 #000);
    }
    .treasury-secondary {
      font-size: 11px;
      color: var(--text-secondary);
      margin-bottom: 4px;
    }
    .treasury-rates {
      font-size: 9px;
      color: var(--text-dim);
      margin-top: 8px;
    }
    .treasury-categories {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 12px;
      margin-bottom: 16px;
    }
    .treasury-cat-card {
      padding: 14px;
      cursor: pointer;
      transition: transform 0.15s;
    }
    .treasury-cat-card:hover { transform: translateY(-2px); }
    .treasury-cat-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }
    .treasury-cat-icon { font-size: 20px; }
    .treasury-cat-name { font-size: 11px; color: var(--text-secondary); }
    .treasury-cat-value {
      font-size: 16px;
      color: var(--sunpetal);
      text-shadow: 1px 1px 0 #000;
    }
    .treasury-cat-pct {
      font-size: 9px;
      color: var(--text-dim);
      margin-top: 4px;
    }
    .treasury-cat-bar {
      height: 6px;
      background: #111;
      border: 1px solid #000;
      margin-top: 6px;
    }
    .treasury-cat-bar-fill { height: 100%; transition: width 0.6s; }
    .treasury-cat-top {
      margin-top: 8px;
      font-size: 10px;
      line-height: 1.8;
      color: var(--text-secondary);
    }
    .treasury-cat-top-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .treasury-cat-top-item img {
      width: 18px; height: 18px;
      image-rendering: pixelated;
      filter: drop-shadow(1px 1px 0 #000);
    }
    .treasury-pie-wrap {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      padding: 16px;
    }
    .treasury-pie {
      width: 140px; height: 140px;
      border-radius: 50%;
      border: 3px solid #000;
      box-shadow: 0 0 0 3px rgba(92,58,30,0.5), 4px 4px 0 rgba(0,0,0,0.4);
    }
    .treasury-pie-legend {
      font-size: 10px;
      line-height: 2;
      color: var(--text-secondary);
    }
    .treasury-pie-swatch {
      display: inline-block;
      width: 12px; height: 12px;
      border: 2px solid #000;
      margin-right: 6px;
      vertical-align: middle;
    }
    .treasury-detail-section { margin-bottom: 16px; }
    .treasury-detail-header {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 10px 14px;
      background: var(--bg-dark);
      border: 3px solid var(--border-dark);
      border-bottom: none;
      cursor: pointer;
    }
    .treasury-detail-header:hover { background: var(--bg-medium); }
    .treasury-detail-header h3 { font-size: 12px; flex: 1; }
    .treasury-detail-arrow { font-size: 10px; color: var(--text-dim); }
    .treasury-detail-grid { border: 3px solid var(--border-dark); }
    .treasury-item-row {
      display: grid;
      grid-template-columns: 32px 1fr 70px 80px 90px;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      border-bottom: 2px solid rgba(0,0,0,0.4);
      font-size: 11px;
      min-height: 40px;
    }
    .treasury-item-row:nth-child(even) { background: var(--bg-card); }
    .treasury-item-row:nth-child(odd) { background: var(--bg-card-alt); }
    .treasury-item-img {
      width: 24px; height: 24px;
      image-rendering: pixelated;
      filter: drop-shadow(1px 1px 0 #000);
    }
    .treasury-item-name {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      color: var(--text-primary);
    }
    .treasury-item-qty { color: var(--text-secondary); text-align: right; }
    .treasury-item-unit { color: var(--text-dim); text-align: right; }
    .treasury-item-total { color: var(--sunpetal); text-align: right; font-weight: bold; }

    /* ‚îÄ‚îÄ Changelog ‚îÄ‚îÄ */
    .changelog-toggle {
      cursor: pointer;
      color: var(--text-dim);
      opacity: 0.6;
      transition: opacity 0.2s;
      user-select: none;
    }
    .changelog-toggle:hover { opacity: 1; }
    .changelog-content {
      text-align: left;
      margin-top: 10px;
      padding-top: 10px;
      border-top: 2px solid rgba(92,58,30,0.3);
      font-family: 'Courier New', monospace;
      font-size: 10px;
      color: var(--text-secondary);
      line-height: 1.7;
      max-height: 400px;
      overflow-y: auto;
    }
    .changelog-ver {
      color: var(--sunpetal);
      font-weight: bold;
      margin-top: 8px;
      margin-bottom: 2px;
    }
    .changelog-ver:first-child { margin-top: 0; }
    .changelog-item { padding-left: 12px; color: var(--text-dim); }
    .changelog-item::before { content: "‚Ä¢ "; color: var(--text-secondary); }
    .changelog-new { color: var(--green); }
    .changelog-fix { color: var(--yellow); }

    /* ‚îÄ‚îÄ Grow Planner ‚îÄ‚îÄ */
    .planner-section {
      margin-bottom: 16px;
      border: 4px solid var(--border-brown);
      background: var(--bg-dark);
      box-shadow: 0 0 0 3px #000;
    }
    .planner-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      padding: 10px 14px;
      background: var(--bg-medium);
      border-bottom: 3px solid var(--border-dark);
      cursor: pointer;
    }
    .planner-header:hover { background: var(--bg-light); }
    .planner-body { padding: 10px 14px; }
    .planner-batch { margin-bottom: 12px; }
    .planner-batch:last-child { margin-bottom: 0; }
    .planner-batch-label {
      font-size: 10px;
      color: var(--text-secondary);
      margin-bottom: 6px;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .planner-row {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 4px 0;
      font-size: 11px;
    }
    .planner-row img {
      width: 22px; height: 22px;
      image-rendering: pixelated;
      filter: drop-shadow(1px 1px 0 #000);
    }
    .planner-row-info { flex: 1; }
    .planner-row-name { color: var(--text-primary); }
    .planner-row-detail { font-size: 9px; color: var(--text-dim); }
    .planner-row-time { font-size: 10px; text-align: right; white-space: nowrap; color: var(--text-secondary); }
    .planner-row-time.sleep { color: var(--yellow); }
    .planner-idle { font-size: 9px; color: var(--text-dim); padding: 6px 0; text-align: center; }
    .planner-pb-box {
      background: rgba(176,124,216,0.08);
      border: 2px solid rgba(176,124,216,0.2);
      padding: 8px 10px;
      margin-top: 4px;
    }
    .planner-pb-saved { font-size: 10px; color: var(--lily); margin-top: 6px; text-align: right; }
    .planner-sleep-cfg {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 8px 14px;
      border-top: 2px solid rgba(92,58,30,0.2);
      font-size: 9px;
      color: var(--text-dim);
    }
    .planner-sleep-cfg input {
      width: 40px;
      padding: 2px 4px;
      font-family: 'Courier New', monospace;
      font-size: 10px;
      background: var(--bg-card);
      border: 2px solid var(--border-brown);
      color: var(--text-primary);
      text-align: center;
    }

    /* ‚îÄ‚îÄ Responsive ‚îÄ‚îÄ */
    @media (max-width: 640px) {
      .container { padding: 8px; }
      .header h1 { font-size: 13px; }
      .flower-row {
        grid-template-columns: 30px 1fr 80px;
        gap: 6px;
        padding: 6px 8px;
      }
      .flower-time { display: none; }
      .flower-row.mobile-show-time .flower-time { display: block; }
      .seed-header { flex-wrap: wrap; gap: 6px; }
      .summary-bar { gap: 8px; }
      .summary-stat { min-width: 80px; }
      .config-field { min-width: 100%; }
      .config-field.small { flex: 1; min-width: 80px; }
      .donate-addr { font-size: 10px; }
      .growing-grid { grid-template-columns: 1fr; }
      .hub-cards { grid-template-columns: 1fr; }
      .nav-link { font-size: 9px; padding: 12px 12px; }
      .nav-link.help-btn { padding: 12px 14px; font-size: 13px; }
      .config-collapsed { gap: 10px; font-size: 9px; flex-wrap: wrap; justify-content: center; }
      .bumpkin-boosts { grid-template-columns: 1fr; gap: 12px 0; }
      .bumpkin-buildings-grid { grid-template-columns: 1fr; }
      .bumpkin-level-big { font-size: 24px; }
      .bumpkin-days-big { font-size: 22px; }
      .treasury-total { font-size: 20px; }
      .treasury-categories { grid-template-columns: 1fr; }
      .treasury-pie-wrap { flex-direction: column; }
      .treasury-item-row { grid-template-columns: 24px 1fr 60px 70px; }
      .treasury-item-unit { display: none; }
      .planner-row { font-size: 10px; gap: 6px; }
      .planner-row img { width: 18px; height: 18px; }
      .planner-row-time { font-size: 9px; }
    }
  </style>
  <script defer src="/_vercel/insights/script.js"></script>
</head>
<body>
  <div class="container">
    <div id="nav-bar"></div>
    <div id="config-bar"></div>
    <div id="app">
      <div class="loading-screen pixel-font">
        <div class="loading-flower">üåª</div>
        <div class="loading-text">Loading...</div>
      </div>
    </div>
    <div id="donate-section"></div>
  </div>
  <div id="help-modal" class="modal-overlay" style="display:none"></div>

  <script>
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  CONSTANTS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const DEFAULTS = { farm: "", key: "", limit: "5" };
    const DONATE_ADDR = "0x5688ee5f0488e1dc96d9aad5715e958914987cfc";
    const IMG_BASE = "https://sfl.world/img/flowers/";
    const PAGES = ["hub", "flowers", "dolls", "crustaceans", "bumpkin", "treasury"];

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  SEED DATA
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const SEED_DATA = {
      "Sunpetal Seed":   { baseSeconds: 86400,  color: "#FFD700", label: "Sunpetal", season: null },
      "Bloom Seed":      { baseSeconds: 172800, color: "#FF69B4", label: "Bloom", season: null },
      "Edelweiss Seed":  { baseSeconds: 259200, color: "#87CEEB", label: "Edelweiss", season: "Winter" },
      "Gladiolus Seed":  { baseSeconds: 259200, color: "#FF6347", label: "Gladiolus", season: "Summer" },
      "Lavender Seed":   { baseSeconds: 259200, color: "#C8A2C8", label: "Lavender", season: "Spring" },
      "Clover Seed":     { baseSeconds: 259200, color: "#2ECC71", label: "Clover", season: "Autumn" },
      "Lily Seed":       { baseSeconds: 432000, color: "#B07CD8", label: "Lily", season: null },
    };

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  FLOWER BOOSTS (auto-detected from API)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const FLOWER_BOOSTS = [
      { name: "Flower Crown",      type: "wearable",        multiplier: 0.5  },
      { name: "Moth Shrine",       type: "collectible_temp", multiplier: 0.75, durationMs: 7 * 24 * 3600 * 1000 },
      { name: "Flower Fox",        type: "collectible",     multiplier: 0.9  },
      { name: "Blossom Hourglass", type: "collectible_temp", multiplier: 0.75, durationMs: 4 * 3600 * 1000 },
      { name: "Blooming Boost",    type: "skill",           multiplier: 0.9  },
      { name: "Flower Power",      type: "skill",           multiplier: 0.8  },
      { name: "Flowery Abode",     type: "skill",           multiplier: 1.5  },
    ];

    function findCollectible(farm, name) {
      // Collectibles can be on main island or home island
      const main = farm.collectibles?.[name] || [];
      const home = farm.home?.collectibles?.[name] || [];
      return [...main, ...home];
    }

    function detectFlowerBoosts(farm) {
      const active = [];
      for (const boost of FLOWER_BOOSTS) {
        let isActive = false;
        switch (boost.type) {
          case "wearable": {
            const equipped = farm.bumpkin?.equipped || {};
            isActive = Object.values(equipped).flat().includes(boost.name);
            break;
          }
          case "collectible": {
            isActive = findCollectible(farm, boost.name).length > 0;
            break;
          }
          case "collectible_temp": {
            const placements = findCollectible(farm, boost.name);
            if (placements.length > 0) {
              const latest = placements[placements.length - 1];
              const placedAt = toMs(latest.createdAt || latest.readyAt || 0);
              isActive = (Date.now() - placedAt) < boost.durationMs;
            }
            break;
          }
          case "skill": {
            const skills = farm.bumpkin?.skills || {};
            isActive = skills[boost.name] !== undefined;
            break;
          }
        }
        if (isActive) active.push(boost);
      }
      console.log("[Boosts]", active.map(b => `${b.name} √ó${b.multiplier}`), "multiplier:", computeFlowerMultiplier(active));
      return active;
    }

    function computeFlowerMultiplier(activeBoosts) {
      return activeBoosts.reduce((m, b) => m * b.multiplier, 1);
    }

    function applyFlowerBoosts(multiplier) {
      for (const sd of Object.values(SEED_DATA)) {
        sd.seconds = sd.baseSeconds * multiplier;
        sd.hours = sd.seconds / 3600;
      }
    }

    // Initialize with no boosts (multiplier = 1)
    applyFlowerBoosts(1);

    const SEED_ORDER = [
      "Sunpetal Seed", "Bloom Seed",
      "Edelweiss Seed", "Gladiolus Seed", "Lavender Seed", "Clover Seed",
      "Lily Seed",
    ];

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  FLOWER RECIPES
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const FLOWER_RECIPES = {
      "Red Pansy":       { seed: "Sunpetal Seed", input: "Radish" },
      "Yellow Pansy":    { seed: "Sunpetal Seed", input: "Sunflower" },
      "Purple Cosmos":   { seed: "Sunpetal Seed", input: "Beetroot" },
      "Blue Cosmos":     { seed: "Sunpetal Seed", input: "Cauliflower" },
      "Blue Pansy":      { seed: "Sunpetal Seed", input: "Purple Cosmos" },
      "Yellow Cosmos":   { seed: "Sunpetal Seed", input: "Yellow Pansy" },
      "Purple Pansy":    { seed: "Sunpetal Seed", input: "Blue Pansy" },
      "White Pansy":     { seed: "Sunpetal Seed", input: "Yellow Cosmos" },
      "White Cosmos":    { seed: "Sunpetal Seed", input: "Prism Petal" },
      "Prism Petal":     { seed: "Sunpetal Seed", input: "Blue Lotus" },
      "Red Cosmos":      { seed: "Sunpetal Seed", input: "Yellow Daffodil" },

      "Red Balloon Flower":   { seed: "Bloom Seed", input: "Sunflower" },
      "Blue Balloon Flower":  { seed: "Bloom Seed", input: "Cauliflower" },
      "Purple Daffodil":      { seed: "Bloom Seed", input: "Radish" },
      "Red Daffodil":         { seed: "Bloom Seed", input: "Yellow Pansy" },
      "White Daffodil":       { seed: "Bloom Seed", input: "Yellow Cosmos" },
      "Celestial Frostbloom": { seed: "Bloom Seed", input: "White Pansy" },
      "White Balloon Flower": { seed: "Bloom Seed", input: "White Cosmos" },
      "Yellow Daffodil":      { seed: "Bloom Seed", input: "Red Cosmos" },
      "Blue Daffodil":        { seed: "Bloom Seed", input: "Purple Balloon Flower" },
      "Yellow Balloon Flower":{ seed: "Bloom Seed", input: "Yellow Lotus" },
      "Purple Balloon Flower":{ seed: "Bloom Seed", input: "Blue Carnation" },

      "Purple Carnation": { seed: "Lily Seed", input: "Eggplant" },
      "Red Lotus":        { seed: "Lily Seed", input: "Beetroot" },
      "White Lotus":      { seed: "Lily Seed", input: "Cauliflower" },
      "Yellow Carnation": { seed: "Lily Seed", input: "Sunflower" },
      "White Carnation":  { seed: "Lily Seed", input: "Yellow Pansy" },
      "Yellow Lotus":     { seed: "Lily Seed", input: "Red Pansy" },
      "Blue Lotus":       { seed: "Lily Seed", input: "Blue Pansy" },
      "Blue Carnation":   { seed: "Lily Seed", input: "Purple Daffodil" },
      "Red Carnation":    { seed: "Lily Seed", input: "Purple Pansy" },
      "Purple Lotus":     { seed: "Lily Seed", input: "Blue Carnation" },
      "Primula Enigma":   { seed: "Lily Seed", input: "Purple Balloon Flower" },

      "Red Edelweiss":    { seed: "Edelweiss Seed", input: "Artichoke" },
      "Yellow Edelweiss": { seed: "Edelweiss Seed", input: "Onion" },
      "Purple Edelweiss": { seed: "Edelweiss Seed", input: "Rhubarb" },
      "White Edelweiss":  { seed: "Edelweiss Seed", input: "Blue Edelweiss" },
      "Blue Edelweiss":   { seed: "Edelweiss Seed", input: "Purple Edelweiss" },

      "Red Gladiolus":    { seed: "Gladiolus Seed", input: "Yellow Edelweiss" },
      "Yellow Gladiolus": { seed: "Gladiolus Seed", input: "Pepper" },
      "Purple Gladiolus": { seed: "Gladiolus Seed", input: "Artichoke" },
      "White Gladiolus":  { seed: "Gladiolus Seed", input: "White Edelweiss" },
      "Blue Gladiolus":   { seed: "Gladiolus Seed", input: "Rhubarb" },

      "Red Lavender":     { seed: "Lavender Seed", input: "Pepper" },
      "Yellow Lavender":  { seed: "Lavender Seed", input: "Red Gladiolus" },
      "Purple Lavender":  { seed: "Lavender Seed", input: "Blue Lavender" },
      "White Lavender":   { seed: "Lavender Seed", input: "Rhubarb" },
      "Blue Lavender":    { seed: "Lavender Seed", input: "White Edelweiss" },

      "Red Clover":       { seed: "Clover Seed", input: "Red Edelweiss" },
      "Yellow Clover":    { seed: "Clover Seed", input: "Pepper" },
      "Purple Clover":    { seed: "Clover Seed", input: "Red Lavender" },
      "White Clover":     { seed: "Clover Seed", input: "Blue Edelweiss" },
      "Blue Clover":      { seed: "Clover Seed", input: "Rhubarb" },
    };

    const CROPS_AND_FRUITS = new Set([
      "Sunflower","Potato","Pumpkin","Carrot","Cabbage","Soybean",
      "Beetroot","Cauliflower","Parsnip","Eggplant","Corn","Radish",
      "Wheat","Kale","Turnip","Onion","Pepper","Rhubarb","Artichoke",
      "Barley","Zucchini","Yam","Broccoli",
      "Tomato","Lemon","Blueberry","Orange","Apple","Banana",
      "Grape","Rice","Olive",
      "Celestine","Lunara","Duskberry",
    ]);

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  DOLL RECIPES
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const DOLL_RECIPES = {
      "Doll":           [{ item: "Leather", qty: 4 }, { item: "Wool", qty: 5 }],
      "Angler Doll":    [{ item: "Kelp Fibre", qty: 8 }, { item: "Doll", qty: 1 }],
      "Bloom Doll":     [{ item: "Doll", qty: 1 }, { item: "Prism Petal", qty: 3 }, { item: "Celestial Frostbloom", qty: 2 }, { item: "Primula Enigma", qty: 3 }],
      "Buzz Doll":      [{ item: "Honey", qty: 8 }, { item: "Doll", qty: 1 }],
      "Cluck Doll":     [{ item: "Feather", qty: 8 }, { item: "Doll", qty: 1 }],
      "Crude Doll":     [{ item: "Oil", qty: 8 }, { item: "Doll", qty: 1 }],
      "Ember Doll":     [{ item: "Crimsteel", qty: 8 }, { item: "Doll", qty: 1 }],
      "Gilded Doll":    [{ item: "Gold", qty: 8 }, { item: "Doll", qty: 1 }],
      "Harvest Doll":   [{ item: "Turnip", qty: 8 }, { item: "Doll", qty: 1 }],
      "Juicy Doll":     [{ item: "Tomato", qty: 8 }, { item: "Doll", qty: 1 }],
      "Lumber Doll":    [{ item: "Timber", qty: 8 }, { item: "Doll", qty: 1 }],
      "Lunar Doll":     [{ item: "Lunara", qty: 3 }, { item: "Duskberry", qty: 2 }, { item: "Doll", qty: 1 }, { item: "Celestine", qty: 3 }],
      "Moo Doll":       [{ item: "Leather", qty: 8 }, { item: "Doll", qty: 1 }],
      "Sizzle Doll":    [{ item: "Synthetic Fabric", qty: 8 }, { item: "Doll", qty: 1 }],
      "Wooly Doll":     [{ item: "Merino Wool", qty: 8 }, { item: "Doll", qty: 1 }],
      "Shadow Doll":    [{ item: "Obsidian", qty: 8 }, { item: "Doll", qty: 1 }],
      "Frosty Doll":    [{ item: "Celestial Frostbloom", qty: 8 }, { item: "Harvest Doll", qty: 1 }],
      "Grubby Doll":    [{ item: "Shadow Doll", qty: 1 }, { item: "Ember Doll", qty: 1 }, { item: "Gilded Doll", qty: 1 }],
      "Dune Doll":      [{ item: "Coral", qty: 8 }, { item: "Lumber Doll", qty: 1 }],
      "Solar Doll":     [],
      "Nefari Doll":    [],
      "Cosmo Doll":     [],
      "Bigfin Doll":    [],
    };

    const TRACKED_DOLLS_DEFAULT = {
      "Doll": true, "Angler Doll": true, "Bloom Doll": true, "Buzz Doll": true,
      "Cluck Doll": true, "Crude Doll": true, "Ember Doll": true, "Gilded Doll": true,
      "Harvest Doll": true, "Juicy Doll": true, "Lumber Doll": true, "Lunar Doll": true,
      "Moo Doll": true, "Sizzle Doll": true, "Wooly Doll": true,
      "Solar Doll": false, "Shadow Doll": false, "Nefari Doll": false, "Grubby Doll": false,
      "Frosty Doll": false, "Dune Doll": false, "Cosmo Doll": false, "Bigfin Doll": false,
    };

    function getTrackedDolls() {
      try {
        const saved = localStorage.getItem("sfl_tracked_dolls");
        if (saved) {
          const parsed = JSON.parse(saved);
          // Merge with defaults (in case new dolls were added)
          const result = { ...TRACKED_DOLLS_DEFAULT };
          for (const k of Object.keys(result)) {
            if (parsed[k] !== undefined) result[k] = parsed[k];
          }
          return result;
        }
      } catch (e) {}
      return { ...TRACKED_DOLLS_DEFAULT };
    }

    function saveTrackedDolls(tracked) {
      localStorage.setItem("sfl_tracked_dolls", JSON.stringify(tracked));
    }

    function toggleDollTracked(name) {
      const tracked = getTrackedDolls();
      tracked[name] = !tracked[name];
      saveTrackedDolls(tracked);
      // Re-render dolls page with cached data
      if (cachedFarmData) renderDolls(cachedFarmData);
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  CRUSTACEAN RECIPES
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const CRUSTACEAN_RECIPES = {
      "Blue Crab":    { pot: "Crab Pot", chum: "Heart Leaf", qty: 3, alt: "Ribbon x3", time: "4h" },
      "Lobster":      { pot: "Crab Pot", chum: "Wild Grass", qty: 3, alt: "Frost Pebble x3", time: "4h" },
      "Hermit Crab":  { pot: "Crab Pot", chum: "Grape", qty: 5, alt: "Rice x5", time: "4h" },
      "Shrimp":       { pot: "Crab Pot", chum: "Crimstone", qty: 2, alt: null, time: "4h" },
      "Mussel":       { pot: "Crab Pot", chum: "Moonfur", qty: 1, alt: null, time: "4h" },
      "Oyster":       { pot: "Crab Pot", chum: "Fish Stick", qty: 2, alt: null, time: "4h" },
      "Anemone":      { pot: "Crab Pot", chum: "Fish Oil", qty: 2, alt: "Crab Stick x2", time: "4h" },
      "Isopod":       { pot: "Crab Pot", chum: null, qty: 0, alt: null, time: "4h" },
      "Sea Slug":     { pot: "Mariner Pot", chum: "Crimstone", qty: 2, alt: null, time: "8h" },
      "Sea Snail":    { pot: "Mariner Pot", chum: "Chewed Bone", qty: 3, alt: "Ruffroot x3", time: "8h" },
      "Garden Eel":   { pot: "Mariner Pot", chum: "Dewberry", qty: 3, alt: "Duskberry x3", time: "8h" },
      "Sea Grapes":   { pot: "Mariner Pot", chum: "Lunara", qty: 3, alt: null, time: "8h" },
      "Octopus":      { pot: "Mariner Pot", chum: "Moonfur", qty: 1, alt: null, time: "8h" },
      "Sea Urchin":   { pot: "Mariner Pot", chum: "Fish Stick", qty: 2, alt: null, time: "8h" },
      "Horseshoe Crab":{ pot: "Mariner Pot", chum: "Crab Stick", qty: 2, alt: null, time: "8h" },
      "Barnacle":     { pot: "Mariner Pot", chum: null, qty: 0, alt: null, time: "8h" },
    };

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  BUMPKIN XP TABLE (total XP for levels 1-200)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const BUMPKIN_XP_TABLE = [
      // Lvl 1-10
      0, 2, 22, 205, 555, 1155, 2155, 3405, 5405, 7905,
      // Lvl 11-20
      10905, 14405, 18405, 22905, 27905, 33655, 40155, 47405, 55405, 64155,
      // Lvl 21-30
      73905, 84655, 96405, 109155, 122905, 137405, 152905, 169405, 186905, 205405,
      // Lvl 31-40
      225405, 246905, 269905, 294405, 320405, 348405, 378405, 410405, 444405, 480405,
      // Lvl 41-50
      518905, 559905, 603405, 649405, 697905, 749405, 803905, 861405, 921905, 985405,
      // Lvl 51-60
      1053905, 1127405, 1205905, 1289405, 1377905, 1476405, 1584905, 1703405, 1831905, 1970405,
      // Lvl 61-70
      2128905, 2287405, 2485905, 2704405, 2942905, 3221405, 3539905, 3898405, 4296905, 4735405,
      // Lvl 71-80
      5233905, 5743905, 6263905, 6793905, 7333905, 7883905, 8443905, 9013905, 9593905, 10183905,
      // Lvl 81-90
      10783905, 11393905, 12013905, 12643905, 13283905, 13933905, 14593905, 15263905, 15943905, 16633905,
      // Lvl 91-100
      17333905, 18043905, 18763905, 19493905, 20233905, 20983905, 21743905, 22513905, 23293905, 24083905,
      // Lvl 101-110
      24893905, 25723905, 26573905, 27443905, 28333905, 29243905, 30173905, 31123905, 32093905, 33083905,
      // Lvl 111-120
      34093905, 35123905, 36173905, 37243905, 38333905, 39443905, 40573905, 41723905, 42893905, 44083905,
      // Lvl 121-130
      45293905, 46523905, 47773905, 49043905, 50333905, 51653905, 53003905, 54383905, 55793905, 57233905,
      // Lvl 131-140
      58708905, 60218905, 61763905, 63343905, 64958905, 66613905, 68308905, 70043905, 71818905, 73633905,
      // Lvl 141-150
      75493905, 77398905, 79348905, 81343905, 83383905, 85473905, 87613905, 89803905, 92043905, 94333905,
      // Lvl 151-160
      95662605, 97031166, 98440783, 99892688, 101388150, 102928475, 104515009, 106149139, 107832292, 109565939,
      // Lvl 161-170
      111351595, 113190820, 115085221, 117036454, 119046223, 121116285, 123248448, 125444575, 127706585, 130036455,
      // Lvl 171-180
      132436221, 134907979, 137453889, 140076176, 142777131, 145559114, 148424556, 151375961, 154415908, 157547053,
      // Lvl 181-190
      160772132, 164093963, 167515448, 171039577, 174669429, 178408176, 182259085, 186225521, 190310950, 194518941,
      // Lvl 191-200
      198853171, 203317427, 207915610, 212651738, 217529949, 222554506, 227729799, 233060350, 238550817, 244206000,
    ];

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  COOKING RECIPES (84 foods, 5 buildings)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const COOKING_RECIPES_DATA = {
      // Fire Pit (18)
      "Mashed Potato":        { building: "Fire Pit",       xp: 3,     cookSec: 30,     usesHoney: false },
      "Rhubarb Tart":         { building: "Fire Pit",       xp: 5,     cookSec: 60,     usesHoney: false },
      "Pumpkin Soup":         { building: "Fire Pit",       xp: 24,    cookSec: 180,    usesHoney: false },
      "Reindeer Carrot":      { building: "Fire Pit",       xp: 36,    cookSec: 300,    usesHoney: false },
      "Mushroom Soup":        { building: "Fire Pit",       xp: 56,    cookSec: 600,    usesHoney: false },
      "Boiled Eggs":          { building: "Fire Pit",       xp: 90,    cookSec: 3600,   usesHoney: false },
      "Bumpkin Broth":        { building: "Fire Pit",       xp: 96,    cookSec: 1200,   usesHoney: false },
      "Popcorn":              { building: "Fire Pit",       xp: 200,   cookSec: 720,    usesHoney: false },
      "Cabbers n Mash":       { building: "Fire Pit",       xp: 250,   cookSec: 2400,   usesHoney: false },
      "Rapid Roast":          { building: "Fire Pit",       xp: 300,   cookSec: 10,     usesHoney: false },
      "Kale Stew":            { building: "Fire Pit",       xp: 400,   cookSec: 7200,   usesHoney: false },
      "Fried Tofu":           { building: "Fire Pit",       xp: 400,   cookSec: 5400,   usesHoney: false },
      "Gumbo":                { building: "Fire Pit",       xp: 600,   cookSec: 14400,  usesHoney: false },
      "Kale Omelette":        { building: "Fire Pit",       xp: 1250,  cookSec: 12600,  usesHoney: false },
      "Rice Bun":             { building: "Fire Pit",       xp: 2600,  cookSec: 18000,  usesHoney: false },
      "Antipasto":            { building: "Fire Pit",       xp: 3000,  cookSec: 10800,  usesHoney: false },
      "Pizza Margherita":     { building: "Fire Pit",       xp: 25000, cookSec: 72000,  usesHoney: false },
      // Kitchen (27)
      "Sunflower Crunch":     { building: "Kitchen",        xp: 50,    cookSec: 600,    usesHoney: false },
      "Club Sandwich":        { building: "Kitchen",        xp: 170,   cookSec: 10800,  usesHoney: false },
      "Roast Veggies":        { building: "Kitchen",        xp: 170,   cookSec: 7200,   usesHoney: false },
      "Fruit Salad":          { building: "Kitchen",        xp: 225,   cookSec: 1800,   usesHoney: false },
      "Mushroom Jacket Potatoes": { building: "Kitchen",    xp: 240,   cookSec: 600,    usesHoney: false },
      "Cauliflower Burger":   { building: "Kitchen",        xp: 255,   cookSec: 10800,  usesHoney: false },
      "Bumpkin Salad":        { building: "Kitchen",        xp: 290,   cookSec: 12600,  usesHoney: false },
      "Goblin's Treat":       { building: "Kitchen",        xp: 500,   cookSec: 21600,  usesHoney: false },
      "Pancakes":             { building: "Kitchen",        xp: 1000,  cookSec: 3600,   usesHoney: true  },
      "Bumpkin ganoush":      { building: "Kitchen",        xp: 1000,  cookSec: 18000,  usesHoney: false },
      "Chowder":              { building: "Kitchen",        xp: 1000,  cookSec: 28800,  usesHoney: false },
      "Tofu Scramble":        { building: "Kitchen",        xp: 1000,  cookSec: 10800,  usesHoney: false },
      "Fish Burger":          { building: "Kitchen",        xp: 1300,  cookSec: 7200,   usesHoney: false },
      "Fish Omelette":        { building: "Kitchen",        xp: 1500,  cookSec: 18000,  usesHoney: false },
      "Fried Calamari":       { building: "Kitchen",        xp: 1500,  cookSec: 18000,  usesHoney: false },
      "Beetroot Blaze":       { building: "Kitchen",        xp: 2000,  cookSec: 30,     usesHoney: false },
      "Sushi Roll":           { building: "Kitchen",        xp: 2000,  cookSec: 3600,   usesHoney: false },
      "Ocean's Olive":        { building: "Kitchen",        xp: 2000,  cookSec: 7200,   usesHoney: false },
      "Fish n Chips":         { building: "Kitchen",        xp: 2000,  cookSec: 14400,  usesHoney: false },
      "Seafood Basket":       { building: "Kitchen",        xp: 2200,  cookSec: 18000,  usesHoney: false },
      "Bumpkin Roast":        { building: "Kitchen",        xp: 2500,  cookSec: 43200,  usesHoney: false },
      "Goblin Brunch":        { building: "Kitchen",        xp: 2500,  cookSec: 43200,  usesHoney: false },
      "Steamed Red Rice":     { building: "Kitchen",        xp: 3000,  cookSec: 14400,  usesHoney: false },
      "Caprese Salad":        { building: "Kitchen",        xp: 6000,  cookSec: 10800,  usesHoney: false },
      "Spaghetti al Limone":  { building: "Kitchen",        xp: 15000, cookSec: 54000,  usesHoney: false },
      // Bakery (17)
      "Sunflower Cake":       { building: "Bakery",         xp: 525,   cookSec: 23400,  usesHoney: false },
      "Cornbread":            { building: "Bakery",         xp: 600,   cookSec: 43200,  usesHoney: false },
      "Pumpkin Cake":         { building: "Bakery",         xp: 625,   cookSec: 37800,  usesHoney: false },
      "Potato Cake":          { building: "Bakery",         xp: 650,   cookSec: 37800,  usesHoney: false },
      "Apple Pie":            { building: "Bakery",         xp: 720,   cookSec: 14400,  usesHoney: false },
      "Kale & Mushroom Pie":  { building: "Bakery",         xp: 720,   cookSec: 14400,  usesHoney: false },
      "Orange Cake":          { building: "Bakery",         xp: 730,   cookSec: 14400,  usesHoney: false },
      "Carrot Cake":          { building: "Bakery",         xp: 750,   cookSec: 46800,  usesHoney: false },
      "Cabbage Cake":         { building: "Bakery",         xp: 860,   cookSec: 54000,  usesHoney: false },
      "Wheat Cake":           { building: "Bakery",         xp: 1100,  cookSec: 86400,  usesHoney: false },
      "Cauliflower Cake":     { building: "Bakery",         xp: 1190,  cookSec: 79200,  usesHoney: false },
      "Radish Cake":          { building: "Bakery",         xp: 1200,  cookSec: 86400,  usesHoney: false },
      "Beetroot Cake":        { building: "Bakery",         xp: 1250,  cookSec: 79200,  usesHoney: false },
      "Parsnip Cake":         { building: "Bakery",         xp: 1300,  cookSec: 86400,  usesHoney: false },
      "Eggplant Cake":        { building: "Bakery",         xp: 1400,  cookSec: 86400,  usesHoney: false },
      "Honey Cake":           { building: "Bakery",         xp: 4000,  cookSec: 28800,  usesHoney: true  },
      "Lemon Cheesecake":     { building: "Bakery",         xp: 30000, cookSec: 108000, usesHoney: false },
      // Deli (9)
      "Cheese":               { building: "Deli",           xp: 1,     cookSec: 1200,   usesHoney: false },
      "Fermented Carrots":    { building: "Deli",           xp: 250,   cookSec: 86400,  usesHoney: false },
      "Blueberry Jam":        { building: "Deli",           xp: 500,   cookSec: 43200,  usesHoney: false },
      "Sauerkraut":           { building: "Deli",           xp: 500,   cookSec: 86400,  usesHoney: false },
      "Fancy Fries":          { building: "Deli",           xp: 1000,  cookSec: 86400,  usesHoney: false },
      "Fermented Fish":       { building: "Deli",           xp: 3000,  cookSec: 86400,  usesHoney: false },
      "Blue Cheese":          { building: "Deli",           xp: 6000,  cookSec: 10800,  usesHoney: false },
      "Shroom Syrup":         { building: "Deli",           xp: 10000, cookSec: 10,     usesHoney: true  },
      "Honey Cheddar":        { building: "Deli",           xp: 15000, cookSec: 43200,  usesHoney: true  },
      // Smoothie Shack (12)
      "Quick Juice":          { building: "Smoothie Shack", xp: 100,   cookSec: 1800,   usesHoney: false },
      "Carrot Juice":         { building: "Smoothie Shack", xp: 200,   cookSec: 3600,   usesHoney: false },
      "Purple Smoothie":      { building: "Smoothie Shack", xp: 310,   cookSec: 1800,   usesHoney: false },
      "Orange Juice":         { building: "Smoothie Shack", xp: 375,   cookSec: 2700,   usesHoney: false },
      "Apple Juice":          { building: "Smoothie Shack", xp: 500,   cookSec: 3600,   usesHoney: false },
      "Power Smoothie":       { building: "Smoothie Shack", xp: 775,   cookSec: 5400,   usesHoney: false },
      "Bumpkin Detox":        { building: "Smoothie Shack", xp: 975,   cookSec: 7200,   usesHoney: false },
      "Sour Shake":           { building: "Smoothie Shack", xp: 1000,  cookSec: 3600,   usesHoney: false },
      "Banana Blast":         { building: "Smoothie Shack", xp: 1200,  cookSec: 10800,  usesHoney: false },
      "The Lot":              { building: "Smoothie Shack", xp: 1500,  cookSec: 12600,  usesHoney: false },
      "Grape Juice":          { building: "Smoothie Shack", xp: 3300,  cookSec: 10800,  usesHoney: false },
      "Slow Juice":           { building: "Smoothie Shack", xp: 7500,  cookSec: 86400,  usesHoney: false },
    };

    const COOKING_BUILDING_NAMES = ["Fire Pit", "Kitchen", "Bakery", "Deli", "Smoothie Shack"];
    const COOKING_BUILDING_EMOJI = { "Fire Pit": "üî•", "Kitchen": "üç≥", "Bakery": "üßÅ", "Deli": "ü•©", "Smoothie Shack": "ü•§" };

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  GLOBALS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    let FARM_ID, API_KEY, LIMIT, FLOWER_BEDS, TRAP_COUNT;
    let lastInventory = null, lastInProgress = null;
    let cachedFarmData = null;
    let configExpanded = false;
    let growingTimerInterval = null;
    let pbTimerInterval = null;

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  ROUTER
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function getPage() {
      const p = new URLSearchParams(window.location.search);
      const page = p.get("page");
      if (page && PAGES.includes(page)) return page;
      const cfg = getConfig();
      return (cfg.farm && cfg.key) ? "flowers" : "hub";
    }

    function navigateTo(page) {
      const url = new URL(window.location);
      url.searchParams.set("page", page);
      history.pushState(null, "", url);
      configExpanded = false;
      main();
    }

    window.addEventListener("popstate", () => main());

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  CONFIG (localStorage + URL)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function migrateApiKey() {
      const p = new URLSearchParams(window.location.search);
      let changed = false;
      const keyFromUrl = p.get("key");
      if (keyFromUrl) {
        localStorage.setItem("sfl_api_key", keyFromUrl);
        p.delete("key");
        changed = true;
      }
      if (p.has("sunpetal")) {
        p.delete("sunpetal");
        changed = true;
      }
      if (changed) {
        const newUrl = window.location.pathname + (p.toString() ? "?" + p.toString() : "");
        history.replaceState(null, "", newUrl);
      }
    }

    function getConfig() {
      const p = new URLSearchParams(window.location.search);
      return {
        farm: p.get("farm") || DEFAULTS.farm,
        key: localStorage.getItem("sfl_api_key") || DEFAULTS.key,
        limit: parseInt(p.get("limit") || DEFAULTS.limit, 10) || 5,
      };
    }

    function saveConfig(farm, key, limit) {
      const p = new URLSearchParams(window.location.search);
      if (farm) p.set("farm", farm); else p.delete("farm");
      if (limit) p.set("limit", limit);
      // Clean up legacy sunpetal param
      p.delete("sunpetal");
      // Preserve page param
      const page = p.get("page");
      if (!page) p.set("page", getPage());
      // Key goes to localStorage only
      if (key) localStorage.setItem("sfl_api_key", key);
      const newURL = window.location.pathname + "?" + p.toString();
      history.replaceState(null, "", newURL);
    }

    function applyConfig() {
      const farm = document.getElementById("cfg-farm").value.trim();
      const key = document.getElementById("cfg-key").value.trim();
      const limit = document.getElementById("cfg-limit").value.trim();
      if (!farm || !key) return;
      saveConfig(farm, key, limit);
      cachedFarmData = null;
      configExpanded = false;
      main();
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  NAV BAR
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function renderNavBar(page) {
      const links = [
        { id: "hub", label: "HUB" },
        { id: "flowers", label: "FLOWERS" },
        { id: "dolls", label: "DOLLS" },
        { id: "crustaceans", label: "CRABS" },
        { id: "bumpkin", label: "BUMPKIN" },
        { id: "treasury", label: "TREASURY" },
      ];
      let html = '<div class="nav-bar pixel-panel">';
      for (const l of links) {
        const cls = page === l.id ? " active" : "";
        html += `<button class="nav-link${cls}" onclick="navigateTo('${l.id}')">${l.label}</button>`;
      }
      html += '<button class="nav-link help-btn" onclick="openHelp()">?</button>';
      html += '</div>';
      document.getElementById("nav-bar").innerHTML = html;
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  CONFIG BAR
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function renderConfigBar(page) {
      const cfg = getConfig();
      const el = document.getElementById("config-bar");
      const isHub = page === "hub";

      if (!isHub && !configExpanded && cfg.farm) {
        el.innerHTML = `<div class="config-collapsed pixel-panel pixel-font" onclick="expandConfig()">
          <span>Farm #${escHTML(cfg.farm)}</span>
          <span>Limit: ${cfg.limit}</span>
          <span class="config-toggle">EDIT &#9660;</span>
        </div>`;
        return;
      }

      el.innerHTML = `
        <div class="config-bar pixel-panel">
          <div class="config-field">
            <label class="pixel-font">FARM ID</label>
            <input id="cfg-farm" type="text" value="${escHTML(cfg.farm)}" placeholder="e.g. 155498">
          </div>
          <div class="config-field">
            <label class="pixel-font">API KEY</label>
            <input id="cfg-key" type="password" value="${escHTML(cfg.key)}" placeholder="sfl.xxxxx.xxxxx">
          </div>
          <div class="config-field small">
            <label class="pixel-font">LIMIT</label>
            <input id="cfg-limit" type="number" min="1" max="99" value="${cfg.limit}">
          </div>
          <button class="config-go" onclick="applyConfig()">LOAD</button>
        </div>`;

      const keyInput = document.getElementById("cfg-key");
      if (keyInput) {
        keyInput.addEventListener("focus", () => keyInput.type = "text");
        keyInput.addEventListener("blur", () => keyInput.type = "password");
      }
    }

    function expandConfig() {
      configExpanded = true;
      renderConfigBar(getPage());
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  DONATE
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function renderDonate() {
      const qrURL = `https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=${encodeURIComponent(DONATE_ADDR)}&bgcolor=ffffff&color=2c1810`;
      document.getElementById("donate-section").innerHTML = `
        <div class="donate-section pixel-panel pixel-font">
          <h3>SUPPORT THE PROJECT</h3>
          <p>If this tool helped you, consider sending<br>a flower or some ETH</p>
          <div class="donate-qr">
            <img src="${qrURL}" alt="Donate QR">
          </div>
          <br>
          <div class="donate-addr-wrap">
            <span class="donate-addr">${DONATE_ADDR}</span>
            <button class="donate-copy" onclick="copyAddr()">COPY</button>
          </div>
          <div class="donate-chain-label">ETH / Polygon / Base / Arbitrum</div>
          <div style="margin-top:16px;padding-top:12px;border-top:2px solid rgba(92,58,30,0.4);font-size:10px;color:var(--text-dim)">
            Created by 0xStableFarmer - #155498<br>
            Based on data from <a href="https://sfl.world" target="_blank" style="color:var(--sunpetal);text-decoration:none">sfl.world</a><br>
            <span class="changelog-toggle" onclick="toggleChangelog()"><span id="changelog-arrow">‚ñ∂</span> v1.7</span>
            <div id="changelog-content" class="changelog-content" style="display:none">
              ${renderChangelog()}
            </div>
          </div>
        </div>`;
    }

    function copyAddr() {
      navigator.clipboard.writeText(DONATE_ADDR).then(() => {
        const btn = document.querySelector(".donate-copy");
        btn.textContent = "COPIED!";
        setTimeout(() => btn.textContent = "COPY", 2000);
      });
    }

    function toggleChangelog() {
      const el = document.getElementById("changelog-content");
      const arrow = document.getElementById("changelog-arrow");
      if (!el) return;
      const show = el.style.display === "none";
      el.style.display = show ? "block" : "none";
      arrow.textContent = show ? "‚ñº" : "‚ñ∂";
    }

    function renderChangelog() {
      const log = [
        { ver: "v1.7", items: [
          { t: "new", text: "Treasury page ‚Äî farm value visualizer" },
          { t: "new", text: "5 value categories: Resources, Treasures, Collectibles, Wearables, Liquid" },
          { t: "new", text: "Treasure sell prices with Treasure Map (+20%) and Camel (+30%) boosts" },
          { t: "new", text: "NFT collectible & wearable valuations from sfl.world" },
          { t: "new", text: "SFL/USD/BTC conversion with live exchange rates" },
          { t: "new", text: "Pie chart breakdown + collapsible detail tables" },
          { t: "new", text: "Gems + coins liquid balance with best-tier conversion" },
          { t: "new", text: "Expandable version changelog in footer" },
        ]},
        { ver: "v1.6", items: [
          { t: "new", text: "Bumpkin XP Calculator page" },
          { t: "new", text: "Current level/XP with progress bar to target level" },
          { t: "new", text: "Building cards with recipe selectors (sorted by XP/hour)" },
          { t: "new", text: "Auto-detect cooking boosts (skills + collectibles)" },
          { t: "new", text: "Combined XP/day + days to target level calculation" },
          { t: "new", text: "Food in inventory XP breakdown" },
          { t: "new", text: "Pet streak detection with weekly status" },
        ]},
        { ver: "v1.5", items: [
          { t: "new", text: "Usage stats tracking (anonymous)" },
          { t: "fix", text: "Unified colors: green = have, red = don't have" },
          { t: "new", text: "Season detection ‚Äî IN SEASON / OFF SEASON badges" },
          { t: "new", text: "Current season shown in flower tracker header" },
          { t: "new", text: "Vercel Web Analytics" },
        ]},
        { ver: "v1.4", items: [
          { t: "new", text: "Multi-page app with nav bar (HUB | FLOWERS | DOLLS | CRABS)" },
          { t: "new", text: "Auto-detected flower boosts (7 boosts, multiplicative)" },
          { t: "new", text: "Dolls tracker with configurable tracking + ingredient breakdown" },
          { t: "new", text: "Crustaceans tracker ‚Äî Crab Pot / Mariner Pot sections" },
          { t: "new", text: "Help modal with usage instructions" },
          { t: "new", text: "API key stored in localStorage (improved security)" },
        ]},
        { ver: "v1.3", items: [
          { t: "new", text: "Auto-detect flower beds from API" },
          { t: "new", text: "Currently growing section with live timers" },
          { t: "new", text: "Clickable flower rows with dependency chain details" },
          { t: "new", text: "Favicon" },
        ]},
        { ver: "v1.2", items: [
          { t: "fix", text: "Proxy: use Node.js res API for Vercel compatibility" },
        ]},
        { ver: "v1.1", items: [
          { t: "new", text: "Vercel deployment with API proxy (CORS fix)" },
          { t: "new", text: "Custom domain: sunflower.sajmonium.quest" },
        ]},
        { ver: "v1.0", items: [
          { t: "new", text: "Initial release ‚Äî flower collection tracker" },
          { t: "new", text: "Progress bars, dependency chains, time estimates" },
          { t: "new", text: "Petal Blessed optimizer" },
        ]},
      ];
      return log.map(v =>
        `<div class="changelog-ver">${v.ver}</div>` +
        v.items.map(i =>
          `<div class="changelog-item"><span class="changelog-${i.t}">${i.t === "new" ? "NEW" : "FIX"}</span> ${escHTML(i.text)}</div>`
        ).join("")
      ).join("");
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  HELP MODAL
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function openHelp() {
      const el = document.getElementById("help-modal");
      el.style.display = "flex";
      el.innerHTML = `<div class="modal-content pixel-panel pixel-font">
        <h2>HOW TO USE</h2>
        <h3>1. GET YOUR API KEY</h3>
        <p>In the game: <b>Settings &gt; General &gt; API Key</b></p>
        <h3>2. GET YOUR FARM ID</h3>
        <p>In the game: <b>Settings &gt; Farm ID</b></p>
        <h3>3. ENTER YOUR DETAILS</h3>
        <p><b>Farm ID</b> - your farm number (e.g. 155498)<br>
        <b>API Key</b> - starts with "sfl." (two dots)<br>
        <b>Limit</b> - target count per item (default: 5)</p>
        <h3>FLOWER BOOSTS</h3>
        <p>Flower grow time boosts are <b>auto-detected</b> from your farm data:<br>
        Flower Crown, Moth Shrine, Flower Fox,<br>
        Blossom Hourglass, Blooming Boost,<br>
        Flower Power, Flowery Abode</p>
        <h3>4. BOOKMARK THIS PAGE</h3>
        <p>Your Farm ID and settings are saved in the URL.<br>
        Your API key is stored locally in your browser (not in the URL).<br>
        Bookmark this page for quick access!</p>
        <h3>TRACKERS</h3>
        <p><b>FLOWERS</b> - All flower types with dependency chains and Petal Blessed planning<br>
        <b>DOLLS</b> - Doll crafting with ingredient requirements<br>
        <b>CRABS</b> - Crab/Mariner pot catches with chum needs</p>
        <h3>BUGS &amp; FEEDBACK</h3>
        <p><a href="https://github.com/hlavasim/sfl-flower-tracker/issues" target="_blank">github.com/hlavasim/sfl-flower-tracker/issues</a></p>
        <button class="modal-close" onclick="closeHelp()">CLOSE</button>
      </div>`;
    }

    function closeHelp() {
      document.getElementById("help-modal").style.display = "none";
    }

    document.addEventListener("click", (e) => {
      const modal = document.getElementById("help-modal");
      if (e.target === modal) closeHelp();
    });

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  HELPERS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function getCount(inv, name) {
      const v = inv[name];
      if (v === undefined || v === null) return 0;
      return Math.floor(parseFloat(v));
    }

    function formatHours(h) {
      if (h <= 0) return "Done";
      const totalMin = Math.round(h * 60);
      const d = Math.floor(totalMin / 1440);
      const hrs = Math.floor((totalMin % 1440) / 60);
      const min = totalMin % 60;
      if (d > 0 && hrs > 0) return `${d}d ${hrs}h`;
      if (d > 0) return `${d}d`;
      if (hrs > 0 && min > 0) return `${hrs}h ${min}m`;
      if (hrs > 0) return `${hrs}h`;
      return `${min}m`;
    }

    function flowerColorCSS(name) {
      if (name.startsWith("Red")) return "#e74c3c";
      if (name.startsWith("Yellow")) return "#f1c40f";
      if (name.startsWith("Purple")) return "#9b59b6";
      if (name.startsWith("Blue")) return "#3498db";
      if (name.startsWith("White")) return "#ecf0f1";
      if (name === "Prism Petal") return "linear-gradient(135deg,#e74c3c,#f1c40f,#3498db,#9b59b6)";
      if (name === "Celestial Frostbloom") return "#a8d8ea";
      if (name === "Primula Enigma") return "#d5a6e6";
      return "#bdc3c7";
    }

    function barClass(pct) {
      return pct >= 100 ? "bar-green" : "bar-red";
    }

    function escHTML(s) {
      return String(s).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;");
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  BUMPKIN HELPERS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function getBumpkinLevel(xp) {
      for (let i = BUMPKIN_XP_TABLE.length - 1; i >= 0; i--) {
        if (xp >= BUMPKIN_XP_TABLE[i]) return i + 1;
      }
      return 1;
    }

    function getAllEquippedWearables(farm) {
      // Main bumpkin + all farm hands (additional bumpkins)
      const all = [];
      if (farm.bumpkin?.equipped) all.push(farm.bumpkin.equipped);
      // Farm hands ‚Äî try common API field names
      const hands = farm.farmHands?.bumpkins || farm.farmHands || {};
      for (const hand of Object.values(hands)) {
        if (hand?.equipped) all.push(hand.equipped);
      }
      return all;
    }

    function isWearableEquipped(farm, name) {
      for (const equipped of getAllEquippedWearables(farm)) {
        if (Object.values(equipped).flat().includes(name)) return true;
      }
      return false;
    }

    function detectCookingBoosts(farm) {
      const skills = farm.bumpkin?.skills || {};
      const xpBoosts = [];
      const timeBoosts = [];

      // Check collectible OR wearable (handles both cases)
      function hasItem(name) {
        return findCollectible(farm, name).length > 0 || isWearableEquipped(farm, name);
      }
      // Try multiple name variants
      function hasAny(...names) {
        return names.some(n => hasItem(n));
      }

      // Debug: log all available items so user can spot missing boosts
      console.log("[Cooking Boosts] Collectibles:", Object.keys(farm.collectibles || {}));
      console.log("[Cooking Boosts] Home collectibles:", Object.keys(farm.home?.collectibles || {}));
      const allEquipped = getAllEquippedWearables(farm);
      console.log("[Cooking Boosts] Main bumpkin equipped:", allEquipped[0]);
      console.log("[Cooking Boosts] Farm hands equipped:", allEquipped.slice(1));
      console.log("[Cooking Boosts] farmHands raw:", farm.farmHands);
      console.log("[Cooking Boosts] Skills:", Object.keys(skills));

      // === XP BOOSTS ===
      // Skills
      if (skills["Munching Mastery"]) xpBoosts.push({ name: "Munching Mastery", multiplier: 1.05 });
      if (skills["Juicy Boost"]) xpBoosts.push({ name: "Juicy Boost", multiplier: 1.1, buildings: ["Smoothie Shack"] });
      if (skills["Drive-Through Deli"]) xpBoosts.push({ name: "Drive-Through Deli", multiplier: 1.15, buildings: ["Deli"] });
      if (skills["Buzzworthy Treats"]) xpBoosts.push({ name: "Buzzworthy Treats", multiplier: 1.1, honeyOnly: true });
      // Items (check both collectibles + wearables)
      if (hasItem("Golden Spatula")) xpBoosts.push({ name: "Golden Spatula", multiplier: 1.1 });
      if (hasItem("Observatory")) xpBoosts.push({ name: "Observatory", multiplier: 1.05 });
      if (hasItem("Blossombeard")) xpBoosts.push({ name: "Blossombeard", multiplier: 1.1 });
      if (hasItem("Grain Grinder")) xpBoosts.push({ name: "Grain Grinder", multiplier: 1.2, buildings: ["Bakery"] });
      if (hasItem("Lifetime Farmer Banner")) xpBoosts.push({ name: "Lifetime Farmer Banner", multiplier: 1.1 });

      // === PET STREAK (auto-detect from faction) ===
      const faction = farm.faction || {};
      const factionHistory = faction.history || {};
      const sortedWeeks = Object.keys(factionHistory).sort();
      const currentWeekKey = sortedWeeks[sortedWeeks.length - 1] || "";
      const prevWeekKey = sortedWeeks[sortedWeeks.length - 2] || "";
      const currentWeekData = factionHistory[currentWeekKey] || {};
      const prevWeekData = factionHistory[prevWeekKey] || {};
      const petStreak = currentWeekData.collectivePet?.streak || 0;
      const streakMultiplier = petStreak >= 8 ? 1.5 : petStreak >= 6 ? 1.3 : petStreak >= 4 ? 1.2 : petStreak >= 2 ? 1.1 : 1.0;
      const weeksToMax = petStreak >= 8 ? 0 : 8 - petStreak;
      // This week: boost active if player fed pet LAST week (petXP > 0)
      const thisWeekActive = (prevWeekData.petXP || 0) > 0 && streakMultiplier > 1;
      // Next week: qualifiesForBoost = player fed pet THIS week
      const nextWeekQualified = faction.pet?.qualifiesForBoost === true;
      const manualPetStreak = localStorage.getItem("sfl_pet_streak") === "1";

      if (thisWeekActive) {
        xpBoosts.push({ name: "Pet's Streak", multiplier: streakMultiplier, petStreak: true });
      } else if (manualPetStreak) {
        xpBoosts.push({ name: "Pet's Streak (simulate)", multiplier: 1.5, petStreak: true, manual: true });
      }

      const petStreakInfo = { streak: petStreak, multiplier: streakMultiplier, thisWeekActive, nextWeekQualified, weeksToMax, manualOverride: manualPetStreak };

      // === TIME BOOSTS ===
      // Skills
      if (skills["Double Nom"]) timeBoosts.push({ name: "Double Nom", multiplier: 0.5 });
      if (skills["Fast Feasts"]) timeBoosts.push({ name: "Fast Feasts", multiplier: 0.9, buildings: ["Fire Pit", "Kitchen"] });
      if (skills["Frosted Cakes"]) timeBoosts.push({ name: "Frosted Cakes", multiplier: 0.9, buildings: ["Bakery"] });
      // Items
      if (hasItem("Luna's Hat")) timeBoosts.push({ name: "Luna's Hat", multiplier: 0.5 });
      if (hasItem("Desert Gnome")) timeBoosts.push({ name: "Desert Gnome", multiplier: 0.9 });
      if (hasAny("Nightshade Medallion")) timeBoosts.push({ name: "Nightshade Medallion", multiplier: 0.75 });
      if (hasAny("Master Chefs Cleaver", "Master Chef's Cleaver")) timeBoosts.push({ name: "Master Chefs Cleaver", multiplier: 0.85 });

      console.log("[Cooking Boosts] Detected XP:", xpBoosts.map(b => b.name));
      console.log("[Cooking Boosts] Detected Time:", timeBoosts.map(b => b.name));
      console.log("[Cooking Boosts] Pet Streak:", petStreakInfo);

      return { xpBoosts, timeBoosts, petStreakInfo };
    }

    function computeFoodXP(foodName, food, buildingName, boosts) {
      let xp = food.xp;
      for (const b of boosts.xpBoosts) {
        if (b.buildings && !b.buildings.includes(buildingName)) continue;
        if (b.honeyOnly && !food.usesHoney) continue;
        xp *= b.multiplier;
      }
      return xp;
    }

    function computeCookTime(baseSec, buildingName, boosts) {
      let time = baseSec;
      for (const b of boosts.timeBoosts) {
        if (b.buildings && !b.buildings.includes(buildingName)) continue;
        time *= b.multiplier;
      }
      return time;
    }

    function formatCookTime(seconds) {
      if (seconds <= 0) return "Instant";
      const h = Math.floor(seconds / 3600);
      const m = Math.floor((seconds % 3600) / 60);
      const s = Math.floor(seconds % 60);
      if (h >= 24) { const d = Math.floor(h / 24); const rh = h % 24; return rh > 0 ? `${d}d ${rh}h` : `${d}d`; }
      if (h > 0 && m > 0) return `${h}h ${m}m`;
      if (h > 0) return `${h}h`;
      if (m > 0 && s > 0) return `${m}m ${s}s`;
      if (m > 0) return `${m}m`;
      return `${s}s`;
    }

    const BUMPKIN_DEFAULT_RECIPES = {
      "Fire Pit": "Pizza Margherita",
      "Kitchen": "Spaghetti al Limone",
      "Bakery": "Lemon Cheesecake",
      "Deli": "Honey Cheddar",
      "Smoothie Shack": "Sour Shake",
    };

    function getSavedBumpkinRecipes() {
      try {
        const saved = localStorage.getItem("sfl_bumpkin_recipes");
        return saved ? JSON.parse(saved) : {};
      } catch (e) { return {}; }
    }

    function selectBumpkinRecipe(building, recipe) {
      const saved = getSavedBumpkinRecipes();
      saved[building] = recipe;
      localStorage.setItem("sfl_bumpkin_recipes", JSON.stringify(saved));
      if (cachedFarmData) renderBumpkin(cachedFarmData);
    }

    function togglePetStreak() {
      const on = localStorage.getItem("sfl_pet_streak") === "1";
      localStorage.setItem("sfl_pet_streak", on ? "0" : "1");
      if (cachedFarmData) renderBumpkin(cachedFarmData);
    }

    function toggleFoodInventory() {
      const el = document.getElementById("food-inv-list");
      if (el) el.style.display = el.style.display === "none" ? "block" : "none";
      const arrow = document.getElementById("food-inv-arrow");
      if (arrow) arrow.textContent = el.style.display === "none" ? "‚ñ∂" : "‚ñº";
    }

    function setBumpkinTargetLevel(val) {
      localStorage.setItem("sfl_bumpkin_target", val);
      if (cachedFarmData) renderBumpkin(cachedFarmData);
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  DEPENDENCY COMPUTATION (flowers)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function isFlowerInput(inputName) {
      return FLOWER_RECIPES[inputName] !== undefined;
    }

    function buildDependencyGraph() {
      const dependents = {};
      for (const [name, recipe] of Object.entries(FLOWER_RECIPES)) {
        if (isFlowerInput(recipe.input)) {
          if (!dependents[recipe.input]) dependents[recipe.input] = [];
          dependents[recipe.input].push(name);
        }
      }
      return dependents;
    }

    function computeAllTotalNeeded(inventory, inProgress) {
      const dependents = buildDependencyGraph();
      const memo = {};
      const visiting = new Set();

      function compute(name) {
        if (memo[name] !== undefined) return memo[name];
        if (visiting.has(name)) return LIMIT;
        visiting.add(name);
        let total = LIMIT;
        const deps = dependents[name] || [];
        for (const dep of deps) {
          const depNeeded = compute(dep);
          const depHave = getCount(inventory, dep) + (inProgress[dep] || 0);
          total += Math.max(0, depNeeded - depHave);
        }
        visiting.delete(name);
        memo[name] = total;
        return total;
      }

      const result = {};
      for (const name of Object.keys(FLOWER_RECIPES)) {
        result[name] = compute(name);
      }
      return { totalNeeded: result, dependents };
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  API FETCH
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function extractInProgress(farm) {
      const pending = {};
      const add = (name, qty) => { pending[name] = (pending[name] || 0) + qty; };

      // Flowers
      const beds = farm.flowers?.flowerBeds || {};
      for (const bed of Object.values(beds)) {
        if (bed.flower?.name) {
          const crits = bed.flower.criticalHit || {};
          const bonus = Object.values(crits).reduce((s, c) => s + c, 0);
          add(bed.flower.name, 1 + bonus);
        }
      }

      // Dolls: craftingBox
      const cb = farm.craftingBox;
      if (cb && cb.status === "crafting" && cb.item?.collectible) {
        add(cb.item.collectible, 1);
      }

      // Crustaceans: crabTraps
      const traps = farm.crabTraps?.trapSpots || {};
      for (const spot of Object.values(traps)) {
        const caught = spot.waterTrap?.caught || {};
        for (const [name, qty] of Object.entries(caught)) {
          add(name, qty);
        }
      }

      return pending;
    }

    function toMs(ts) {
      // SFL API timestamps may be in seconds or milliseconds
      return ts < 1e12 ? ts * 1000 : ts;
    }

    function extractBedDetails(flowerBeds) {
      const beds = [];
      for (const [id, bed] of Object.entries(flowerBeds)) {
        if (bed.flower?.name) {
          const name = bed.flower.name;
          const recipe = FLOWER_RECIPES[name];
          const seedType = recipe ? recipe.seed : "Unknown";
          const baseSeconds = recipe ? SEED_DATA[seedType].baseSeconds : 86400;
          const plantedAt = toMs(bed.flower.plantedAt);
          const crits = bed.flower.criticalHit || {};
          const bonus = Object.values(crits).reduce((s, c) => s + c, 0);
          const totalYield = 1 + bonus;
          const readyAt = plantedAt + baseSeconds * 1000;
          beds.push({ id, name, plantedAt, seedType, bonus, totalYield, readyAt });
        } else {
          beds.push({ id, name: null, empty: true });
        }
      }
      beds.sort((a, b) => {
        if (a.empty && !b.empty) return 1;
        if (!a.empty && b.empty) return -1;
        if (a.empty && b.empty) return 0;
        return a.readyAt - b.readyAt;
      });
      return beds;
    }

    const PETAL_BLESSED_COOLDOWN = 96 * 60 * 60;

    function extractPetalBlessed(farm) {
      const powers = farm.bumpkin?.previousPowerUseAt;
      if (!powers || powers["Petal Blessed"] === undefined) {
        return { status: "unavailable" };
      }
      const hasLunas = farm.wardrobe?.["Luna's Crescent"] > 0;
      const cooldownMs = PETAL_BLESSED_COOLDOWN * (hasLunas ? 0.5 : 1) * 1000;
      const lastUsed = toMs(powers["Petal Blessed"]);
      const nextAt = lastUsed + cooldownMs;
      if (Date.now() >= nextAt) {
        return { status: "ready" };
      }
      return { status: "cooldown", nextAt };
    }

    async function fetchFarmData() {
      if (!FARM_ID || !API_KEY) {
        throw new Error("Enter your Farm ID and API Key, then click LOAD");
      }

      const apiUrl = `https://api.sunflower-land.com/community/farms/${FARM_ID}`;
      const proxyUrl = `/api/proxy?url=${encodeURIComponent(apiUrl)}&key=${encodeURIComponent(API_KEY)}`;

      let data, lastErr;

      try {
        const resp = await fetch(proxyUrl);
        if (!resp.ok) throw new Error(`Proxy ${resp.status}`);
        data = await resp.json();
      } catch (proxyErr) {
        lastErr = proxyErr;
        console.warn("Proxy fetch failed, trying direct...", proxyErr);
        try {
          const resp = await fetch(apiUrl, { headers: { "x-api-key": API_KEY } });
          if (!resp.ok) throw new Error(`API ${resp.status}`);
          data = await resp.json();
          lastErr = null;
        } catch (directErr) {
          lastErr = directErr;
          console.warn("Direct fetch also failed:", directErr);
        }
      }

      if (!data) throw lastErr || new Error("All fetch attempts failed");

      const farm = data.farm || {};
      const inventory = farm.inventory || {};
      const flowerBeds = farm.flowers?.flowerBeds || {};
      const craftingBox = farm.craftingBox || null;
      const trapSpots = farm.crabTraps?.trapSpots || {};
      const inProgress = extractInProgress(farm);
      const petalBlessed = extractPetalBlessed(farm);
      const activeBoosts = detectFlowerBoosts(farm);
      const flowerMultiplier = computeFlowerMultiplier(activeBoosts);
      const season = farm.season?.season || null;
      return { inventory, inProgress, petalBlessed, flowerBeds, craftingBox, trapSpots, activeBoosts, flowerMultiplier, season, bumpkin: farm.bumpkin, buildings: farm.buildings, farm };
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  TIMERS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function startGrowingTimers() {
      if (growingTimerInterval) clearInterval(growingTimerInterval);
      growingTimerInterval = setInterval(() => {
        const els = document.querySelectorAll(".growing-bed-time[data-ready]");
        if (els.length === 0) { clearInterval(growingTimerInterval); return; }
        const now = Date.now();
        els.forEach(el => {
          const readyAt = parseInt(el.dataset.ready, 10);
          const diff = readyAt - now;
          if (diff <= 0) {
            el.textContent = "Ready!";
            el.classList.remove("growing");
            el.classList.add("ready");
          } else {
            const h = Math.floor(diff / 3600000);
            const m = Math.floor((diff % 3600000) / 60000);
            const s = Math.floor((diff % 60000) / 1000);
            el.textContent = h > 0
              ? `${h}h ${String(m).padStart(2,"0")}m`
              : `${m}m ${String(s).padStart(2,"0")}s`;
          }
        });
      }, 1000);
    }

    function startPBTimer() {
      if (pbTimerInterval) clearInterval(pbTimerInterval);
      const el = document.getElementById("pb-timer");
      if (!el) return;
      const nextAt = parseInt(el.dataset.next, 10);

      function tick() {
        const el = document.getElementById("pb-timer");
        if (!el) { clearInterval(pbTimerInterval); return; }
        const diff = nextAt - Date.now();
        if (diff <= 0) {
          clearInterval(pbTimerInterval);
          refresh();
          return;
        }
        const h = Math.floor(diff / 3600000);
        const m = Math.floor((diff % 3600000) / 60000);
        const s = Math.floor((diff % 60000) / 1000);
        el.textContent = `${h}h ${String(m).padStart(2,"0")}m ${String(s).padStart(2,"0")}s`;
      }

      tick();
      pbTimerInterval = setInterval(tick, 1000);
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  CHAIN DETAILS (clickable expand)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function buildChainHTML(name, inventory, inProgress, visited) {
      if (!visited) visited = new Set();
      if (visited.has(name)) return `<div class="chain-step"><span class="chain-flower">${escHTML(name)}</span> (circular ref)</div>`;
      visited.add(name);

      const recipe = FLOWER_RECIPES[name];
      if (!recipe) return "";

      const sd = SEED_DATA[recipe.seed];
      const have = getCount(inventory, name) + (inProgress[name] || 0);
      const haveClass = have > 0 ? "chain-have" : "chain-need";

      let html = `<div class="chain-step">`;
      html += `<span class="${haveClass}">${escHTML(name)}</span>`;
      html += ` <span style="color:var(--text-dim)">(have: ${have})</span>`;
      html += ` = <span class="chain-seed">${sd.label} Seed</span>`;

      if (isFlowerInput(recipe.input)) {
        html += ` + <span class="chain-flower">${escHTML(recipe.input)}</span>`;
        html += buildChainHTML(recipe.input, inventory, inProgress, visited);
      } else {
        html += ` + <span class="chain-crop">${escHTML(recipe.input)}</span> <span style="color:var(--text-dim)">(crop)</span>`;
      }
      html += `</div>`;
      return html;
    }

    function toggleChain(el) {
      const row = el.closest(".flower-row");
      const existing = row.nextElementSibling;
      if (existing && existing.classList.contains("chain-detail")) {
        existing.remove();
        return;
      }
      document.querySelectorAll(".chain-detail").forEach(d => d.remove());

      const name = row.dataset.flower;
      if (!name || !lastInventory) return;

      const recipe = FLOWER_RECIPES[name];
      if (!recipe) return;

      const sd = SEED_DATA[recipe.seed];
      let html = `<strong>Recipe:</strong> <span class="chain-seed">${sd.label} Seed</span> + `;

      if (isFlowerInput(recipe.input)) {
        html += `<span class="chain-flower">${escHTML(recipe.input)}</span>`;
        html += buildChainHTML(recipe.input, lastInventory, lastInProgress || {});
      } else {
        html += `<span class="chain-crop">${escHTML(recipe.input)}</span> <span style="color:var(--text-dim)">(crop)</span>`;
      }

      const detail = document.createElement("div");
      detail.className = "chain-detail";
      detail.innerHTML = html;
      row.after(detail);
    }

    function toggleDollChain(el) {
      const row = el.closest(".flower-row");
      const existing = row.nextElementSibling;
      if (existing && existing.classList.contains("chain-detail")) {
        existing.remove();
        return;
      }
      document.querySelectorAll(".chain-detail").forEach(d => d.remove());

      const name = row.dataset.doll;
      if (!name || !lastInventory) return;

      const ingredients = DOLL_RECIPES[name];
      if (!ingredients || ingredients.length === 0) {
        const detail = document.createElement("div");
        detail.className = "chain-detail";
        detail.innerHTML = `<span style="color:var(--text-dim)">Recipe unknown</span>`;
        row.after(detail);
        return;
      }

      let html = `<strong>Ingredients per craft:</strong>`;
      for (const ing of ingredients) {
        const have = getCount(lastInventory, ing.item);
        const ok = have >= ing.qty;
        html += `<div class="chain-step">
          <span class="${ok ? "chain-have" : "chain-need"}">${escHTML(ing.item)}</span>
          x${ing.qty} <span style="color:var(--text-dim)">(have: ${have})</span>
          ${ok ? '<span style="color:var(--green)">OK</span>' : `<span style="color:var(--red)">need ${Math.max(0, ing.qty - have)} more</span>`}
        </div>`;
      }

      const detail = document.createElement("div");
      detail.className = "chain-detail";
      detail.innerHTML = html;
      row.after(detail);
    }

    function toggleCrustChain(el) {
      const row = el.closest(".flower-row");
      const existing = row.nextElementSibling;
      if (existing && existing.classList.contains("chain-detail")) {
        existing.remove();
        return;
      }
      document.querySelectorAll(".chain-detail").forEach(d => d.remove());

      const name = row.dataset.crust;
      if (!name || !lastInventory) return;

      const recipe = CRUSTACEAN_RECIPES[name];
      if (!recipe) return;

      let html = `<strong>Pot:</strong> ${escHTML(recipe.pot)} (${recipe.time})`;

      if (recipe.chum) {
        const chumHave = getCount(lastInventory, recipe.chum);
        const ok = chumHave >= recipe.qty;
        html += `<div class="chain-step">
          <strong>Chum:</strong> <span class="${ok ? "chain-have" : "chain-need"}">${escHTML(recipe.chum)}</span>
          x${recipe.qty} <span style="color:var(--text-dim)">(have: ${chumHave})</span>
          ${ok ? '<span style="color:var(--green)">OK</span>' : `<span style="color:var(--red)">need ${Math.max(0, recipe.qty - chumHave)} more</span>`}
        </div>`;
      } else {
        html += `<div class="chain-step"><span style="color:var(--text-dim)">No chum required</span></div>`;
      }

      if (recipe.alt) {
        html += `<div class="chain-step"><strong>Alt chum:</strong> <span style="color:var(--text-secondary)">${escHTML(recipe.alt)}</span></div>`;
      }

      const detail = document.createElement("div");
      detail.className = "chain-detail";
      detail.innerHTML = html;
      row.after(detail);
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  PETAL BLESSED
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function getPetalBlessedRecommendation(inventory, inProgress) {
      const { totalNeeded } = computeAllTotalNeeded(inventory, inProgress);
      const candidates = [];
      for (const [name, needed] of Object.entries(totalNeeded)) {
        const have = getCount(inventory, name);
        const pend = inProgress[name] || 0;
        const remaining = Math.max(0, needed - have - pend);
        if (remaining <= 0) continue;
        const recipe = FLOWER_RECIPES[name];
        const seedHours = SEED_DATA[recipe.seed].hours;
        const inputIsFlower = isFlowerInput(recipe.input);
        let inputReady = true;
        if (inputIsFlower) {
          const inputHave = getCount(inventory, recipe.input) + (inProgress[recipe.input] || 0);
          if (inputHave <= 0) inputReady = false;
        }
        candidates.push({ name, remaining, seedHours, seed: recipe.seed, input: recipe.input, inputIsFlower, inputReady });
      }
      candidates.sort((a, b) => {
        if (b.seedHours !== a.seedHours) return b.seedHours - a.seedHours;
        if (a.inputReady !== b.inputReady) return a.inputReady ? -1 : 1;
        return b.remaining - a.remaining;
      });
      const picks = [];
      const used = {};
      for (const c of candidates) {
        if (picks.length >= FLOWER_BEDS) break;
        const canUse = Math.min(c.remaining - (used[c.name] || 0), FLOWER_BEDS - picks.length);
        for (let i = 0; i < canUse; i++) {
          picks.push(c);
          used[c.name] = (used[c.name] || 0) + 1;
        }
      }
      return picks;
    }

    function togglePetalBlessed() {
      const container = document.getElementById("petal-blessed-container");
      if (container.innerHTML) {
        container.innerHTML = "";
        return;
      }
      if (!lastInventory) return;

      const picks = getPetalBlessedRecommendation(lastInventory, lastInProgress);
      if (picks.length === 0) {
        container.innerHTML = `<div class="petal-blessed-panel pixel-font">
          <h3>PETAL BLESSED</h3>
          <p class="pb-subtitle">All flowers are complete! Nothing to grow.</p>
        </div>`;
        return;
      }

      const totalSaved = picks.reduce((s, p) => s + p.seedHours, 0);
      let bedsHTML = "";
      picks.forEach((p, i) => {
        const sd = SEED_DATA[p.seed];
        const inputLabel = p.inputIsFlower
          ? `${sd.label} Seed + <span style="color:var(--yellow)">${escHTML(p.input)}</span>${p.inputReady ? "" : " <span style='color:var(--red)'>(!)</span>"}`
          : `${sd.label} Seed + ${escHTML(p.input)}`;
        bedsHTML += `<div class="pb-bed">
          <div class="pb-bed-num">${i + 1}</div>
          <img class="pb-bed-img" src="${IMG_BASE}${encodeURIComponent(p.name)}.png" onerror="this.style.display='none'" alt="">
          <div class="pb-bed-info">
            <div class="pb-bed-name">${escHTML(p.name)}</div>
            <div class="pb-bed-recipe">${inputLabel}</div>
          </div>
          <div class="pb-bed-time">${formatHours(p.seedHours)}<div class="saved">saved</div></div>
        </div>`;
      });

      container.innerHTML = `<div class="petal-blessed-panel pixel-font">
        <h3>PETAL BLESSED</h3>
        <div class="pb-subtitle">Plant these ${picks.length} flowers, then use instant grow ‚Äî saves ${formatHours(totalSaved)}</div>
        ${bedsHTML}
        <button class="pb-close" onclick="togglePetalBlessed()">CLOSE</button>
      </div>`;
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  GROW PLANNER
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function getSleepSchedule() {
      try {
        const s = localStorage.getItem("sfl_sleep_schedule");
        if (s) return JSON.parse(s);
      } catch(e) {}
      return { start: 23, end: 7 };
    }

    function saveSleepSchedule(s) {
      localStorage.setItem("sfl_sleep_schedule", JSON.stringify(s));
    }

    function isHourDuringSleep(hour, sleep) {
      const s = sleep.start, e = sleep.end;
      return s < e ? (hour >= s && hour < e) : (hour >= s || hour < e);
    }

    function formatTimeShort(ms) {
      const d = new Date(ms);
      const days = ["Ne","Po","√öt","St","ƒåt","P√°","So"];
      return `${days[d.getDay()]} ${String(d.getHours()).padStart(2,"0")}:${String(d.getMinutes()).padStart(2,"0")}`;
    }

    function buildGrowPlan(flowerData, beds, petalBlessed, sleep) {
      const now = Date.now();
      let pbTime = null, pbReady = false;
      if (petalBlessed.status === "ready") { pbTime = now; pbReady = true; }
      else if (petalBlessed.status === "cooldown") { pbTime = petalBlessed.nextAt; }

      // Collect plantable incomplete flowers sorted by grow time desc
      const incomplete = [];
      for (const [name, f] of Object.entries(flowerData)) {
        if (f.isComplete || f.remaining <= 0) continue;
        const growH = SEED_DATA[f.seed].hours;
        let inputOk = !f.inputIsFlower;
        if (f.inputIsFlower) {
          const id = flowerData[f.input];
          inputOk = id && id.have > 0;
        }
        incomplete.push({ name, seed: f.seed, growH, growMs: growH * 3600000, inputOk, remaining: f.remaining });
      }
      incomplete.sort((a, b) => b.growH !== a.growH ? b.growH - a.growH : b.remaining - a.remaining);

      const alloc = {};
      const canA = f => (alloc[f.name] || 0) < f.remaining;
      const doA = f => { alloc[f.name] = (alloc[f.name] || 0) + 1; };

      const bedFree = beds.map(b => b.empty ? now : Math.max(now, b.readyAt));
      const steps = [];

      if (!pbReady) {
        for (let i = 0; i < bedFree.length; i++) {
          let t = bedFree[i];
          const limit = pbTime || (t + 30 * 24 * 3600000);
          let safety = 10;
          while (safety-- > 0 && t < limit) {
            const rem = limit - t;
            let best = null;
            for (const f of incomplete) {
              if (!f.inputOk || !canA(f)) continue;
              if (pbTime && f.growMs > rem) continue;
              best = f;
              break;
            }
            if (!best) break;
            const fin = t + best.growMs;
            const fH = new Date(fin).getHours();
            steps.push({
              flower: best.name, seed: best.seed, growH: best.growH,
              startAt: t, finishAt: fin,
              sleepWaste: isHourDuringSleep(fH, sleep),
              bedIdx: i,
            });
            doA(best);
            t = fin;
            if (!pbTime) break;
          }
        }
      }

      // PB flowers: always longest incomplete
      const pbFlowers = [];
      if (pbTime) {
        for (const f of incomplete) {
          if (pbFlowers.length >= beds.length) break;
          if (!f.inputOk || !canA(f)) continue;
          pbFlowers.push({ name: f.name, seed: f.seed, growH: f.growH });
          doA(f);
        }
      }

      // Idle before PB
      let idleH = 0;
      if (pbTime && !pbReady) {
        const lastFin = steps.length > 0 ? Math.max(...steps.map(s => s.finishAt)) : Math.min(...bedFree);
        idleH = Math.max(0, (pbTime - lastFin) / 3600000);
      }

      return { steps, pbFlowers, pbTime, pbReady, idleH };
    }

    function renderGrowPlanner(flowerData, beds, petalBlessed) {
      if (Object.values(flowerData).every(f => f.isComplete)) return "";

      const sleep = getSleepSchedule();
      const plan = buildGrowPlan(flowerData, beds, petalBlessed, sleep);
      const now = Date.now();

      let html = `<div class="planner-section">`;

      // Header
      html += `<div class="planner-header" onclick="document.getElementById('planner-body').style.display=document.getElementById('planner-body').style.display==='none'?'block':'none'">
        <span class="pixel-font" style="font-size:11px">üìã GROW PLANNER</span>
        <span style="display:flex;align-items:center;gap:10px;font-size:9px">`;
      if (plan.pbTime && !plan.pbReady) {
        const d = plan.pbTime - now;
        html += `<span class="pixel-font" style="color:var(--lily)">‚ö° PB ${Math.floor(d/3600000)}h ${Math.floor((d%3600000)/60000)}m</span>`;
      } else if (plan.pbReady) {
        html += `<span class="pixel-font" style="color:var(--green)">‚ö° PB READY</span>`;
      }
      html += `<span class="pixel-font" style="color:var(--text-dim)">üí§ ${String(sleep.start).padStart(2,"0")}-${String(sleep.end).padStart(2,"0")}</span>`;
      html += `</span></div>`;

      html += `<div id="planner-body">`;

      if (plan.pbReady && plan.pbFlowers.length > 0) {
        // PB ready NOW
        html += `<div class="planner-body"><div class="planner-batch planner-pb-box">
          <div class="planner-batch-label pixel-font" style="color:var(--lily)">‚ö° USE PETAL BLESSED NOW</div>`;
        for (const f of plan.pbFlowers) {
          html += `<div class="planner-row">
            <img src="${IMG_BASE}${encodeURIComponent(f.name)}.png" onerror="this.style.display='none'" alt="">
            <div class="planner-row-info"><div class="planner-row-name">${escHTML(f.name)}</div>
            <div class="planner-row-detail">${SEED_DATA[f.seed]?.label || "?"} ¬∑ saves ${formatHours(f.growH)}</div></div>
          </div>`;
        }
        const saved = plan.pbFlowers.reduce((s, f) => s + f.growH, 0);
        html += `<div class="planner-pb-saved pixel-font">Total saved: ${formatHours(saved)}</div>`;
        html += `</div></div>`;
      } else {
        html += `<div class="planner-body">`;

        // Group regular steps by approximate start time into batches
        if (plan.steps.length > 0) {
          const batches = [];
          const sorted = [...plan.steps].sort((a, b) => a.startAt - b.startAt);
          let cur = null;
          for (const s of sorted) {
            if (!cur || s.startAt - cur.t > 3600000) {
              cur = { t: s.startAt, items: [] };
              batches.push(cur);
            }
            cur.items.push(s);
          }

          for (const batch of batches) {
            const isNow = batch.t <= now + 60000;
            html += `<div class="planner-batch">
              <div class="planner-batch-label pixel-font">‚ñ∏ ${isNow ? "PLANT NOW" : "PLANT " + formatTimeShort(batch.t)}</div>`;
            for (const s of batch.items) {
              const cls = s.sleepWaste ? "planner-row-time sleep" : "planner-row-time";
              html += `<div class="planner-row">
                <img src="${IMG_BASE}${encodeURIComponent(s.flower)}.png" onerror="this.style.display='none'" alt="">
                <div class="planner-row-info"><div class="planner-row-name">${escHTML(s.flower)}</div>
                <div class="planner-row-detail">${SEED_DATA[s.seed]?.label || "?"} ¬∑ ${formatHours(s.growH)}</div></div>
                <div class="${cls}">‚Üí ${formatTimeShort(s.finishAt)}${s.sleepWaste ? " üí§" : ""}</div>
              </div>`;
            }
            html += `</div>`;
          }

          if (plan.idleH > 0.5 && plan.pbTime) {
            html += `<div class="planner-idle">‚è≥ ${Math.round(plan.idleH * 10) / 10}h idle before Petal Blessed</div>`;
          }
        } else if (!plan.pbTime) {
          html += `<div class="planner-idle">No Petal Blessed data ¬∑ plant highest priority flowers</div>`;
        } else {
          html += `<div class="planner-idle">‚è≥ No flowers fit before Petal Blessed ‚Äî wait for PB</div>`;
        }

        // PB batch (future)
        if (plan.pbFlowers.length > 0 && plan.pbTime && !plan.pbReady) {
          html += `<div class="planner-batch planner-pb-box">
            <div class="planner-batch-label pixel-font"><span style="color:var(--lily)">‚ö° PETAL BLESSED</span> <span style="color:var(--text-dim)">${formatTimeShort(plan.pbTime)}</span></div>`;
          for (const f of plan.pbFlowers) {
            html += `<div class="planner-row">
              <img src="${IMG_BASE}${encodeURIComponent(f.name)}.png" onerror="this.style.display='none'" alt="">
              <div class="planner-row-info"><div class="planner-row-name">${escHTML(f.name)}</div>
              <div class="planner-row-detail">${SEED_DATA[f.seed]?.label || "?"} ¬∑ saves ${formatHours(f.growH)}</div></div>
            </div>`;
          }
          const saved = plan.pbFlowers.reduce((s, f) => s + f.growH, 0);
          html += `<div class="planner-pb-saved pixel-font">Total saved: ${formatHours(saved)}</div>`;
          html += `</div>`;
        }

        html += `</div>`;
      }

      // Sleep config
      html += `<div class="planner-sleep-cfg">
        üí§ Sleep:
        <input type="number" min="0" max="23" value="${sleep.start}" onchange="updateSleepSchedule(this,'start')">:00 ‚Äî
        <input type="number" min="0" max="23" value="${sleep.end}" onchange="updateSleepSchedule(this,'end')">:00
      </div>`;

      html += `</div></div>`;
      return html;
    }

    function updateSleepSchedule(input, field) {
      const s = getSleepSchedule();
      s[field] = Math.max(0, Math.min(23, parseInt(input.value) || 0));
      saveSleepSchedule(s);
      if (cachedFarmData) renderFlowers(cachedFarmData);
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  RENDER: HUB
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function renderHub(data) {
      const app = document.getElementById("app");
      const flowerTotal = Object.keys(FLOWER_RECIPES).length;
      const trackedDolls = getTrackedDolls();
      const dollTotal = Object.entries(trackedDolls).filter(([,v]) => v).length;
      const crustTotal = Object.keys(CRUSTACEAN_RECIPES).length;

      let flowerProgress = "", dollProgress = "", crustProgress = "", bumpkinProgress = "";

      if (data) {
        const { inventory, inProgress } = data;
        const { totalNeeded } = computeAllTotalNeeded(inventory, inProgress);

        let fc = 0;
        for (const [name, needed] of Object.entries(totalNeeded)) {
          if (getCount(inventory, name) + (inProgress[name] || 0) >= needed) fc++;
        }
        flowerProgress = `<div class="hub-card-progress pixel-font">${fc}/${flowerTotal} complete</div>`;

        let dc = 0;
        for (const [name, tracked] of Object.entries(trackedDolls)) {
          if (!tracked) continue;
          if (getCount(inventory, name) + (inProgress[name] || 0) >= LIMIT) dc++;
        }
        dollProgress = `<div class="hub-card-progress pixel-font">${dc}/${dollTotal} complete</div>`;

        let cc = 0;
        for (const name of Object.keys(CRUSTACEAN_RECIPES)) {
          if (getCount(inventory, name) + (inProgress[name] || 0) >= LIMIT) cc++;
        }
        crustProgress = `<div class="hub-card-progress pixel-font">${cc}/${crustTotal} complete</div>`;

        if (data.bumpkin) {
          const bxp = parseFloat(data.bumpkin.experience || 0);
          const blvl = getBumpkinLevel(bxp);
          bumpkinProgress = `<div class="hub-card-progress pixel-font">Level ${blvl}/200</div>`;
        }
      }

      let html = `<div class="header pixel-panel pixel-font">
        <h1>SFL COLLECTION TRACKER</h1>
        ${FARM_ID ? `<div class="farm-id">Farm #${escHTML(FARM_ID)} | Target: ${LIMIT} of each</div>` : `<div class="farm-id">Enter your Farm ID &amp; API Key to get started</div>`}
      </div>`;

      html += `<div class="hub-cards">
        <div class="hub-card pixel-panel" onclick="navigateTo('flowers')">
          <div class="hub-card-icon">üå∏</div>
          <h3 class="pixel-font">FLOWERS</h3>
          <div class="hub-card-count pixel-font">${flowerTotal} types</div>
          ${flowerProgress}
        </div>
        <div class="hub-card pixel-panel" onclick="navigateTo('dolls')">
          <div class="hub-card-icon">ü™Ü</div>
          <h3 class="pixel-font">DOLLS</h3>
          <div class="hub-card-count pixel-font">${dollTotal} tracked</div>
          ${dollProgress}
        </div>
        <div class="hub-card pixel-panel" onclick="navigateTo('crustaceans')">
          <div class="hub-card-icon">ü¶Ä</div>
          <h3 class="pixel-font">CRUSTACEANS</h3>
          <div class="hub-card-count pixel-font">${crustTotal} types</div>
          ${crustProgress}
        </div>
        <div class="hub-card pixel-panel" onclick="navigateTo('bumpkin')">
          <div class="hub-card-icon">üë®‚Äçüç≥</div>
          <h3 class="pixel-font">BUMPKIN</h3>
          <div class="hub-card-count pixel-font">XP Calculator</div>
          ${bumpkinProgress}
        </div>
        <div class="hub-card pixel-panel" onclick="navigateTo('treasury')">
          <div class="hub-card-icon">üí∞</div>
          <h3 class="pixel-font">TREASURY</h3>
          <div class="hub-card-count pixel-font">Farm Value</div>
        </div>
      </div>`;

      app.innerHTML = html;
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  RENDER: FLOWERS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function renderFlowers(data) {
      const { inventory, inProgress, petalBlessed, flowerBeds, activeBoosts, flowerMultiplier, season } = data;
      lastInventory = inventory;
      lastInProgress = inProgress;

      const { totalNeeded, dependents } = computeAllTotalNeeded(inventory, inProgress);
      const app = document.getElementById("app");

      const groups = {};
      for (const seed of SEED_ORDER) groups[seed] = [];
      for (const [name, recipe] of Object.entries(FLOWER_RECIPES)) {
        groups[recipe.seed].push(name);
      }

      const flowerData = {};
      let totalComplete = 0, totalAll = 0, grandRemaining = 0;

      for (const [name, needed] of Object.entries(totalNeeded)) {
        const have = getCount(inventory, name);
        const pend = inProgress[name] || 0;
        const remaining = Math.max(0, needed - have - pend);
        const isComplete = remaining === 0;
        if (isComplete) totalComplete++;
        totalAll++;
        grandRemaining += remaining;
        const recipe = FLOWER_RECIPES[name];
        flowerData[name] = {
          name, needed, have, pend, remaining, isComplete,
          seed: recipe.seed, input: recipe.input,
          inputIsFlower: isFlowerInput(recipe.input),
          consumedBy: dependents[name] || [],
          ownNeed: LIMIT, depNeed: needed - LIMIT,
        };
      }

      const seedStats = {};
      for (const seed of SEED_ORDER) {
        const flowers = groups[seed];
        let rem = 0, complete = 0;
        for (const f of flowers) {
          rem += flowerData[f].remaining;
          if (flowerData[f].isComplete) complete++;
        }
        const batches = Math.ceil(rem / FLOWER_BEDS);
        const hours = batches * SEED_DATA[seed].hours;
        seedStats[seed] = { remaining: rem, complete, total: flowers.length, batches, hours };
      }

      const grandHours = Object.values(seedStats).reduce((s, x) => s + x.hours, 0);
      const pctComplete = totalAll > 0 ? Math.round((totalComplete / totalAll) * 100) : 0;

      let html = "";

      html += `<div class="header pixel-panel pixel-font">
        <h1>FLOWER TRACKER</h1>
        <div class="farm-id">Farm #${escHTML(FARM_ID)} | Target: ${LIMIT} of each${season ? ` | Season: ${escHTML(season)}` : ""}</div>
      </div>`;

      html += `<div class="summary-bar pixel-panel pixel-font">
        <div class="summary-stat"><div class="label">COMPLETE</div><div class="value complete">${totalComplete} / ${totalAll}</div></div>
        <div class="summary-stat"><div class="label">REMAINING</div><div class="value pending">${grandRemaining} grows</div></div>
        <div class="summary-stat"><div class="label">BEDS</div><div class="value" style="color:var(--sunpetal)">${FLOWER_BEDS}</div></div>
        <div class="summary-stat"><div class="label">EST. TIME</div><div class="value time">${formatHours(grandHours)}</div></div>
      </div>`;

      if (activeBoosts && activeBoosts.length > 0) {
        const pctStr = Math.round(Math.abs(1 - flowerMultiplier) * 100);
        const sign = flowerMultiplier <= 1 ? "-" : "+";
        const color = flowerMultiplier <= 1 ? "var(--green)" : "var(--red)";
        html += `<div class="boost-bar pixel-panel pixel-font" style="padding:8px 12px;display:flex;flex-wrap:wrap;align-items:center;gap:6px 12px;font-size:9px">
          <span style="color:${color}">BOOSTS ${sign}${pctStr}%</span>
          ${activeBoosts.map(b => `<span style="color:var(--text-secondary)">${escHTML(b.name)} <span style="color:var(--text-dim)">&times;${b.multiplier}</span></span>`).join("")}
          <span style="color:var(--text-dim);margin-left:auto">Sunpetal: ${formatHours(SEED_DATA["Sunpetal Seed"].hours)}</span>
        </div>`;
      }

      html += `<div class="progress-overview pixel-panel">
        <div class="progress-label pixel-font"><span>Progress</span><span>${pctComplete}%</span></div>
        <div class="progress-bar-outer"><div class="progress-bar-fill green" style="width:${pctComplete}%"></div></div>
      </div>`;

      // Currently Growing
      const plannerBeds = flowerBeds ? extractBedDetails(flowerBeds) : [];
      if (plannerBeds.length > 0) {
        html += `<div class="growing-section pixel-panel pixel-font">
          <div class="growing-title">CURRENTLY GROWING</div>
          <div class="growing-grid">`;
        const now = Date.now();
        for (const bed of plannerBeds) {
          if (bed.empty) {
            html += `<div class="growing-bed empty-bed">
              <div style="width:28px;height:28px;display:flex;align-items:center;justify-content:center;font-size:18px;opacity:0.3">üå±</div>
              <div class="growing-bed-info"><div class="growing-bed-name" style="color:var(--text-dim)">Empty</div></div>
            </div>`;
          } else {
            const diff = bed.readyAt - now;
            const isReady = diff <= 0;
            let timeStr;
            if (isReady) { timeStr = "Ready!"; }
            else { const h = Math.floor(diff/3600000); const m = Math.floor((diff%3600000)/60000); timeStr = h > 0 ? `${h}h ${String(m).padStart(2,"0")}m` : `${m}m`; }
            const sdLabel = SEED_DATA[bed.seedType]?.label || "?";
            html += `<div class="growing-bed">
              <img class="growing-bed-img" src="${IMG_BASE}${encodeURIComponent(bed.name)}.png" onerror="this.style.display='none'" alt="">
              <div class="growing-bed-info">
                <div class="growing-bed-name">${escHTML(bed.name)}</div>
                <div class="growing-bed-detail">${sdLabel} | yield: ${bed.totalYield}${bed.bonus > 0 ? ` (1+${bed.bonus})` : ""}</div>
              </div>
              <div class="growing-bed-time ${isReady ? "ready" : "growing"}" data-ready="${bed.readyAt}">${timeStr}</div>
            </div>`;
          }
        }
        html += `</div></div>`;
      }

      // Petal Blessed
      if (petalBlessed.status === "ready") {
        html += `<button class="petal-blessed-btn" onclick="togglePetalBlessed()">Petal Blessed READY ‚Äî tap to plan!</button>`;
      } else if (petalBlessed.status === "cooldown") {
        html += `<div class="petal-blessed-btn pb-cooldown" style="cursor:default;opacity:0.7;background:linear-gradient(180deg,#3b1768,#2a1050,#1e0a3c)">Petal Blessed in <span id="pb-timer" data-next="${petalBlessed.nextAt}">--:--:--</span></div>`;
      }
      html += `<div id="petal-blessed-container"></div>`;

      // Grow Planner
      html += renderGrowPlanner(flowerData, plannerBeds, petalBlessed);

      // Seed sections
      for (const seed of SEED_ORDER) {
        const sd = SEED_DATA[seed];
        const ss = seedStats[seed];
        const flowers = groups[seed];
        if (flowers.length === 0) continue;

        html += `<div class="seed-section">`;
        html += `<div class="seed-header pixel-font">
          <img class="seed-icon" src="${IMG_BASE}${encodeURIComponent(seed)}.webp" onerror="this.style.display='none'" alt="">
          <h2 style="color:${sd.color}">${sd.label}</h2>
          ${sd.season ? (() => { const inSeason = sd.season.toLowerCase() === (season || "").toLowerCase(); return `<span class="seed-badge" style="border-color:${inSeason ? 'var(--green)' : 'var(--text-dim)'};color:${inSeason ? 'var(--green)' : 'var(--text-dim)'};${inSeason ? '' : 'opacity:0.5;text-decoration:line-through'}">${sd.season}</span>`; })() : ""}
          <div class="seed-meta">
            <span>${formatHours(sd.hours)} / grow</span>
            <span>${ss.complete}/${ss.total} done</span>
            <span>${ss.remaining > 0 ? `~${ss.batches} batches = ${formatHours(ss.hours)}` : "All complete!"}</span>
          </div>
        </div>`;

        html += `<div class="flower-grid">`;

        const sorted = [...flowers].sort((a, b) => {
          const fa = flowerData[a], fb = flowerData[b];
          if (fa.isComplete !== fb.isComplete) return fa.isComplete ? 1 : -1;
          return fb.remaining - fa.remaining;
        });

        for (const fname of sorted) {
          const f = flowerData[fname];
          const pct = f.needed > 0 ? Math.min(100, Math.round(((f.have + f.pend) / f.needed) * 100)) : 100;
          const color = flowerColorCSS(fname);
          const isGradient = color.includes("gradient");

          let chainHTML = "";
          if (f.inputIsFlower) {
            const inputData = flowerData[f.input];
            const avail = inputData ? inputData.have + inputData.pend : 0;
            const inputOk = avail > 0;
            chainHTML += `<span style="color:${inputOk ? 'var(--green)' : 'var(--red)'}">${escHTML(f.input)}</span>`;
            chainHTML += ` (${avail} avail)`;
          } else {
            const cropHave = getCount(inventory, f.input);
            const cropOk = cropHave > 0;
            chainHTML += `<span style="color:${cropOk ? 'var(--green)' : 'var(--red)'}">${escHTML(f.input)}</span> (${cropHave} avail)`;
          }
          if (f.consumedBy.length > 0) {
            const tags = f.consumedBy.map(c => {
              const cd = flowerData[c];
              return `<span class="consumed-tag">${escHTML(c)} (x${cd ? cd.needed : "?"})</span>`;
            }).join("");
            chainHTML += ` <span class="consumed-by">used in</span>${tags}`;
          }

          html += `<div class="flower-row ${f.isComplete ? "complete" : ""}" data-flower="${escHTML(fname)}" onclick="toggleChain(this)">
            <div class="flower-img-wrap">
              <img class="flower-img" src="${IMG_BASE}${encodeURIComponent(fname)}.png" onerror="this.style.display='none';this.nextElementSibling.style.display='flex'" alt="">
              <div class="flower-color-dot" style="display:none;${isGradient ? "background:" + color : "background-color:" + color}"></div>
            </div>
            <div class="flower-info">
              <div class="flower-name">${escHTML(fname)}</div>
              <div class="flower-chain">${chainHTML}</div>
            </div>
            <div class="flower-progress">
              <div class="flower-bar-outer"><div class="flower-bar-fill ${barClass(pct)}" style="width:${pct}%"></div></div>
              <div class="flower-count">
                <span class="have">${f.have}${f.pend > 0 ? `<span class="pending">+${f.pend}</span>` : ""} / ${f.needed}</span>
                ${f.depNeed > 0 ? `<span style="color:var(--text-dim);font-size:9px">(${f.ownNeed}+${f.depNeed})</span>` : ""}
              </div>
            </div>
            <div class="flower-time">
              ${f.isComplete
                ? `<div class="done pixel-font">DONE</div>`
                : `<div class="remaining-count pixel-font">-${f.remaining}</div><div class="remaining-time">${formatHours(f.remaining * sd.hours)}</div>`}
            </div>
          </div>`;
        }

        html += `</div></div>`;
      }

      html += `<div class="footer">
        <button class="refresh-btn" onclick="refresh()">REFRESH</button>
        <div class="timestamp pixel-font">Updated: ${new Date().toLocaleTimeString("cs-CZ")}</div>
      </div>`;

      app.innerHTML = html;
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  RENDER: DOLLS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function renderDolls(data) {
      const { inventory, inProgress, craftingBox } = data;
      lastInventory = inventory;
      lastInProgress = inProgress;
      const app = document.getElementById("app");

      const trackedDolls = getTrackedDolls();
      const dollList = [];
      let totalComplete = 0, totalAll = 0, grandRemaining = 0;

      for (const [name, tracked] of Object.entries(trackedDolls)) {
        if (!tracked) continue;
        totalAll++;
        const have = getCount(inventory, name);
        const pend = inProgress[name] || 0;
        const remaining = Math.max(0, LIMIT - have - pend);
        const isComplete = remaining === 0;
        if (isComplete) totalComplete++;
        grandRemaining += remaining;
        dollList.push({ name, have, pend, remaining, isComplete, ingredients: DOLL_RECIPES[name] || [], needed: LIMIT });
      }

      const pctComplete = totalAll > 0 ? Math.round((totalComplete / totalAll) * 100) : 0;

      let html = `<div class="header pixel-panel pixel-font">
        <h1>DOLL TRACKER</h1>
        <div class="farm-id">Farm #${escHTML(FARM_ID)} | Target: ${LIMIT} of each</div>
      </div>`;

      // Tracked dolls toggle
      const allDollNames = Object.keys(DOLL_RECIPES);
      const trackedCount = Object.values(trackedDolls).filter(v => v).length;
      html += `<div class="config-collapsed pixel-panel pixel-font" onclick="this.nextElementSibling.style.display=this.nextElementSibling.style.display==='none'?'block':'none'" style="cursor:pointer">
        <span>Tracking ${trackedCount}/${allDollNames.length} dolls</span>
        <span class="config-toggle">CONFIGURE &#9660;</span>
      </div>
      <div style="display:none;margin-bottom:16px;padding:12px 16px;background:var(--bg-dark);border:4px solid var(--border-brown);box-shadow:0 0 0 3px #000">
        <div style="display:flex;flex-wrap:wrap;gap:6px">
          ${allDollNames.map(name => {
            const on = trackedDolls[name];
            return `<button onclick="event.stopPropagation();toggleDollTracked('${escHTML(name)}')" style="font-family:'Press Start 2P',cursive;font-size:8px;padding:6px 8px;border:2px solid ${on ? 'var(--green)' : 'var(--border-brown)'};background:${on ? 'rgba(48,209,88,0.15)' : 'var(--bg-card)'};color:${on ? 'var(--green)' : 'var(--text-dim)'};cursor:pointer;white-space:nowrap">${escHTML(name.replace(' Doll',''))}</button>`;
          }).join("")}
        </div>
      </div>`;

      html += `<div class="summary-bar pixel-panel pixel-font">
        <div class="summary-stat"><div class="label">COMPLETE</div><div class="value complete">${totalComplete} / ${totalAll}</div></div>
        <div class="summary-stat"><div class="label">REMAINING</div><div class="value pending">${grandRemaining} crafts</div></div>
      </div>`;

      html += `<div class="progress-overview pixel-panel">
        <div class="progress-label pixel-font"><span>Progress</span><span>${pctComplete}%</span></div>
        <div class="progress-bar-outer"><div class="progress-bar-fill green" style="width:${pctComplete}%"></div></div>
      </div>`;

      // Currently Crafting
      if (craftingBox && craftingBox.status === "crafting" && craftingBox.item?.collectible) {
        const readyAttr = craftingBox.readyAt ? ` data-ready="${craftingBox.readyAt}"` : "";
        html += `<div class="growing-section pixel-panel pixel-font">
          <div class="growing-title">CURRENTLY CRAFTING</div>
          <div class="growing-grid">
            <div class="growing-bed">
              <div style="font-size:24px;flex-shrink:0">ü™Ü</div>
              <div class="growing-bed-info">
                <div class="growing-bed-name">${escHTML(craftingBox.item.collectible)}</div>
                <div class="growing-bed-detail">Crafting Box</div>
              </div>
              <div class="growing-bed-time growing"${readyAttr}>Crafting...</div>
            </div>
          </div>
        </div>`;
      }

      // Doll list
      const sorted = dollList.sort((a, b) => {
        if (a.isComplete !== b.isComplete) return a.isComplete ? 1 : -1;
        return b.remaining - a.remaining;
      });

      html += `<div class="flower-grid" style="border:3px solid var(--border-dark)">`;
      for (const d of sorted) {
        const pct = d.needed > 0 ? Math.min(100, Math.round(((d.have + d.pend) / d.needed) * 100)) : 100;

        let ingredientHTML = "";
        if (d.ingredients.length === 0) {
          ingredientHTML = `<span style="color:var(--text-dim)">Recipe unknown</span>`;
        } else {
          ingredientHTML = d.ingredients.map(ing => {
            const have = getCount(inventory, ing.item);
            const ok = have >= ing.qty;
            return `<span style="color:${ok ? 'var(--green)' : 'var(--red)'}">${escHTML(ing.item)} x${ing.qty}</span>`;
          }).join(", ");
        }

        html += `<div class="flower-row ${d.isComplete ? 'complete' : ''}" data-doll="${escHTML(d.name)}" onclick="toggleDollChain(this)">
          <div class="flower-img-wrap" style="font-size:22px">ü™Ü</div>
          <div class="flower-info">
            <div class="flower-name">${escHTML(d.name)}</div>
            <div class="flower-chain">${ingredientHTML}</div>
          </div>
          <div class="flower-progress">
            <div class="flower-bar-outer"><div class="flower-bar-fill ${barClass(pct)}" style="width:${pct}%"></div></div>
            <div class="flower-count">
              <span class="have">${d.have}${d.pend > 0 ? `<span class="pending">+${d.pend}</span>` : ""} / ${d.needed}</span>
            </div>
          </div>
          <div class="flower-time">
            ${d.isComplete
              ? `<div class="done pixel-font">DONE</div>`
              : `<div class="remaining-count pixel-font">-${d.remaining}</div>`}
          </div>
        </div>`;
      }
      html += `</div>`;

      html += `<div class="footer">
        <button class="refresh-btn" onclick="refresh()">REFRESH</button>
        <div class="timestamp pixel-font">Updated: ${new Date().toLocaleTimeString("cs-CZ")}</div>
      </div>`;

      app.innerHTML = html;
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  RENDER: CRUSTACEANS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function renderCrustaceans(data) {
      const { inventory, inProgress, trapSpots } = data;
      lastInventory = inventory;
      lastInProgress = inProgress;
      const app = document.getElementById("app");

      TRAP_COUNT = Math.max(1, Object.keys(trapSpots).length);

      let totalComplete = 0, totalAll = 0, grandRemaining = 0;
      const crustData = {};

      for (const [name, recipe] of Object.entries(CRUSTACEAN_RECIPES)) {
        totalAll++;
        const have = getCount(inventory, name);
        const pend = inProgress[name] || 0;
        const remaining = Math.max(0, LIMIT - have - pend);
        const isComplete = remaining === 0;
        if (isComplete) totalComplete++;
        grandRemaining += remaining;
        crustData[name] = { name, have, pend, remaining, isComplete, ...recipe, needed: LIMIT };
      }

      const pctComplete = totalAll > 0 ? Math.round((totalComplete / totalAll) * 100) : 0;

      let html = `<div class="header pixel-panel pixel-font">
        <h1>CRUSTACEAN TRACKER</h1>
        <div class="farm-id">Farm #${escHTML(FARM_ID)} | Target: ${LIMIT} of each</div>
      </div>`;

      html += `<div class="summary-bar pixel-panel pixel-font">
        <div class="summary-stat"><div class="label">COMPLETE</div><div class="value complete">${totalComplete} / ${totalAll}</div></div>
        <div class="summary-stat"><div class="label">REMAINING</div><div class="value pending">${grandRemaining} traps</div></div>
        <div class="summary-stat"><div class="label">TRAPS</div><div class="value" style="color:var(--sunpetal)">${TRAP_COUNT}</div></div>
      </div>`;

      html += `<div class="progress-overview pixel-panel">
        <div class="progress-label pixel-font"><span>Progress</span><span>${pctComplete}%</span></div>
        <div class="progress-bar-outer"><div class="progress-bar-fill green" style="width:${pctComplete}%"></div></div>
      </div>`;

      // Currently Trapping (caught, ready to collect)
      const caughtItems = [];
      for (const [id, spot] of Object.entries(trapSpots)) {
        const caught = spot.waterTrap?.caught || {};
        for (const [name, qty] of Object.entries(caught)) {
          caughtItems.push({ id, name, qty });
        }
      }

      if (caughtItems.length > 0) {
        html += `<div class="growing-section pixel-panel pixel-font">
          <div class="growing-title">READY TO COLLECT</div>
          <div class="growing-grid">`;
        for (const c of caughtItems) {
          html += `<div class="growing-bed">
            <div style="font-size:24px;flex-shrink:0">ü¶Ä</div>
            <div class="growing-bed-info">
              <div class="growing-bed-name">${escHTML(c.name)}</div>
              <div class="growing-bed-detail">x${c.qty}</div>
            </div>
            <div class="growing-bed-time ready">Collect!</div>
          </div>`;
        }
        html += `</div></div>`;
      }

      // Pot sections
      const potGroups = {
        "Crab Pot": { label: "CRAB POT", time: "4h", emoji: "ü¶Ä", items: [] },
        "Mariner Pot": { label: "MARINER POT", time: "8h", emoji: "üêü", items: [] },
      };

      for (const [name, d] of Object.entries(crustData)) {
        potGroups[d.pot].items.push(d);
      }

      for (const [potType, group] of Object.entries(potGroups)) {
        const sorted = [...group.items].sort((a, b) => {
          if (a.isComplete !== b.isComplete) return a.isComplete ? 1 : -1;
          return b.remaining - a.remaining;
        });

        const complete = sorted.filter(d => d.isComplete).length;

        html += `<div class="seed-section">
          <div class="seed-header pixel-font">
            <div style="font-size:22px">${group.emoji}</div>
            <h2 style="color:var(--blue)">${group.label}</h2>
            <div class="seed-meta">
              <span>${group.time} / trap</span>
              <span>${complete}/${sorted.length} done</span>
            </div>
          </div>
          <div class="flower-grid">`;

        for (const d of sorted) {
          const pct = d.needed > 0 ? Math.min(100, Math.round(((d.have + d.pend) / d.needed) * 100)) : 100;

          let chumHTML = "";
          if (d.chum) {
            const chumHave = getCount(inventory, d.chum);
            const ok = chumHave >= d.qty;
            chumHTML = `<span style="color:${ok ? 'var(--green)' : 'var(--red)'}">${escHTML(d.chum)} x${d.qty}</span>`;
            if (d.alt) chumHTML += ` <span style="color:var(--text-dim);font-size:10px">alt: ${escHTML(d.alt)}</span>`;
          } else {
            chumHTML = `<span style="color:var(--text-dim)">No chum needed</span>`;
          }

          html += `<div class="flower-row ${d.isComplete ? 'complete' : ''}" data-crust="${escHTML(d.name)}" onclick="toggleCrustChain(this)">
            <div class="flower-img-wrap" style="font-size:18px">${group.emoji}</div>
            <div class="flower-info">
              <div class="flower-name">${escHTML(d.name)}</div>
              <div class="flower-chain">${chumHTML}</div>
            </div>
            <div class="flower-progress">
              <div class="flower-bar-outer"><div class="flower-bar-fill ${barClass(pct)}" style="width:${pct}%"></div></div>
              <div class="flower-count">
                <span class="have">${d.have}${d.pend > 0 ? `<span class="pending">+${d.pend}</span>` : ""} / ${d.needed}</span>
              </div>
            </div>
            <div class="flower-time">
              ${d.isComplete
                ? `<div class="done pixel-font">DONE</div>`
                : `<div class="remaining-count pixel-font">-${d.remaining}</div>`}
            </div>
          </div>`;
        }

        html += `</div></div>`;
      }

      html += `<div class="footer">
        <button class="refresh-btn" onclick="refresh()">REFRESH</button>
        <div class="timestamp pixel-font">Updated: ${new Date().toLocaleTimeString("cs-CZ")}</div>
      </div>`;

      app.innerHTML = html;
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  RENDER: BUMPKIN
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function renderBumpkin(data) {
      const { bumpkin, buildings, farm } = data;
      const app = document.getElementById("app");

      if (!bumpkin) {
        app.innerHTML = `<div class="error-screen pixel-panel pixel-font">
          <div class="icon">‚ö†Ô∏è</div>
          <h2>No bumpkin data found</h2>
          <p>Make sure your API key has the correct permissions.</p>
        </div>`;
        return;
      }

      const currentXP = parseFloat(bumpkin.experience || 0);
      const currentLevel = getBumpkinLevel(currentXP);
      const maxXP = BUMPKIN_XP_TABLE[199];

      // Target level (user-adjustable)
      const savedTarget = parseInt(localStorage.getItem("sfl_bumpkin_target") || "200");
      const targetLevel = Math.max(currentLevel + 1, Math.min(200, savedTarget));
      const targetXP = BUMPKIN_XP_TABLE[targetLevel - 1];
      const xpRemaining = Math.max(0, targetXP - currentXP);
      const xpPctTotal = Math.min(100, (currentXP / maxXP) * 100);
      const xpPctTarget = Math.min(100, (currentXP / targetXP) * 100);

      // Level progress within current level
      const nextLevelXP = currentLevel < 200 ? BUMPKIN_XP_TABLE[currentLevel] : maxXP;
      const prevLevelXP = BUMPKIN_XP_TABLE[currentLevel - 1];
      const levelProgress = currentLevel >= 200 ? 100 :
        Math.round(((currentXP - prevLevelXP) / (nextLevelXP - prevLevelXP)) * 100);

      // Detect owned cooking buildings
      const ownedBuildings = {};
      for (const name of COOKING_BUILDING_NAMES) {
        const count = (buildings?.[name] || []).length;
        if (count > 0) ownedBuildings[name] = count;
      }

      // Detect cooking boosts
      const boosts = detectCookingBoosts(farm);
      const savedRecipes = getSavedBumpkinRecipes();

      // Calculate XP banked in food inventory
      const inventory = data.inventory || {};
      const foodInInventory = [];
      let bankedXP = 0;
      for (const [foodName, recipe] of Object.entries(COOKING_RECIPES_DATA)) {
        const qty = getCount(inventory, foodName);
        if (qty > 0) {
          const xpEach = computeFoodXP(foodName, recipe, recipe.building, boosts);
          const totalFoodXP = xpEach * qty;
          bankedXP += totalFoodXP;
          foodInInventory.push({ name: foodName, qty, xpEach, totalFoodXP });
        }
      }
      foodInInventory.sort((a, b) => b.totalFoodXP - a.totalFoodXP);
      const xpAfterFood = Math.max(0, xpRemaining - bankedXP);

      let html = "";

      // Header
      html += `<div class="header pixel-panel pixel-font">
        <h1>BUMPKIN XP CALCULATOR</h1>
        <div class="farm-id">Farm #${escHTML(FARM_ID)}</div>
      </div>`;

      // Level section
      html += `<div class="bumpkin-xp-section pixel-panel pixel-font">
        <div class="bumpkin-level-big">LVL ${currentLevel}</div>
        <div class="bumpkin-xp-info">
          ${Math.floor(currentXP).toLocaleString()} XP${xpRemaining > 0 ? ` ‚Äî ${Math.ceil(xpRemaining).toLocaleString()} XP to level ${targetLevel}` : " ‚Äî MAX LEVEL!"}
        </div>
        <div style="display:flex;align-items:center;gap:8px;margin:8px 0 4px">
          <span style="font-size:9px;color:var(--text-dim);white-space:nowrap">Target LVL</span>
          <input type="range" min="${currentLevel + 1}" max="200" value="${targetLevel}" oninput="document.getElementById('target-val').textContent=this.value" onchange="setBumpkinTargetLevel(this.value)" style="flex:1;accent-color:var(--sunpetal);cursor:pointer">
          <span id="target-val" style="font-size:11px;color:var(--sunpetal);min-width:24px;text-align:right">${targetLevel}</span>
        </div>
        <div class="progress-bar-outer"><div class="progress-bar-fill green" style="width:${xpPctTarget.toFixed(2)}%"></div></div>
        <div style="font-size:9px;color:var(--text-dim);margin-top:2px">${xpPctTarget.toFixed(1)}% to level ${targetLevel}</div>
        ${currentLevel < 200 ? `<div style="margin-top:6px;font-size:9px;color:var(--text-dim)">Level ${currentLevel} ‚Üí ${currentLevel + 1}: ${levelProgress}%</div>` : ""}
      </div>`;

      // Food in inventory
      if (bankedXP > 0) {
        const fmtXP = (v) => v % 1 === 0 ? v.toLocaleString() : v.toLocaleString(undefined, { maximumFractionDigits: 0 });
        html += `<div class="bumpkin-boosts pixel-panel pixel-font" style="display:block">
          <h4 style="color:var(--sunpetal);margin-bottom:6px;padding-bottom:4px;border-bottom:2px solid rgba(92,58,30,0.4);font-size:10px;cursor:pointer" onclick="toggleFoodInventory()">
            <span id="food-inv-arrow">‚ñ∂</span> FOOD IN INVENTORY ‚Äî ${fmtXP(bankedXP)} XP (${foodInInventory.length} items)
          </h4>
          <div id="food-inv-list" style="display:none">
            <div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(200px,1fr));gap:2px 16px">
              ${foodInInventory.map(f => `<div class="boost-row"><span>${f.qty}√ó ${escHTML(f.name)}</span><span class="boost-val" style="color:var(--green)">${fmtXP(f.totalFoodXP)} XP</span></div>`).join("")}
            </div>
          </div>
          ${xpAfterFood > 0 ? `<div style="margin-top:6px;padding-top:4px;border-top:2px solid rgba(92,58,30,0.4);color:var(--text-secondary)">After eating: <span style="color:var(--yellow)">${fmtXP(xpAfterFood)}</span> XP still needed</div>` : `<div style="margin-top:6px;padding-top:4px;border-top:2px solid rgba(92,58,30,0.4);color:var(--green)">Eating all food would reach level ${targetLevel}!</div>`}
        </div>`;
      }

      // Boosts section ‚Äî always show both columns
      {
        const ps = boosts.petStreakInfo;
        const xpLabel = (b) => {
          let tag = "";
          if (b.buildings) tag = ` (${b.buildings.join(", ")})`;
          if (b.honeyOnly) tag = " (honey)";
          return tag;
        };
        // Pet streak section
        let petStreakHTML = `<div style="margin-top:8px;padding-top:8px;border-top:1px solid rgba(92,58,30,0.3)">`;
        // This week status
        if (ps.thisWeekActive) {
          petStreakHTML += `<div class="boost-row"><span>Pet's Streak (${ps.streak}w)</span><span class="boost-val" style="color:var(--green)">√ó${ps.multiplier}</span></div>`;
        } else {
          petStreakHTML += `<div class="boost-row" style="color:var(--text-dim)"><span>Pet's Streak (${ps.streak}w) ‚Äî inactive</span><span class="boost-val">√ó${ps.multiplier}</span></div>`;
        }
        // Next week status
        if (!ps.nextWeekQualified) {
          petStreakHTML += `<div style="font-size:9px;color:#c0392b;margin:2px 0">Feed pet to qualify for next week!</div>`;
        } else {
          petStreakHTML += `<div style="font-size:9px;color:var(--green);margin:2px 0">Qualified for next week</div>`;
        }
        if (ps.weeksToMax > 0) {
          petStreakHTML += `<div style="font-size:9px;color:var(--text-dim)">${ps.weeksToMax}w to max √ó1.5</div>`;
        }
        petStreakHTML += `<div class="boost-row" style="margin-top:4px">
          <label style="display:flex;align-items:center;gap:6px;cursor:pointer;color:${ps.manualOverride ? "var(--green)" : "var(--text-dim)"}">
            <input type="checkbox" ${ps.manualOverride ? "checked" : ""} onchange="togglePetStreak()" style="cursor:pointer;accent-color:var(--green)">
            Simulate √ó1.5
          </label>
          <span class="boost-val" style="color:${ps.manualOverride ? "var(--green)" : "var(--text-dim)"}">√ó1.5</span>
        </div></div>`;

        html += `<div class="bumpkin-boosts pixel-panel pixel-font">
          <div class="bumpkin-boosts-col">
            <h4 style="color:var(--green)">XP BOOSTS</h4>
            ${boosts.xpBoosts.filter(b => !b.petStreak).map(b => `<div class="boost-row"><span>${escHTML(b.name)}${xpLabel(b)}</span><span class="boost-val">√ó${b.multiplier}</span></div>`).join("") || '<div style="color:var(--text-dim)">None detected</div>'}
            ${petStreakHTML}
          </div>
          <div class="bumpkin-boosts-col">
            <h4 style="color:var(--blue)">TIME BOOSTS</h4>
            ${boosts.timeBoosts.length > 0 ? boosts.timeBoosts.map(b => `<div class="boost-row"><span>${escHTML(b.name)}${b.buildings ? " (" + b.buildings.join(", ") + ")" : ""}</span><span class="boost-val">√ó${b.multiplier}</span></div>`).join("") : '<div style="color:var(--text-dim)">None detected</div>'}
          </div>
        </div>`;
      }

      // Building cards
      const buildingEntries = Object.entries(ownedBuildings);
      if (buildingEntries.length === 0) {
        html += `<div class="bumpkin-summary pixel-panel pixel-font">
          <div style="font-size:11px;color:var(--text-dim)">No cooking buildings detected.</div>
        </div>`;
      } else {
        html += `<div class="bumpkin-buildings-grid">`;

        let totalXPPerDay = 0;
        const buildingStats = [];

        for (const [buildingName, count] of buildingEntries) {
          const recipes = Object.entries(COOKING_RECIPES_DATA)
            .filter(([, r]) => r.building === buildingName && r.cookSec > 0)
            .map(([name, r]) => {
              const xp = computeFoodXP(name, r, buildingName, boosts);
              const time = computeCookTime(r.cookSec, buildingName, boosts);
              const xpPerHour = time > 0 ? (xp / time) * 3600 : 0;
              return { name, xp, time, xpPerHour };
            })
            .sort((a, b) => b.xpPerHour - a.xpPerHour);

          const selectedName = savedRecipes[buildingName] !== undefined ? savedRecipes[buildingName] : (BUMPKIN_DEFAULT_RECIPES[buildingName] || "");
          const selected = selectedName ? recipes.find(r => r.name === selectedName) : null;

          let xpPerDay = 0, cooksPerDay = 0, daysNeeded = Infinity;

          if (selected && selected.time > 0) {
            cooksPerDay = (86400 / selected.time) * count;
            xpPerDay = selected.xp * cooksPerDay;
            totalXPPerDay += xpPerDay;
            daysNeeded = xpAfterFood > 0 ? Math.ceil(xpAfterFood / xpPerDay) : 0;
          }

          buildingStats.push({ buildingName, xpPerDay, count });

          const emoji = COOKING_BUILDING_EMOJI[buildingName] || "üè†";
          const fmtXP = (v) => v % 1 === 0 ? v.toLocaleString() : v.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });

          html += `<div class="bumpkin-building-card pixel-panel">
            <div class="bumpkin-building-header pixel-font">
              <span style="font-size:20px">${emoji}</span>
              <span class="bumpkin-building-name">${escHTML(buildingName)}</span>
              ${count > 1 ? `<span class="bumpkin-building-count">√ó${count}</span>` : ""}
            </div>
            <select class="bumpkin-recipe-select" onchange="selectBumpkinRecipe('${escHTML(buildingName)}', this.value)">
              <option value="" ${!selectedName ? "selected" : ""}>-- None --</option>
              ${recipes.map(r => `<option value="${escHTML(r.name)}" ${r.name === selectedName ? "selected" : ""}>${escHTML(r.name)} (${Math.round(r.xpPerHour).toLocaleString()} XP/h)</option>`).join("")}
            </select>
            ${selected ? `<div class="bumpkin-recipe-stats">
              XP per cook: <span style="color:var(--green)">${fmtXP(selected.xp)}</span><br>
              Cook time: <span style="color:var(--blue)">${formatCookTime(selected.time)}</span><br>
              XP/hour: <span style="color:var(--sunpetal)">${fmtXP(selected.xpPerHour)}</span><br>
              XP/day${count > 1 ? " (√ó" + count + ")" : ""}: <span style="color:var(--green)">${fmtXP(xpPerDay)}</span><br>
              ${xpRemaining > 0 ? `Solo days to ${targetLevel}: <span style="color:var(--text-dim)">${daysNeeded.toLocaleString()}d</span>` : ""}
            </div>` : `<div style="font-size:10px;color:var(--text-dim)">${recipes.length > 0 ? "Not cooking" : "No recipes available"}</div>`}
          </div>`;
        }

        html += `</div>`;

        // Summary
        const totalDays = totalXPPerDay > 0 && xpAfterFood > 0 ? Math.ceil(xpAfterFood / totalXPPerDay) : 0;

        html += `<div class="bumpkin-summary pixel-panel pixel-font">
          <div style="font-size:11px;color:var(--text-secondary);margin-bottom:4px">ALL BUILDINGS COMBINED</div>
          <div style="font-size:13px;color:var(--sunpetal);margin-bottom:8px">${Math.round(totalXPPerDay).toLocaleString()} XP / day</div>
          ${xpAfterFood > 0 ? `
            <div class="bumpkin-days-big">${totalDays.toLocaleString()} days</div>
            <div style="font-size:10px;color:var(--text-dim)">to reach level ${targetLevel}${bankedXP > 0 ? " (after eating food)" : ""}</div>
          ` : `<div class="bumpkin-days-big" style="color:var(--green)">${currentLevel >= targetLevel ? "TARGET REACHED!" : "Food covers it!"}</div>`}
          ${buildingStats.length > 1 ? `<div style="margin-top:12px;font-size:9px;color:var(--text-dim);line-height:2">
            ${buildingStats.map(b => `${COOKING_BUILDING_EMOJI[b.buildingName] || ""} ${escHTML(b.buildingName)}${b.count > 1 ? " √ó" + b.count : ""}: ${Math.round(b.xpPerDay).toLocaleString()} XP/day`).join("<br>")}
          </div>` : ""}
        </div>`;
      }

      // Footer
      html += `<div class="footer">
        <button class="refresh-btn" onclick="refresh()">REFRESH</button>
        <div class="timestamp pixel-font">Updated: ${new Date().toLocaleTimeString("cs-CZ")}</div>
      </div>`;

      app.innerHTML = html;
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  TREASURY
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const TREASURY_CAT_COLORS = {
      resources: "#2ECC71",
      treasures: "#F1C40F",
      collectibles: "#E67E22",
      wearables: "#9B59B6",
      liquid: "#3498DB",
    };

    // Treasure sell prices in COINS (base, no boosts)
    const TREASURE_SELL_PRICES = {
      "Crab": 18, "Camel Bone": 12, "Sea Cucumber": 27, "Vase": 60,
      "Starfish": 135, "Sand": 12, "Old Bottle": 27, "Seaweed": 90,
      "Cockle Shell": 120, "Clam Shell": 450, "Iron Compass": 225,
      "Pipi": 225, "Pearl": 4500, "Wooden Compass": 157.5,
      "Hieroglyph": 300, "Coral": 1800, "Broken Pillar": 240,
      "Coprolite": 240, "Pirate Bounty": 9000,
    };

    // Betty sell prices in COINS (from game source crops.ts / fruits.ts)
    const BETTY_SELL_PRICES = {
      "Sunflower": 0.02, "Potato": 0.14, "Rhubarb": 0.24, "Pumpkin": 0.4,
      "Zucchini": 0.4, "Carrot": 0.8, "Yam": 0.8, "Cabbage": 1.5,
      "Broccoli": 1.5, "Soybean": 2.3, "Beetroot": 2.8, "Pepper": 3,
      "Cauliflower": 4.25, "Parsnip": 6.5, "Eggplant": 8, "Corn": 9,
      "Onion": 10, "Radish": 9.5, "Wheat": 7, "Turnip": 8,
      "Kale": 10, "Artichoke": 12, "Barley": 12,
      "Tomato": 2, "Lemon": 6, "Blueberry": 12, "Orange": 18,
      "Apple": 25, "Banana": 25, "Celestine": 200, "Lunara": 500,
      "Duskberry": 1000, "Grape": 240, "Rice": 320, "Olive": 400,
    };

    function computeBettyRate(p2pPrices) {
      let bestRate = 0, bestItem = "";
      for (const [name, sellCoins] of Object.entries(BETTY_SELL_PRICES)) {
        const p2p = p2pPrices[name];
        if (!p2p || p2p <= 0) continue;
        const rate = sellCoins / p2p;
        if (rate > bestRate) { bestRate = rate; bestItem = name; }
      }
      return { rate: bestRate, item: bestItem };
    }

    const SFL_ICON_URL = "https://sfl.world/img/source/SFL.png";
    const ITEM_ICON_BASE = "https://sfl.world/img/source/";

    function formatSFL(v) {
      if (v >= 1e6) return (v / 1e6).toFixed(2) + "M";
      if (v >= 1e4) return Math.round(v).toLocaleString();
      if (v >= 100) return v.toFixed(1);
      if (v >= 1) return v.toFixed(2);
      return v.toFixed(4);
    }
    function formatUSD(v) {
      return "$" + v.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
    }
    function formatBTC(v) {
      if (v >= 0.01) return "‚Çø" + v.toFixed(4);
      return "‚Çø" + v.toFixed(8);
    }

    async function fetchTreasuryData() {
      const proxyFetch = async (url) => {
        try {
          const resp = await fetch(`/api/proxy?url=${encodeURIComponent(url)}`);
          if (resp.ok) return resp.json();
        } catch {}
        const resp = await fetch(url);
        if (!resp.ok) throw new Error(`Fetch ${url} failed: ${resp.status}`);
        return resp.json();
      };

      const [nftData, priceData, exchangeData, btcData] = await Promise.all([
        proxyFetch("https://sfl.world/api/v1/nfts"),
        proxyFetch("https://sfl.world/api/v1/prices"),
        proxyFetch("https://sfl.world/api/v1.1/exchange"),
        proxyFetch("https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd"),
      ]);

      const nftCollectibles = {};
      for (const c of (nftData.collectibles || [])) {
        nftCollectibles[c.name] = c;
      }
      const nftWearables = {};
      for (const w of (nftData.wearables || [])) {
        nftWearables[w.name] = w;
      }

      const p2pPrices = priceData?.data?.p2p || {};
      const sflUsd = exchangeData?.sfl?.usd || 0;
      const btcUsd = btcData?.bitcoin?.usd || 0;

      // Coins: API rate (best tier) + Betty rate (best crop to sell)
      const coinTiers = Object.values(exchangeData?.coins || {});
      const bestCoinTier = coinTiers.reduce((best, t) => (!best || (t.coin / t.sfl) > (best.coin / best.sfl)) ? t : best, null);
      const coinsPerSFL_api = bestCoinTier ? (bestCoinTier.coin / bestCoinTier.sfl) : 320;
      const betty = computeBettyRate(p2pPrices);
      const coinsPerSFL_betty = betty.rate;

      // Gems: best-value tier with -30% pack discount applied
      const gemTiers = Object.values(exchangeData?.gems || {});
      const bestGemTier = gemTiers.reduce((best, t) => (!best || (t.gem / t.sfl) > (best.gem / best.sfl)) ? t : best, null);
      const gemsPerSFL = bestGemTier ? (bestGemTier.gem / (bestGemTier.sfl * 0.7)) : 0;

      return { nftCollectibles, nftWearables, p2pPrices, sflUsd, coinsPerSFL_api, coinsPerSFL_betty, bettyItem: betty.item, gemsPerSFL, btcUsd };
    }

    function computeFarmValue(farm, td, coinMode) {
      const { nftCollectibles, nftWearables, p2pPrices, sflUsd, coinsPerSFL_api, coinsPerSFL_betty, bettyItem, gemsPerSFL, btcUsd } = td;
      const coinsPerSFL = coinMode === "api" ? coinsPerSFL_api : coinMode === "betty" ? coinsPerSFL_betty : 0;
      const inventory = farm.inventory || {};
      const wardrobe = farm.wardrobe || {};
      const MIN_VALUE = 0.01;

      // Debug: log farm keys to help find gems path
      console.log("[Treasury] farm keys:", Object.keys(farm));
      console.log("[Treasury] farm.gems:", farm.gems, "| farm.bank:", farm.bank, "| inventory Gem:", inventory["Gem"]);

      // --- Resources: inventory items with P2P prices ---
      const resources = [];
      for (const [name, price] of Object.entries(p2pPrices)) {
        const qty = getCount(inventory, name);
        if (qty <= 0) continue;
        const total = qty * price;
        if (total < MIN_VALUE) continue;
        resources.push({ name, qty, unitPrice: price, total });
      }
      resources.sort((a, b) => b.total - a.total);

      // --- Treasures: inventory items with coin sell prices ---
      const treasures = [];
      // Detect treasure sell boosts
      let treasureBoost = 1;
      if (findCollectible(farm, "Treasure Map").length > 0) treasureBoost += 0.2;
      // Camel: check inventory (might not be placed)
      if (getCount(inventory, "Camel") > 0 || findCollectible(farm, "Camel").length > 0) treasureBoost += 0.3;

      for (const [name, baseCoins] of Object.entries(TREASURE_SELL_PRICES)) {
        const qty = getCount(inventory, name);
        if (qty <= 0) continue;
        const boostedCoins = baseCoins * treasureBoost;
        const sflValue = coinsPerSFL > 0 ? boostedCoins / coinsPerSFL : 0;
        const total = qty * sflValue;
        if (total < MIN_VALUE) continue;
        treasures.push({ name, qty, unitPrice: sflValue, unitCoins: boostedCoins, total });
      }
      treasures.sort((a, b) => b.total - a.total);

      // --- Collectibles: inventory NFT collectibles (inventory includes placed) ---
      const collectibles = [];
      const countedCollectibles = new Set();

      for (const name of Object.keys(nftCollectibles)) {
        const nft = nftCollectibles[name];
        const floor = parseFloat(nft.floor) || 0;
        if (floor <= 0) continue;

        const qty = getCount(inventory, name);
        if (qty <= 0) continue;
        const total = qty * floor;
        if (total < MIN_VALUE) continue;
        collectibles.push({ name, qty, unitPrice: floor, total });
        countedCollectibles.add(name);
      }
      collectibles.sort((a, b) => b.total - a.total);

      // --- Wearables: wardrobe matched against NFT wearables ---
      const wearables = [];
      for (const [name, qty] of Object.entries(wardrobe)) {
        if (!qty || qty <= 0) continue;
        const nft = nftWearables[name];
        if (!nft) continue;
        const price = parseFloat(nft.lastSalePrice) || parseFloat(nft.floor) || 0;
        if (price <= 0) continue;
        const total = qty * price;
        if (total < MIN_VALUE) continue;
        wearables.push({ name, qty, unitPrice: price, total });
      }
      wearables.sort((a, b) => b.total - a.total);

      // --- Liquid: SFL balance + coins + gems ---
      const sflBalance = parseFloat(farm.balance) || 0;
      const coinBalance = parseFloat(farm.coins) || 0;
      // Try multiple paths for gems
      const gemBalance = parseFloat(farm.gems) || parseFloat(farm.bank?.gems) || getCount(inventory, "Gem") || 0;
      const coinsAsSFL = coinsPerSFL > 0 ? coinBalance / coinsPerSFL : 0;
      const gemsAsSFL = gemsPerSFL > 0 ? gemBalance / gemsPerSFL : 0;
      const liquidTotal = sflBalance + coinsAsSFL + gemsAsSFL;

      const resourcesTotal = resources.reduce((s, r) => s + r.total, 0);
      const treasuresTotal = treasures.reduce((s, t) => s + t.total, 0);
      const collectiblesTotal = collectibles.reduce((s, c) => s + c.total, 0);
      const wearablesTotal = wearables.reduce((s, w) => s + w.total, 0);
      const grandTotal = resourcesTotal + treasuresTotal + collectiblesTotal + wearablesTotal + liquidTotal;

      return {
        resources, treasures, collectibles, wearables,
        liquid: { sflBalance, coinBalance, gemBalance, coinsAsSFL, gemsAsSFL, total: liquidTotal },
        treasureBoost,
        totals: {
          resources: resourcesTotal,
          treasures: treasuresTotal,
          collectibles: collectiblesTotal,
          wearables: wearablesTotal,
          liquid: liquidTotal,
          grand: grandTotal,
        },
        rates: { sflUsd, btcUsd, coinsPerSFL, coinsPerSFL_api, coinsPerSFL_betty, bettyItem },
      };
    }

    let treasuryDetailOpen = {};
    let treasuryCoinMode = localStorage.getItem("sfl_coin_mode") || "betty";
    let cachedTreasuryData = null;

    function setCoinMode(mode) {
      treasuryCoinMode = mode;
      localStorage.setItem("sfl_coin_mode", mode);
      if (cachedTreasuryData && cachedFarmData) {
        renderTreasuryWithData(cachedFarmData, cachedTreasuryData);
      }
    }

    function toggleTreasuryDetail(cat) {
      treasuryDetailOpen[cat] = !treasuryDetailOpen[cat];
      const grid = document.getElementById("treasury-detail-" + cat);
      const arrow = document.getElementById("treasury-arrow-" + cat);
      if (grid) grid.style.display = treasuryDetailOpen[cat] ? "block" : "none";
      if (arrow) arrow.textContent = treasuryDetailOpen[cat] ? "‚ñº" : "‚ñ∂";
    }

    function renderPieChart(totals) {
      const cats = [
        { key: "resources", label: "Resources", color: TREASURY_CAT_COLORS.resources },
        { key: "treasures", label: "Treasures", color: TREASURY_CAT_COLORS.treasures },
        { key: "collectibles", label: "Collectibles", color: TREASURY_CAT_COLORS.collectibles },
        { key: "wearables", label: "Wearables", color: TREASURY_CAT_COLORS.wearables },
        { key: "liquid", label: "Liquid", color: TREASURY_CAT_COLORS.liquid },
      ];
      const grand = totals.grand || 1;
      let gradParts = [];
      let cumPct = 0;
      for (const c of cats) {
        const pct = (totals[c.key] / grand) * 100;
        if (pct < 0.1) continue;
        gradParts.push(`${c.color} ${cumPct}% ${cumPct + pct}%`);
        cumPct += pct;
      }
      if (gradParts.length === 0) gradParts.push("#333 0% 100%");
      const gradient = `conic-gradient(${gradParts.join(", ")})`;

      let legendHTML = "";
      for (const c of cats) {
        const pct = ((totals[c.key] / grand) * 100).toFixed(1);
        legendHTML += `<div><span class="treasury-pie-swatch" style="background:${c.color}"></span>${c.label}: ${pct}%</div>`;
      }

      return `<div class="treasury-pie-wrap pixel-panel">
        <div class="treasury-pie" style="background:${gradient}"></div>
        <div class="treasury-pie-legend pixel-font">${legendHTML}</div>
      </div>`;
    }

    function renderTreasuryItemRows(items) {
      if (items.length === 0) return '<div style="padding:12px;text-align:center;font-size:10px;color:var(--text-dim)">No items found</div>';
      return items.map(item => {
        const imgUrl = ITEM_ICON_BASE + encodeURIComponent(item.name) + ".png";
        return `<div class="treasury-item-row">
          <img class="treasury-item-img" src="${imgUrl}" onerror="this.style.display='none'" alt="">
          <div class="treasury-item-name" title="${escHTML(item.name)}">${escHTML(item.name)}</div>
          <div class="treasury-item-qty">√ó${item.qty}</div>
          <div class="treasury-item-unit">${formatSFL(item.unitPrice)}</div>
          <div class="treasury-item-total">${formatSFL(item.total)}</div>
        </div>`;
      }).join("");
    }

    function renderCategoryCard(key, icon, label, total, grandTotal, items) {
      const pct = grandTotal > 0 ? ((total / grandTotal) * 100) : 0;
      const color = TREASURY_CAT_COLORS[key];
      const top5 = items.slice(0, 5);
      let topHTML = "";
      for (const item of top5) {
        const imgUrl = ITEM_ICON_BASE + encodeURIComponent(item.name) + ".png";
        topHTML += `<div class="treasury-cat-top-item">
          <img src="${imgUrl}" onerror="this.style.display='none'" alt="" style="width:16px;height:16px;image-rendering:pixelated">
          <span style="flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap">${escHTML(item.name)}</span>
          <span style="color:var(--sunpetal)">${formatSFL(item.total)}</span>
        </div>`;
      }
      return `<div class="treasury-cat-card pixel-panel" onclick="toggleTreasuryDetail('${key}')">
        <div class="treasury-cat-header">
          <span class="treasury-cat-icon">${icon}</span>
          <span class="treasury-cat-name pixel-font">${label}</span>
        </div>
        <div class="treasury-cat-value pixel-font">${formatSFL(total)} SFL</div>
        <div class="treasury-cat-pct pixel-font">${pct.toFixed(1)}%</div>
        <div class="treasury-cat-bar"><div class="treasury-cat-bar-fill" style="width:${pct.toFixed(1)}%;background:${color}"></div></div>
        <div class="treasury-cat-top">${topHTML}</div>
      </div>`;
    }

    function renderTreasuryWithData(data, td) {
      const app = document.getElementById("app");
      const farm = data.farm;
      const val = computeFarmValue(farm, td, treasuryCoinMode);
      const { totals, rates, resources, treasures, collectibles, wearables, liquid, treasureBoost } = val;

      const usdTotal = totals.grand * rates.sflUsd;
      const btcTotal = rates.btcUsd > 0 ? usdTotal / rates.btcUsd : 0;

      const coinModeLabel = treasuryCoinMode === "betty"
        ? `Betty (${escHTML(rates.bettyItem)}: ${Math.round(rates.coinsPerSFL_betty)}/SFL)`
        : treasuryCoinMode === "api"
          ? `Exchange API (${Math.round(rates.coinsPerSFL_api)}/SFL)`
          : "0 (no value)";

      let html = `<div class="bumpkin-dev-banner pixel-panel pixel-font">‚ö† UNDER DEVELOPMENT ‚Äî might show incorrect data</div>
      <div class="treasury-header pixel-panel pixel-font">
        <h1>TREASURY</h1>
        <div class="farm-id">Farm #${escHTML(FARM_ID)}</div>
        <div class="treasury-total">
          <img src="${SFL_ICON_URL}" onerror="this.style.display='none'" alt="SFL">
          ${formatSFL(totals.grand)} SFL
        </div>
        <div class="treasury-secondary">${formatUSD(usdTotal)} &nbsp;|&nbsp; ${formatBTC(btcTotal)}</div>
        <div class="treasury-rates">1 SFL = ${rates.sflUsd.toFixed(4)} USD &nbsp;|&nbsp; 1 BTC = ${formatUSD(rates.btcUsd)}</div>
        <div style="margin-top:8px;font-size:9px">
          <span style="color:var(--text-dim)">Coin rate:</span>
          <select onchange="setCoinMode(this.value)" style="font-family:'Courier New',monospace;font-size:9px;background:#111;color:var(--text-primary);border:2px solid var(--border-brown);padding:2px 4px">
            <option value="betty" ${treasuryCoinMode === "betty" ? "selected" : ""}>Betty (${escHTML(rates.bettyItem)} ${Math.round(rates.coinsPerSFL_betty)}/SFL)</option>
            <option value="api" ${treasuryCoinMode === "api" ? "selected" : ""}>Exchange API (${Math.round(rates.coinsPerSFL_api)}/SFL)</option>
            <option value="zero" ${treasuryCoinMode === "zero" ? "selected" : ""}>0 (no real value)</option>
          </select>
        </div>
      </div>`;

      // Pie chart
      html += renderPieChart(totals);

      // Category cards
      html += '<div class="treasury-categories">';
      html += renderCategoryCard("resources", "‚õèÔ∏è", "RESOURCES", totals.resources, totals.grand, resources);
      html += renderCategoryCard("treasures", "üè¥‚Äç‚ò†Ô∏è", "TREASURES", totals.treasures, totals.grand, treasures);
      html += renderCategoryCard("collectibles", "üèÜ", "COLLECTIBLES", totals.collectibles, totals.grand, collectibles);
      html += renderCategoryCard("wearables", "üëï", "WEARABLES", totals.wearables, totals.grand, wearables);

      // Liquid card
      const liqPct = totals.grand > 0 ? ((totals.liquid / totals.grand) * 100) : 0;
      html += `<div class="treasury-cat-card pixel-panel">
        <div class="treasury-cat-header">
          <span class="treasury-cat-icon">üíß</span>
          <span class="treasury-cat-name pixel-font">LIQUID</span>
        </div>
        <div class="treasury-cat-value pixel-font">${formatSFL(totals.liquid)} SFL</div>
        <div class="treasury-cat-pct pixel-font">${liqPct.toFixed(1)}%</div>
        <div class="treasury-cat-bar"><div class="treasury-cat-bar-fill" style="width:${liqPct.toFixed(1)}%;background:${TREASURY_CAT_COLORS.liquid}"></div></div>
        <div class="treasury-cat-top" style="line-height:2.2">
          <div>SFL Balance: <span style="color:var(--sunpetal)">${formatSFL(liquid.sflBalance)}</span></div>
          <div>Coins: <span style="color:var(--text-secondary)">${Math.floor(liquid.coinBalance).toLocaleString()}</span> <span style="color:var(--text-dim)">(‚âà ${formatSFL(liquid.coinsAsSFL)} SFL)</span></div>
          <div>Gems: <span style="color:var(--text-secondary)">${Math.floor(liquid.gemBalance).toLocaleString()}</span> <span style="color:var(--text-dim)">(‚âà ${formatSFL(liquid.gemsAsSFL)} SFL)</span></div>
        </div>
      </div>`;
      html += '</div>';

      // Detail sections
      const boostLabel = treasureBoost > 1 ? ` (√ó${treasureBoost.toFixed(1)} boost)` : "";
      const sections = [
        { key: "resources", icon: "‚õèÔ∏è", label: "Resources", items: resources },
        { key: "treasures", icon: "üè¥‚Äç‚ò†Ô∏è", label: `Treasures${boostLabel}`, items: treasures },
        { key: "collectibles", icon: "üèÜ", label: "Collectibles", items: collectibles },
        { key: "wearables", icon: "üëï", label: "Wearables", items: wearables },
      ];
      for (const sec of sections) {
        const isOpen = treasuryDetailOpen[sec.key];
        html += `<div class="treasury-detail-section">
          <div class="treasury-detail-header pixel-panel pixel-font" onclick="toggleTreasuryDetail('${sec.key}')">
            <span>${sec.icon}</span>
            <h3>${sec.label} (${sec.items.length})</h3>
            <span class="treasury-detail-arrow" id="treasury-arrow-${sec.key}">${isOpen ? "‚ñº" : "‚ñ∂"}</span>
          </div>
          <div class="treasury-detail-grid" id="treasury-detail-${sec.key}" style="display:${isOpen ? "block" : "none"}">
            ${renderTreasuryItemRows(sec.items)}
          </div>
        </div>`;
      }

      app.innerHTML = html;
    }

    async function renderTreasury(data) {
      const app = document.getElementById("app");

      app.innerHTML = `<div class="bumpkin-dev-banner pixel-panel pixel-font">‚ö† UNDER DEVELOPMENT ‚Äî might show incorrect data</div>
      <div class="header pixel-panel pixel-font">
        <h1>TREASURY</h1>
        <div class="farm-id">Farm #${escHTML(FARM_ID)}</div>
      </div>
      <div class="loading-screen pixel-font" style="min-height:30vh">
        <div class="loading-flower">üí∞</div>
        <div class="loading-text">Fetching market data...</div>
      </div>`;

      try {
        cachedTreasuryData = await fetchTreasuryData();
        renderTreasuryWithData(data, cachedTreasuryData);
      } catch (err) {
        console.error("Treasury error:", err);
        app.innerHTML = `<div class="header pixel-panel pixel-font">
          <h1>TREASURY</h1>
          <div class="farm-id">Farm #${escHTML(FARM_ID)}</div>
        </div>
        <div class="error-screen pixel-panel pixel-font">
          <div class="icon">‚ö†Ô∏è</div>
          <h2>Failed to load market data</h2>
          <p>${escHTML(err.message)}</p>
          <button class="refresh-btn" onclick="refresh()">RETRY</button>
        </div>`;
      }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  MAIN
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function refresh() {
      cachedFarmData = null;
      main();
    }

    async function main() {
      const cfg = getConfig();
      const page = getPage();

      FARM_ID = cfg.farm;
      API_KEY = cfg.key;
      LIMIT = cfg.limit;
      FLOWER_BEDS = 4;

      renderNavBar(page);
      renderDonate();

      if (!FARM_ID || !API_KEY) {
        renderConfigBar("hub");
        renderHub(null);
        return;
      }

      renderConfigBar(page);

      const app = document.getElementById("app");

      if (!cachedFarmData) {
        app.innerHTML = `<div class="loading-screen pixel-font">
          <div class="loading-flower">üåª</div>
          <div class="loading-text">Loading farm data...</div>
        </div>`;
      }

      try {
        if (!cachedFarmData) {
          cachedFarmData = await fetchFarmData();
        }
        const data = cachedFarmData;

        // Auto-detect bed/trap counts and apply boosts
        FLOWER_BEDS = Math.max(1, Object.keys(data.flowerBeds).length);
        applyFlowerBoosts(data.flowerMultiplier);

        switch (page) {
          case "hub": renderHub(data); break;
          case "flowers": renderFlowers(data); break;
          case "dolls": renderDolls(data); break;
          case "crustaceans": renderCrustaceans(data); break;
          case "bumpkin": renderBumpkin(data); break;
          case "treasury": renderTreasury(data); break;
          default: renderHub(data);
        }

        if (page === "flowers") {
          startPBTimer();
          startGrowingTimers();
        }
        if (page === "dolls" && data.craftingBox?.readyAt) {
          startGrowingTimers();
        }

        fetch(`/api/track?farm=${FARM_ID}&page=${page}`).catch(() => {});
      } catch (err) {
        console.error(err);
        const needsConfig = !FARM_ID || !API_KEY;
        app.innerHTML = `<div class="error-screen pixel-panel pixel-font">
          <div class="icon">${needsConfig ? "üëÜ" : "‚ö†Ô∏è"}</div>
          <h2>${needsConfig ? "Enter your Farm ID & API Key above" : "Failed to load data"}</h2>
          <p>${escHTML(err.message)}</p>
          ${needsConfig ? `<p style="font-size:10px;color:var(--text-dim)">
            Get your API key at <a href="https://sfl.world" target="_blank" style="color:var(--sunpetal)">sfl.world</a><br>
            Your settings will be saved in the URL for bookmarking.
          </p>` : ""}
          <button class="refresh-btn" onclick="refresh()">RETRY</button>
        </div>`;
      }
    }

    // Enter key in config inputs triggers load
    document.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && e.target.closest(".config-bar")) applyConfig();
    });

    // Init
    migrateApiKey();
    main();
  </script>
</body>
</html>
