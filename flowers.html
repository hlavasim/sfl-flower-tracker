<!DOCTYPE html>
<html lang="cs">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <title>SFL Collection Tracker</title>
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Ccircle cx='32' cy='32' r='10' fill='%23614126'/%3E%3Cg fill='%23FFD700'%3E%3Cellipse cx='32' cy='14' rx='7' ry='12'/%3E%3Cellipse cx='32' cy='50' rx='7' ry='12'/%3E%3Cellipse cx='14' cy='32' rx='12' ry='7'/%3E%3Cellipse cx='50' cy='32' rx='12' ry='7'/%3E%3Cellipse cx='19' cy='19' rx='7' ry='12' transform='rotate(-45 19 19)'/%3E%3Cellipse cx='45' cy='45' rx='7' ry='12' transform='rotate(-45 45 45)'/%3E%3Cellipse cx='45' cy='19' rx='7' ry='12' transform='rotate(45 45 19)'/%3E%3Cellipse cx='19' cy='45' rx='7' ry='12' transform='rotate(45 19 45)'/%3E%3C/g%3E%3Ccircle cx='32' cy='32' r='8' fill='%23614126'/%3E%3C/svg%3E">
  <link rel="manifest" href="/manifest.json">
  <link rel="apple-touch-icon" href="/icon-192.svg">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="SFL Tracker">
  <meta name="theme-color" content="#1a0e08">
  <meta name="description" content="Sunflower Land collection tracker - flowers, dolls, crustaceans, treasury & more">
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-darkest: #0d0906;
      --bg-dark: #1a0e08;
      --bg-medium: #2c1810;
      --bg-light: #3e2415;
      --bg-card: #2a1a0f;
      --bg-card-alt: #231509;
      --border-dark: #000;
      --border-brown: #5c3a1e;
      --border-light: #8b6914;
      --text-primary: #f0e6d2;
      --text-secondary: #c4a882;
      --text-dim: #9a8060;
      --green: #30D158;
      --red: #FF6B6B;
      --yellow: #FFD60A;
      --blue: #5DADE2;
      --sunpetal: #FFD700;
      --bloom: #FF69B4;
      --lily: #B07CD8;
      --edelweiss: #87CEEB;
      --gladiolus: #FF6347;
      --lavender: #C8A2C8;
      --clover: #2ECC71;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: var(--bg-darkest);
      color: var(--text-primary);
      font-family: 'Courier New', monospace;
      min-height: 100vh;
      image-rendering: pixelated;
    }

    .pixel-font { font-family: 'Press Start 2P', cursive; }

    .pixel-panel {
      background: var(--bg-medium);
      border: 4px solid var(--border-brown);
      box-shadow:
        inset 3px 3px 0 rgba(255,255,255,0.08),
        inset -3px -3px 0 rgba(0,0,0,0.25),
        0 0 0 3px var(--border-dark),
        6px 6px 0 rgba(0,0,0,0.4);
    }

    .container {
      max-width: 960px;
      margin: 0 auto;
      padding: 12px;
      padding-top: max(12px, env(safe-area-inset-top));
      padding-bottom: max(12px, env(safe-area-inset-bottom));
    }

    /* ‚îÄ‚îÄ Nav Bar ‚îÄ‚îÄ */
    .nav-bar {
      display: flex;
      align-items: stretch;
      margin-bottom: 12px;
      background: var(--bg-dark);
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
    }
    .nav-link {
      font-family: 'Press Start 2P', cursive;
      font-size: 10px;
      color: var(--text-secondary);
      background: none;
      border: none;
      padding: 14px 16px;
      cursor: pointer;
      white-space: nowrap;
      border-bottom: 3px solid transparent;
      transition: color 0.15s, border-color 0.15s;
      min-height: 44px;
      display: flex;
      align-items: center;
    }
    .nav-link:hover { color: var(--text-primary); }
    .nav-link.active {
      color: var(--sunpetal);
      border-bottom-color: var(--sunpetal);
    }
    .nav-link.help-btn {
      margin-left: auto;
      font-size: 14px;
      padding: 14px 18px;
    }

    /* ‚îÄ‚îÄ Header ‚îÄ‚îÄ */
    .header {
      text-align: center;
      padding: 20px 16px;
      margin-bottom: 16px;
      background: linear-gradient(180deg, #3e2415 0%, #2c1810 100%);
      position: relative;
      overflow: hidden;
    }
    .header::before {
      content: '';
      position: absolute;
      top: 0; left: 0; right: 0;
      height: 4px;
      background: repeating-linear-gradient(90deg, var(--sunpetal) 0 8px, transparent 8px 16px);
    }
    .header h1 {
      font-size: 16px;
      letter-spacing: 1px;
      color: var(--sunpetal);
      text-shadow: 2px 2px 0 #000, 0 0 8px rgba(255,215,0,0.3);
      margin-bottom: 8px;
    }
    .header .farm-id {
      font-size: 12px;
      color: var(--text-secondary);
    }

    /* ‚îÄ‚îÄ Summary bar ‚îÄ‚îÄ */
    .summary-bar {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      justify-content: center;
      padding: 14px 16px;
      margin-bottom: 16px;
      background: var(--bg-dark);
    }
    .summary-stat {
      text-align: center;
      min-width: 100px;
    }
    .summary-stat .label {
      font-size: 10px;
      color: var(--text-dim);
      margin-bottom: 4px;
      letter-spacing: 0.5px;
    }
    .summary-stat .value {
      font-size: 16px;
      font-weight: bold;
    }
    .summary-stat .value.complete { color: var(--green); }
    .summary-stat .value.pending { color: var(--yellow); }
    .summary-stat .value.time { color: var(--blue); }

    /* ‚îÄ‚îÄ Progress overview ‚îÄ‚îÄ */
    .progress-overview {
      padding: 12px 16px;
      margin-bottom: 16px;
    }
    .progress-label {
      display: flex;
      justify-content: space-between;
      font-size: 11px;
      margin-bottom: 6px;
      color: var(--text-secondary);
    }
    .progress-bar-outer {
      background: #111;
      border: 3px solid #000;
      height: 20px;
      position: relative;
      box-shadow: inset 2px 2px 0 rgba(0,0,0,0.6);
    }
    .progress-bar-fill {
      height: 100%;
      transition: width 0.8s ease-out;
      position: relative;
    }
    .progress-bar-fill.green {
      background: linear-gradient(180deg, #4ade80 0%, #22c55e 40%, #16a34a 100%);
      box-shadow: inset 0 2px 0 rgba(255,255,255,0.25), inset 0 -2px 0 rgba(0,0,0,0.2);
    }
    .progress-bar-fill::after {
      content: '';
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: repeating-linear-gradient(
        90deg,
        transparent 0 6px,
        rgba(0,0,0,0.12) 6px 8px
      );
    }

    /* ‚îÄ‚îÄ Seed section ‚îÄ‚îÄ */
    .seed-section {
      margin-bottom: 20px;
    }
    .seed-header {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 14px;
      background: var(--bg-dark);
      border: 3px solid var(--border-dark);
      border-bottom: none;
      box-shadow: inset 3px 3px 0 rgba(255,255,255,0.05);
    }
    .seed-icon {
      width: 28px;
      height: 28px;
      image-rendering: pixelated;
      filter: drop-shadow(1px 1px 0 #000);
    }
    .seed-header h2 {
      font-size: 13px;
      flex: 1;
    }
    .seed-meta {
      font-size: 10px;
      color: var(--text-dim);
      text-align: right;
    }
    .seed-meta span { display: block; margin-top: 2px; }
    .seed-badge {
      display: inline-block;
      padding: 2px 6px;
      font-size: 9px;
      border: 2px solid;
      margin-left: 4px;
    }

    /* ‚îÄ‚îÄ Flower grid ‚îÄ‚îÄ */
    .flower-grid {
      border: 3px solid var(--border-dark);
    }

    /* ‚îÄ‚îÄ Flower row ‚îÄ‚îÄ */
    .flower-row {
      display: grid;
      grid-template-columns: 36px 1fr 100px 140px;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      border-bottom: 2px solid rgba(0,0,0,0.4);
      transition: background 0.15s;
      min-height: 48px;
      cursor: pointer;
    }
    .flower-row:nth-child(even) { background: var(--bg-card); }
    .flower-row:nth-child(odd) { background: var(--bg-card-alt); }
    .flower-row:hover { background: #382210; }
    .flower-row.complete { opacity: 0.55; }
    .flower-row.complete:hover { opacity: 0.85; }

    .flower-img-wrap {
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }
    .flower-img {
      width: 28px;
      height: 28px;
      image-rendering: pixelated;
      filter: drop-shadow(1px 1px 0 rgba(0,0,0,0.6));
    }
    .flower-color-dot {
      width: 14px;
      height: 14px;
      border: 2px solid #000;
      box-shadow: inset 2px 2px 0 rgba(255,255,255,0.3);
    }

    .flower-info { min-width: 0; }
    .flower-name {
      font-size: 13px;
      font-weight: bold;
      color: var(--text-primary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .flower-chain {
      font-size: 11px;
      color: var(--text-dim);
      margin-top: 2px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .flower-chain .input-flower { color: var(--yellow); }
    .flower-chain .consumed-by { color: #c87d38; }

    .flower-progress { min-width: 0; }
    .flower-bar-outer {
      background: #111;
      border: 2px solid #000;
      height: 12px;
      box-shadow: inset 1px 1px 0 rgba(0,0,0,0.5);
      margin-bottom: 3px;
    }
    .flower-bar-fill {
      height: 100%;
      transition: width 0.6s;
    }
    .flower-bar-fill.bar-green {
      background: linear-gradient(180deg, #4ade80, #16a34a);
    }
    .flower-bar-fill.bar-yellow {
      background: linear-gradient(180deg, #fbbf24, #d97706);
    }
    .flower-bar-fill.bar-red {
      background: linear-gradient(180deg, #f87171, #dc2626);
    }
    .flower-count {
      font-size: 11px;
      display: flex;
      justify-content: space-between;
    }
    .flower-count .have { color: var(--text-secondary); }
    .flower-count .pending { color: var(--green); font-size: 10px; }

    .flower-time {
      text-align: right;
      font-size: 11px;
      color: var(--text-dim);
    }
    .flower-time .remaining-count { color: var(--yellow); font-size: 12px; }
    .flower-time .remaining-time { color: var(--text-dim); margin-top: 2px; }
    .flower-time .done { color: var(--green); font-size: 12px; }

    /* ‚îÄ‚îÄ Loading ‚îÄ‚îÄ */
    .loading-screen {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 60vh;
      gap: 20px;
    }
    .loading-flower {
      font-size: 48px;
      animation: bounce 1s ease-in-out infinite;
    }
    @keyframes bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-12px); }
    }
    .loading-text {
      font-size: 12px;
      color: var(--text-secondary);
      animation: blink 1.2s step-end infinite;
    }
    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }

    /* ‚îÄ‚îÄ Error ‚îÄ‚îÄ */
    .error-screen {
      text-align: center;
      padding: 40px 20px;
    }
    .error-screen .icon { font-size: 40px; margin-bottom: 12px; }
    .error-screen h2 { font-size: 14px; color: var(--red); margin-bottom: 8px; }
    .error-screen p { font-size: 11px; color: var(--text-secondary); max-width: 400px; margin: 0 auto 16px; }

    /* ‚îÄ‚îÄ Footer ‚îÄ‚îÄ */
    .footer {
      text-align: center;
      padding: 16px;
      margin-top: 8px;
    }
    .refresh-btn {
      font-family: 'Press Start 2P', cursive;
      font-size: 11px;
      color: var(--text-primary);
      background: var(--bg-light);
      border: 3px solid var(--border-brown);
      padding: 8px 18px;
      cursor: pointer;
      box-shadow:
        inset 2px 2px 0 rgba(255,255,255,0.1),
        inset -2px -2px 0 rgba(0,0,0,0.3),
        3px 3px 0 #000;
      transition: transform 0.1s;
    }
    .refresh-btn:hover { background: #4a2e18; }
    .refresh-btn:active {
      transform: translate(2px, 2px);
      box-shadow: inset 2px 2px 0 rgba(0,0,0,0.3), inset -2px -2px 0 rgba(255,255,255,0.1);
    }
    .timestamp {
      font-size: 10px;
      color: var(--text-dim);
      margin-top: 10px;
    }

    /* ‚îÄ‚îÄ Tooltip for consumed-by ‚îÄ‚îÄ */
    .consumed-tag {
      display: inline-block;
      font-size: 9px;
      padding: 1px 4px;
      margin-left: 3px;
      border: 1px solid #5c3a1e;
      background: rgba(92,58,30,0.3);
      color: #c87d38;
      vertical-align: middle;
    }

    /* ‚îÄ‚îÄ Config bar ‚îÄ‚îÄ */
    .config-bar {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: flex-end;
      padding: 14px 16px;
      margin-bottom: 16px;
      background: var(--bg-dark);
    }
    .config-field {
      display: flex;
      flex-direction: column;
      gap: 4px;
      flex: 1;
      min-width: 120px;
    }
    .config-field.small { flex: 0 0 100px; min-width: 80px; }
    .config-field label {
      font-size: 9px;
      color: var(--text-dim);
      letter-spacing: 0.5px;
    }
    .config-field input {
      font-family: 'Courier New', monospace;
      font-size: 12px;
      padding: 6px 10px;
      color: var(--text-primary);
      background: #111;
      border: 3px solid var(--border-brown);
      box-shadow: inset 2px 2px 0 rgba(0,0,0,0.5);
      outline: none;
      width: 100%;
    }
    .config-field input:focus {
      border-color: var(--sunpetal);
      box-shadow: inset 2px 2px 0 rgba(0,0,0,0.5), 0 0 6px rgba(255,215,0,0.2);
    }
    .config-field input::placeholder { color: var(--text-dim); }
    .config-go {
      font-family: 'Press Start 2P', cursive;
      font-size: 11px;
      color: #fff;
      background: #2d6a30;
      border: 3px solid #1a4a1c;
      padding: 8px 16px;
      cursor: pointer;
      box-shadow: inset 2px 2px 0 rgba(255,255,255,0.15), inset -2px -2px 0 rgba(0,0,0,0.3), 3px 3px 0 #000;
      white-space: nowrap;
      transition: transform 0.1s;
    }
    .config-go:hover { background: #38833c; }
    .config-go:active {
      transform: translate(2px, 2px);
      box-shadow: inset 2px 2px 0 rgba(0,0,0,0.3);
    }

    /* ‚îÄ‚îÄ Config collapsed ‚îÄ‚îÄ */
    .config-collapsed {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 16px;
      padding: 10px 16px;
      margin-bottom: 16px;
      background: var(--bg-dark);
      cursor: pointer;
      font-size: 10px;
      color: var(--text-secondary);
    }
    .config-collapsed:hover { background: var(--bg-medium); }
    .config-toggle {
      color: var(--sunpetal);
      font-size: 9px;
    }

    /* ‚îÄ‚îÄ Donate section ‚îÄ‚îÄ */
    .donate-section {
      margin-top: 20px;
      padding: 20px 16px;
      text-align: center;
      background: linear-gradient(180deg, #2c1810 0%, #1a0e08 100%);
    }
    .donate-section h3 {
      font-size: 12px;
      color: var(--sunpetal);
      margin-bottom: 12px;
      text-shadow: 1px 1px 0 #000;
    }
    .donate-section p {
      font-size: 11px;
      color: var(--text-secondary);
      margin-bottom: 12px;
      line-height: 1.6;
    }
    .donate-qr {
      display: inline-block;
      padding: 8px;
      background: #fff;
      border: 4px solid var(--border-brown);
      box-shadow: 0 0 0 3px #000, 4px 4px 0 rgba(0,0,0,0.4);
      margin-bottom: 12px;
    }
    .donate-qr img {
      display: block;
      width: 140px;
      height: 140px;
      image-rendering: pixelated;
    }
    .donate-addr-wrap {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: #111;
      border: 3px solid var(--border-brown);
      padding: 6px 10px;
      max-width: 100%;
      box-shadow: inset 2px 2px 0 rgba(0,0,0,0.5);
    }
    .donate-addr {
      font-family: 'Courier New', monospace;
      font-size: 12px;
      color: var(--text-primary);
      word-break: break-all;
      user-select: all;
    }
    .donate-copy {
      font-family: 'Press Start 2P', cursive;
      font-size: 9px;
      color: var(--text-primary);
      background: var(--bg-light);
      border: 2px solid var(--border-brown);
      padding: 4px 8px;
      cursor: pointer;
      white-space: nowrap;
      flex-shrink: 0;
    }
    .donate-copy:hover { background: #4a2e18; }
    .donate-chain-label {
      font-size: 10px;
      color: var(--text-dim);
      margin-top: 8px;
    }

    /* ‚îÄ‚îÄ Currently Growing section ‚îÄ‚îÄ */
    .growing-section {
      margin-bottom: 16px;
      padding: 14px 16px;
      background: var(--bg-dark);
    }
    .growing-title {
      font-size: 11px;
      color: var(--sunpetal);
      text-align: center;
      margin-bottom: 10px;
      text-shadow: 1px 1px 0 #000;
    }
    .growing-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
    }
    .growing-bed {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      background: rgba(255,215,0,0.06);
      border: 2px solid rgba(92,58,30,0.5);
    }
    .growing-bed.empty-bed {
      opacity: 0.35;
      background: rgba(0,0,0,0.2);
    }
    .growing-bed-img {
      width: 28px;
      height: 28px;
      image-rendering: pixelated;
      filter: drop-shadow(1px 1px 0 #000);
      flex-shrink: 0;
    }
    .growing-bed-info { flex: 1; min-width: 0; }
    .growing-bed-name {
      font-size: 11px;
      font-weight: bold;
      color: var(--text-primary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .growing-bed-detail {
      font-size: 9px;
      color: var(--text-secondary);
      margin-top: 2px;
    }
    .growing-bed-time {
      font-family: 'Press Start 2P', cursive;
      font-size: 9px;
      text-align: right;
      white-space: nowrap;
      flex-shrink: 0;
    }
    .growing-bed-time.ready { color: var(--green); }
    .growing-bed-time.growing { color: var(--yellow); }

    /* ‚îÄ‚îÄ Chain detail (clickable rows) ‚îÄ‚îÄ */
    .chain-detail {
      padding: 10px 12px 10px 52px;
      background: rgba(0,0,0,0.3);
      border-bottom: 2px solid rgba(0,0,0,0.4);
      font-size: 11px;
      color: var(--text-secondary);
      line-height: 1.6;
    }
    .chain-detail .chain-step {
      padding-left: 14px;
      border-left: 2px solid rgba(92,58,30,0.5);
      margin-top: 4px;
    }
    .chain-detail .chain-flower { color: var(--yellow); }
    .chain-detail .chain-crop { color: var(--text-secondary); }
    .chain-detail .chain-seed { color: var(--blue); }
    .chain-detail .chain-have { color: var(--green); }
    .chain-detail .chain-need { color: var(--red); }

    /* ‚îÄ‚îÄ Petal Blessed panel ‚îÄ‚îÄ */
    .petal-blessed-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      width: 100%;
      padding: 12px 16px;
      margin-bottom: 16px;
      font-family: 'Press Start 2P', cursive;
      font-size: 11px;
      color: #fff;
      background: linear-gradient(180deg, #6b21a8 0%, #4c1d95 50%, #3b0764 100%);
      border: 4px solid #7c3aed;
      cursor: pointer;
      box-shadow:
        inset 3px 3px 0 rgba(255,255,255,0.15),
        inset -3px -3px 0 rgba(0,0,0,0.3),
        0 0 0 3px #000,
        0 0 16px rgba(124,58,237,0.3);
      transition: transform 0.1s;
      text-shadow: 1px 1px 0 #000;
    }
    .petal-blessed-btn:hover {
      background: linear-gradient(180deg, #7c3aed 0%, #5b21b6 50%, #4c1d95 100%);
      box-shadow:
        inset 3px 3px 0 rgba(255,255,255,0.2),
        inset -3px -3px 0 rgba(0,0,0,0.3),
        0 0 0 3px #000,
        0 0 24px rgba(124,58,237,0.5);
    }
    .petal-blessed-btn:active {
      transform: translate(2px, 2px);
    }
    .pb-cooldown #pb-timer {
      color: #c084fc;
      font-size: 12px;
    }
    .petal-blessed-panel {
      margin-bottom: 16px;
      padding: 16px;
      background: linear-gradient(180deg, #2e1065 0%, #1e0a3c 100%);
      border: 4px solid #7c3aed;
      box-shadow: 0 0 0 3px #000, 0 0 20px rgba(124,58,237,0.25);
    }
    .petal-blessed-panel h3 {
      font-size: 12px;
      color: #c084fc;
      text-align: center;
      margin-bottom: 4px;
      text-shadow: 0 0 8px rgba(192,132,252,0.4);
    }
    .petal-blessed-panel .pb-subtitle {
      font-size: 10px;
      color: var(--text-dim);
      text-align: center;
      margin-bottom: 14px;
    }
    .pb-bed {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      margin-bottom: 6px;
      background: rgba(124,58,237,0.1);
      border: 2px solid rgba(124,58,237,0.3);
    }
    .pb-bed-num {
      font-family: 'Press Start 2P', cursive;
      font-size: 12px;
      color: #7c3aed;
      min-width: 24px;
    }
    .pb-bed-img {
      width: 28px;
      height: 28px;
      image-rendering: pixelated;
      filter: drop-shadow(1px 1px 0 #000);
    }
    .pb-bed-info { flex: 1; min-width: 0; }
    .pb-bed-name {
      font-size: 12px;
      font-weight: bold;
      color: var(--text-primary);
    }
    .pb-bed-recipe {
      font-size: 10px;
      color: var(--text-secondary);
      margin-top: 2px;
    }
    .pb-bed-time {
      font-family: 'Press Start 2P', cursive;
      font-size: 10px;
      color: #c084fc;
      text-align: right;
      white-space: nowrap;
    }
    .pb-bed-time .saved { color: var(--green); }
    .pb-close {
      display: block;
      margin: 12px auto 0;
      font-family: 'Press Start 2P', cursive;
      font-size: 9px;
      color: var(--text-secondary);
      background: transparent;
      border: 2px solid rgba(124,58,237,0.3);
      padding: 6px 16px;
      cursor: pointer;
    }
    .pb-close:hover { border-color: #7c3aed; color: #c084fc; }

    /* ‚îÄ‚îÄ Hub cards ‚îÄ‚îÄ */
    .hub-cards {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 16px;
      margin-top: 16px;
    }
    .hub-card {
      padding: 24px 16px;
      text-align: center;
      cursor: pointer;
      transition: transform 0.15s, box-shadow 0.15s;
    }
    .hub-card:hover {
      transform: translateY(-3px);
    }
    .hub-card-icon {
      font-size: 40px;
      margin-bottom: 10px;
    }
    .hub-card h3 {
      font-size: 13px;
      color: var(--sunpetal);
      margin-bottom: 8px;
      text-shadow: 1px 1px 0 #000;
    }
    .hub-card-count {
      font-size: 10px;
      color: var(--text-secondary);
    }
    .hub-card-progress {
      font-size: 11px;
      color: var(--green);
      margin-top: 8px;
    }

    /* ‚îÄ‚îÄ Help Modal ‚îÄ‚îÄ */
    .modal-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.85);
      z-index: 10000;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }
    .modal-content {
      max-width: 520px;
      width: 100%;
      padding: 24px;
      max-height: 80vh;
      overflow-y: auto;
    }
    .modal-content h2 {
      font-size: 14px;
      color: var(--sunpetal);
      text-align: center;
      margin-bottom: 16px;
      text-shadow: 1px 1px 0 #000;
    }
    .modal-content h3 {
      font-size: 10px;
      color: var(--sunpetal);
      margin: 14px 0 6px;
    }
    .modal-content p {
      font-size: 10px;
      color: var(--text-secondary);
      line-height: 1.8;
      margin-bottom: 8px;
    }
    .modal-content a {
      color: var(--sunpetal);
      text-decoration: none;
    }
    .modal-content a:hover { text-decoration: underline; }
    .modal-close {
      display: block;
      margin: 20px auto 0;
      font-family: 'Press Start 2P', cursive;
      font-size: 10px;
      color: var(--text-primary);
      background: var(--bg-light);
      border: 3px solid var(--border-brown);
      padding: 10px 24px;
      cursor: pointer;
      box-shadow: inset 2px 2px 0 rgba(255,255,255,0.1), 3px 3px 0 #000;
    }
    .modal-close:hover { background: #4a2e18; }

    /* ‚îÄ‚îÄ Scanline overlay (subtle) ‚îÄ‚îÄ */
    body::after {
      content: '';
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      pointer-events: none;
      background: repeating-linear-gradient(
        0deg,
        transparent 0 3px,
        rgba(0,0,0,0.03) 3px 4px
      );
      z-index: 9999;
    }

    /* ‚îÄ‚îÄ Bumpkin page ‚îÄ‚îÄ */
    .bumpkin-dev-banner {
      text-align: center;
      padding: 10px 12px;
      margin-bottom: 12px;
      background: rgba(255,214,10,0.1);
      border-color: rgba(255,214,10,0.4);
      font-size: 10px;
      color: var(--yellow);
    }
    .bumpkin-xp-section {
      padding: 20px 16px;
      margin-bottom: 16px;
      text-align: center;
    }
    .bumpkin-level-big {
      font-size: 32px;
      color: var(--sunpetal);
      text-shadow: 2px 2px 0 #000, 0 0 12px rgba(255,215,0,0.3);
    }
    .bumpkin-xp-info {
      font-size: 11px;
      color: var(--text-secondary);
      margin: 8px 0 12px;
      line-height: 1.8;
    }
    .bumpkin-buildings-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 12px;
      margin-bottom: 16px;
    }
    .bumpkin-building-card { padding: 14px; }
    .bumpkin-building-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 10px;
    }
    .bumpkin-building-name { font-size: 12px; color: var(--sunpetal); }
    .bumpkin-building-count { font-size: 9px; color: var(--text-dim); }
    .bumpkin-recipe-select {
      width: 100%;
      font-family: 'Courier New', monospace;
      font-size: 11px;
      padding: 6px 8px;
      color: var(--text-primary);
      background: #111;
      border: 3px solid var(--border-brown);
      box-shadow: inset 2px 2px 0 rgba(0,0,0,0.5);
      margin-bottom: 8px;
      outline: none;
    }
    .bumpkin-recipe-select:focus {
      border-color: var(--sunpetal);
    }
    .bumpkin-recipe-stats {
      font-size: 10px;
      color: var(--text-secondary);
      line-height: 1.8;
    }
    .bumpkin-summary {
      padding: 20px 16px;
      margin-bottom: 16px;
      text-align: center;
    }
    .bumpkin-days-big {
      font-size: 28px;
      color: var(--green);
      text-shadow: 2px 2px 0 #000;
      margin: 8px 0;
    }
    .bumpkin-boosts {
      padding: 12px 16px;
      margin-bottom: 12px;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 0 20px;
      font-size: 9px;
    }
    .bumpkin-boosts-col h4 {
      font-size: 10px;
      margin-bottom: 6px;
      padding-bottom: 4px;
      border-bottom: 2px solid rgba(92,58,30,0.4);
    }
    .bumpkin-boosts-col .boost-row {
      display: flex;
      justify-content: space-between;
      padding: 3px 0;
      color: var(--text-secondary);
    }
    .bumpkin-boosts-col .boost-row .boost-val {
      color: var(--text-dim);
      white-space: nowrap;
    }

    /* ‚îÄ‚îÄ Treasury page ‚îÄ‚îÄ */
    .treasury-header {
      text-align: center;
      padding: 20px 16px;
      margin-bottom: 16px;
      background: linear-gradient(180deg, #3e2415 0%, #2c1810 100%);
    }
    .treasury-total {
      font-size: 28px;
      color: var(--sunpetal);
      text-shadow: 2px 2px 0 #000, 0 0 12px rgba(255,215,0,0.3);
      margin: 8px 0 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }
    .treasury-total img {
      width: 28px; height: 28px;
      image-rendering: pixelated;
      filter: drop-shadow(1px 1px 0 #000);
    }
    .treasury-secondary {
      font-size: 11px;
      color: var(--text-secondary);
      margin-bottom: 4px;
    }
    .treasury-rates {
      font-size: 9px;
      color: var(--text-dim);
      margin-top: 8px;
    }
    .treasury-categories {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 12px;
      margin-bottom: 16px;
    }
    .treasury-cat-card {
      padding: 14px;
      cursor: pointer;
      transition: transform 0.15s;
    }
    .treasury-cat-card:hover { transform: translateY(-2px); }
    .treasury-cat-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }
    .treasury-cat-icon { font-size: 20px; }
    .treasury-cat-name { font-size: 11px; color: var(--text-secondary); }
    .treasury-cat-value {
      font-size: 16px;
      color: var(--sunpetal);
      text-shadow: 1px 1px 0 #000;
    }
    .treasury-cat-pct {
      font-size: 9px;
      color: var(--text-dim);
      margin-top: 4px;
    }
    .treasury-cat-bar {
      height: 6px;
      background: #111;
      border: 1px solid #000;
      margin-top: 6px;
    }
    .treasury-cat-bar-fill { height: 100%; transition: width 0.6s; }
    .treasury-cat-top {
      margin-top: 8px;
      font-size: 10px;
      line-height: 1.8;
      color: var(--text-secondary);
    }
    .treasury-cat-top-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .treasury-cat-top-item img {
      width: 18px; height: 18px;
      image-rendering: pixelated;
      filter: drop-shadow(1px 1px 0 #000);
    }
    .treasury-pie-wrap {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 20px;
      margin-bottom: 16px;
      padding: 16px;
    }
    .treasury-pie {
      width: 140px; height: 140px;
      border-radius: 50%;
      border: 3px solid #000;
      box-shadow: 0 0 0 3px rgba(92,58,30,0.5), 4px 4px 0 rgba(0,0,0,0.4);
    }
    .treasury-pie-legend {
      font-size: 10px;
      line-height: 2;
      color: var(--text-secondary);
    }
    .treasury-pie-swatch {
      display: inline-block;
      width: 12px; height: 12px;
      border: 2px solid #000;
      margin-right: 6px;
      vertical-align: middle;
    }
    .treasury-detail-section { margin-bottom: 16px; }
    .treasury-detail-header {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 10px 14px;
      background: var(--bg-dark);
      border: 3px solid var(--border-dark);
      border-bottom: none;
      cursor: pointer;
    }
    .treasury-detail-header:hover { background: var(--bg-medium); }
    .treasury-detail-header h3 { font-size: 12px; flex: 1; }
    .treasury-detail-arrow { font-size: 10px; color: var(--text-dim); }
    .treasury-detail-grid { border: 3px solid var(--border-dark); }
    .treasury-item-row {
      display: grid;
      grid-template-columns: 32px 1fr 70px 80px 90px;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      border-bottom: 2px solid rgba(0,0,0,0.4);
      font-size: 11px;
      min-height: 40px;
    }
    .treasury-item-row:nth-child(even) { background: var(--bg-card); }
    .treasury-item-row:nth-child(odd) { background: var(--bg-card-alt); }
    .treasury-item-img {
      width: 24px; height: 24px;
      image-rendering: pixelated;
      filter: drop-shadow(1px 1px 0 #000);
    }
    .treasury-item-name {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      color: var(--text-primary);
    }
    .treasury-item-qty { color: var(--text-secondary); text-align: right; }
    .treasury-item-unit { color: var(--text-dim); text-align: right; }
    .treasury-item-total { color: var(--sunpetal); text-align: right; font-weight: bold; }

    /* ‚îÄ‚îÄ Changelog ‚îÄ‚îÄ */
    .changelog-toggle {
      cursor: pointer;
      color: var(--text-dim);
      opacity: 0.6;
      transition: opacity 0.2s;
      user-select: none;
    }
    .changelog-toggle:hover { opacity: 1; }
    .changelog-content {
      text-align: left;
      margin-top: 10px;
      padding-top: 10px;
      border-top: 2px solid rgba(92,58,30,0.3);
      font-family: 'Courier New', monospace;
      font-size: 10px;
      color: var(--text-secondary);
      line-height: 1.7;
      max-height: 400px;
      overflow-y: auto;
    }
    .changelog-ver {
      color: var(--sunpetal);
      font-weight: bold;
      margin-top: 8px;
      margin-bottom: 2px;
    }
    .changelog-ver:first-child { margin-top: 0; }
    .changelog-item { padding-left: 12px; color: var(--text-dim); }
    .changelog-item::before { content: "‚Ä¢ "; color: var(--text-secondary); }
    .changelog-new { color: var(--green); }
    .changelog-fix { color: var(--yellow); }

    /* ‚îÄ‚îÄ Sales Tracker ‚îÄ‚îÄ */
    .sales-listing {
      display: grid;
      grid-template-columns: 36px 1fr auto;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      border-bottom: 2px solid rgba(0,0,0,0.4);
      font-size: 11px;
      min-height: 48px;
    }
    .sales-listing:nth-child(even) { background: var(--bg-card); }
    .sales-listing:nth-child(odd) { background: var(--bg-card-alt); }
    .sales-listing-img {
      width: 28px; height: 28px;
      image-rendering: pixelated;
      filter: drop-shadow(1px 1px 0 #000);
    }
    .sales-listing-info { flex: 1; }
    .sales-listing-name { color: var(--text-primary); font-weight: bold; }
    .sales-listing-detail { font-size: 9px; color: var(--text-dim); margin-top: 2px; }
    .sales-listing-prices {
      text-align: right;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 2px;
    }
    .sales-price-yours { color: var(--sunpetal); font-weight: bold; }
    .sales-price-market { font-size: 9px; color: var(--text-dim); }
    .sales-badge {
      display: inline-block;
      font-size: 8px;
      padding: 2px 5px;
      border: 1px solid;
      font-family: 'Press Start 2P', cursive;
      margin-left: 4px;
    }
    .sales-badge.overpriced { color: var(--red); border-color: var(--red); }
    .sales-badge.good { color: var(--green); border-color: var(--green); }
    .sales-badge.stale { color: var(--yellow); border-color: var(--yellow); }
    .sales-badge.sold { color: var(--blue); border-color: var(--blue); }
    .sales-summary-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 10px;
      margin: 12px 0;
    }
    .sales-stat {
      background: var(--bg-card);
      border: 2px solid var(--border-dark);
      padding: 10px;
      text-align: center;
    }
    .sales-stat-label { font-size: 9px; color: var(--text-dim); margin-bottom: 4px; }
    .sales-stat-value { font-size: 14px; color: var(--sunpetal); text-shadow: 1px 1px 0 #000; }
    .sales-section-header {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 10px 14px;
      background: var(--bg-medium);
      border: 3px solid var(--border-dark);
      cursor: pointer;
    }
    .sales-section-header:hover { background: var(--bg-light); }
    .sales-section-header h3 { font-size: 11px; flex: 1; }
    .sales-section-count { font-size: 9px; color: var(--text-dim); }
    .sales-section-body { border: 3px solid var(--border-dark); border-top: none; }

    /* ‚îÄ‚îÄ Power Page ‚îÄ‚îÄ */
    .power-summary {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 8px;
      margin-bottom: 16px;
    }
    .power-summary-stat {
      background: var(--bg-card);
      border: 3px solid var(--border-dark);
      padding: 10px 8px;
      text-align: center;
    }
    .power-summary-label { font-size: 8px; color: var(--text-dim); margin-bottom: 4px; }
    .power-summary-value { font-size: 11px; text-shadow: 1px 1px 0 #000; }
    .power-best-buys { margin-bottom: 16px; }
    .power-section-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 14px;
      background: var(--bg-medium);
      border-bottom: 3px solid var(--border-dark);
      cursor: pointer;
      font-size: 11px;
      color: var(--sunpetal);
    }
    .power-section-header:hover { background: var(--bg-light); }
    .power-section-body { padding: 4px 0; }
    .power-bb-row {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 5px 12px;
      font-size: 10px;
      border-bottom: 1px solid rgba(0,0,0,0.3);
    }
    .power-bb-row:hover { background: var(--bg-light); }
    .power-bb-rank { color: var(--sunpetal); width: 20px; font-weight: bold; }
    .power-bb-img { width: 20px; height: 20px; image-rendering: pixelated; }
    .power-bb-name { flex: 1; color: var(--text-primary); font-weight: bold; }
    .power-bb-cat { font-size: 8px; color: var(--text-dim); width: 60px; }
    .power-bb-sfl { color: var(--green); width: 70px; text-align: right; }
    .power-bb-floor { color: var(--sunpetal); width: 55px; text-align: right; }
    .power-bb-roi { color: var(--lily); width: 55px; text-align: right; font-weight: bold; }
    .power-category { margin-bottom: 12px; }
    .power-cat-header {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 10px 14px;
      background: var(--bg-medium);
      border-bottom: 3px solid var(--border-dark);
      cursor: pointer;
      font-size: 11px;
    }
    .power-cat-header:hover { background: var(--bg-light); }
    .power-cat-count { font-size: 9px; color: var(--text-dim); }
    .power-cat-sfl { margin-left: auto; font-weight: bold; }
    .power-toggle-arrow { font-size: 9px; color: var(--text-dim); margin-left: 4px; }
    .power-cat-body { }
    .power-product-select {
      font-family: 'Press Start 2P', cursive;
      font-size: 7px;
      padding: 3px 6px;
      background: var(--bg-dark);
      color: var(--text-primary);
      border: 2px solid var(--border-brown);
      cursor: pointer;
    }
    .power-subsection-label {
      font-size: 9px;
      color: var(--text-secondary);
      padding: 6px 12px 2px;
      font-weight: bold;
    }
    .power-boost-row {
      display: grid;
      grid-template-columns: 28px 1fr auto;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      border-bottom: 1px solid rgba(0,0,0,0.3);
      font-size: 10px;
      cursor: pointer;
      transition: background 0.1s;
    }
    .power-boost-row:hover { background: var(--bg-light); }
    .power-boost-row.has-it { border-left: 3px solid var(--green); }
    .power-boost-row.missing { border-left: 3px solid var(--text-dim); opacity: 0.85; }
    .power-boost-img {
      width: 24px; height: 24px;
      image-rendering: pixelated;
      filter: drop-shadow(1px 1px 0 #000);
    }
    .power-boost-icon { width: 24px; text-align: center; font-size: 14px; }
    .power-boost-info { min-width: 0; }
    .power-boost-name { color: var(--text-primary); font-weight: bold; font-size: 10px; }
    .power-boost-type { font-size: 8px; color: var(--text-dim); margin-left: 3px; font-weight: normal; }
    .power-boost-text { font-size: 8px; color: var(--green); margin-top: 1px; white-space: pre-line; overflow: hidden; text-overflow: ellipsis; }
    .power-boost-value { text-align: right; white-space: nowrap; }
    .power-boost-sfl { font-size: 10px; color: var(--green); font-weight: bold; }
    .power-boost-roi { font-size: 8px; color: var(--lily); }
    .power-boost-floor { font-size: 8px; color: var(--sunpetal); }
    .power-detail {
      padding: 10px 14px;
      background: var(--bg-dark);
      border: 2px solid var(--border-dark);
      border-top: none;
      margin-bottom: 2px;
    }
    .power-formula { font-size: 9px; line-height: 1.6; color: var(--text-secondary); }
    .power-formula strong { color: var(--text-primary); }

    /* ‚îÄ‚îÄ Grow Planner ‚îÄ‚îÄ */
    .planner-section {
      margin-bottom: 16px;
      border: 4px solid var(--border-brown);
      background: var(--bg-dark);
      box-shadow: 0 0 0 3px #000;
    }
    .planner-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      padding: 10px 14px;
      background: var(--bg-medium);
      border-bottom: 3px solid var(--border-dark);
      cursor: pointer;
    }
    .planner-header:hover { background: var(--bg-light); }
    .planner-body { padding: 10px 14px; }
    .planner-batch { margin-bottom: 12px; }
    .planner-batch:last-child { margin-bottom: 0; }
    .planner-batch-label {
      font-size: 10px;
      color: var(--text-secondary);
      margin-bottom: 6px;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .planner-row {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 4px 0;
      font-size: 11px;
      cursor: pointer;
    }
    .planner-row:hover { background: rgba(255,255,255,0.03); }
    .planner-row img {
      width: 22px; height: 22px;
      image-rendering: pixelated;
      filter: drop-shadow(1px 1px 0 #000);
    }
    .planner-row-info { flex: 1; }
    .planner-row-name { color: var(--text-primary); }
    .planner-row-detail { font-size: 9px; color: var(--text-dim); }
    .planner-row-time { font-size: 10px; text-align: right; white-space: nowrap; color: var(--text-secondary); }
    .planner-row-time.sleep { color: var(--yellow); }
    .planner-idle { font-size: 9px; color: var(--text-dim); padding: 6px 0; text-align: center; }
    .planner-pb-box {
      background: rgba(176,124,216,0.08);
      border: 2px solid rgba(176,124,216,0.2);
      padding: 8px 10px;
      margin-top: 4px;
    }
    .planner-pb-saved { font-size: 10px; color: var(--lily); margin-top: 6px; text-align: right; }
    .planner-sleep-cfg {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 8px 14px;
      border-top: 2px solid rgba(92,58,30,0.2);
      font-size: 9px;
      color: var(--text-dim);
    }
    .planner-sleep-cfg input {
      width: 40px;
      padding: 2px 4px;
      font-family: 'Courier New', monospace;
      font-size: 10px;
      background: var(--bg-card);
      border: 2px solid var(--border-brown);
      color: var(--text-primary);
      text-align: center;
    }

    /* ‚îÄ‚îÄ Responsive ‚îÄ‚îÄ */
    @media (max-width: 640px) {
      .container { padding: 8px; }
      .header h1 { font-size: 13px; }
      .flower-row {
        grid-template-columns: 30px 1fr 80px;
        gap: 6px;
        padding: 6px 8px;
      }
      .flower-time { display: none; }
      .flower-row.mobile-show-time .flower-time { display: block; }
      .seed-header { flex-wrap: wrap; gap: 6px; }
      .summary-bar { gap: 8px; }
      .summary-stat { min-width: 80px; }
      .config-field { min-width: 100%; }
      .config-field.small { flex: 1; min-width: 80px; }
      .donate-addr { font-size: 10px; }
      .growing-grid { grid-template-columns: 1fr; }
      .hub-cards { grid-template-columns: 1fr; }
      .nav-link { font-size: 9px; padding: 12px 12px; }
      .nav-link.help-btn { padding: 12px 14px; font-size: 13px; }
      .config-collapsed { gap: 10px; font-size: 9px; flex-wrap: wrap; justify-content: center; }
      .bumpkin-boosts { grid-template-columns: 1fr; gap: 12px 0; }
      .bumpkin-buildings-grid { grid-template-columns: 1fr; }
      .bumpkin-level-big { font-size: 24px; }
      .bumpkin-days-big { font-size: 22px; }
      .treasury-total { font-size: 20px; }
      .treasury-categories { grid-template-columns: 1fr; }
      .treasury-pie-wrap { flex-direction: column; }
      .treasury-item-row { grid-template-columns: 24px 1fr 60px 70px; }
      .treasury-item-unit { display: none; }
      .planner-row { font-size: 10px; gap: 6px; }
      .planner-row img { width: 18px; height: 18px; }
      .planner-row-time { font-size: 9px; }
      .sales-listing { grid-template-columns: 28px 1fr auto; gap: 6px; padding: 6px 8px; }
      .sales-listing-img { width: 22px; height: 22px; }
      .sales-summary-grid { grid-template-columns: repeat(2, 1fr); }
      .power-summary { grid-template-columns: repeat(2, 1fr); }
      .power-boost-row { grid-template-columns: 22px 1fr auto; gap: 5px; padding: 5px 8px; }
      .power-boost-img { width: 20px; height: 20px; }
      .power-boost-name { font-size: 9px; }
      .power-boost-text { font-size: 7px; }
      .power-bb-row { font-size: 9px; gap: 4px; }
      .power-bb-cat { display: none; }
      .power-bb-roi { width: 45px; }
      .power-cat-header { font-size: 9px; flex-wrap: wrap; }
      .power-product-select { font-size: 6px; }
    }
  </style>
  <script defer src="/_vercel/insights/script.js"></script>
</head>
<body>
  <div class="container">
    <div id="nav-bar"></div>
    <div id="config-bar"></div>
    <div id="app">
      <div class="loading-screen pixel-font">
        <div class="loading-flower">üåª</div>
        <div class="loading-text">Loading...</div>
      </div>
    </div>
    <div id="donate-section"></div>
  </div>
  <div id="help-modal" class="modal-overlay" style="display:none"></div>

  <script>
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  CONSTANTS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const DEFAULTS = { farm: "", limit: "5" };
    const DONATE_ADDR = "0x5688ee5f0488e1dc96d9aad5715e958914987cfc";
    const IMG_BASE = "https://sfl.world/img/flowers/";
    const PAGES = ["hub", "flowers", "dolls", "crustaceans", "bumpkin", "treasury", "sales", "power"];

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  SEED DATA
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const SEED_DATA = {
      "Sunpetal Seed":   { baseSeconds: 86400,  color: "#FFD700", label: "Sunpetal", season: null },
      "Bloom Seed":      { baseSeconds: 172800, color: "#FF69B4", label: "Bloom", season: null },
      "Edelweiss Seed":  { baseSeconds: 259200, color: "#87CEEB", label: "Edelweiss", season: "Winter" },
      "Gladiolus Seed":  { baseSeconds: 259200, color: "#FF6347", label: "Gladiolus", season: "Summer" },
      "Lavender Seed":   { baseSeconds: 259200, color: "#C8A2C8", label: "Lavender", season: "Spring" },
      "Clover Seed":     { baseSeconds: 259200, color: "#2ECC71", label: "Clover", season: "Autumn" },
      "Lily Seed":       { baseSeconds: 432000, color: "#B07CD8", label: "Lily", season: null },
    };

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  FLOWER BOOSTS (auto-detected from API)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const FLOWER_BOOSTS = [
      { name: "Flower Crown",      type: "wearable",        multiplier: 0.5  },
      { name: "Moth Shrine",       type: "collectible_temp", multiplier: 0.75, durationMs: 7 * 24 * 3600 * 1000 },
      { name: "Flower Fox",        type: "collectible",     multiplier: 0.9  },
      { name: "Blossom Hourglass", type: "collectible_temp", multiplier: 0.75, durationMs: 4 * 3600 * 1000 },
      { name: "Blooming Boost",    type: "skill",           multiplier: 0.9  },
      { name: "Flower Power",      type: "skill",           multiplier: 0.8  },
      { name: "Flowery Abode",     type: "skill",           multiplier: 1.5  },
    ];

    function findCollectible(farm, name) {
      // Collectibles can be on main island or home island
      const main = farm.collectibles?.[name] || [];
      const home = farm.home?.collectibles?.[name] || [];
      return [...main, ...home];
    }

    function detectFlowerBoosts(farm) {
      const active = [];
      for (const boost of FLOWER_BOOSTS) {
        let isActive = false;
        switch (boost.type) {
          case "wearable": {
            const equipped = farm.bumpkin?.equipped || {};
            isActive = Object.values(equipped).flat().includes(boost.name);
            break;
          }
          case "collectible": {
            isActive = findCollectible(farm, boost.name).length > 0;
            break;
          }
          case "collectible_temp": {
            const placements = findCollectible(farm, boost.name);
            if (placements.length > 0) {
              const latest = placements[placements.length - 1];
              const placedAt = toMs(latest.createdAt || latest.readyAt || 0);
              isActive = (Date.now() - placedAt) < boost.durationMs;
            }
            break;
          }
          case "skill": {
            const skills = farm.bumpkin?.skills || {};
            isActive = skills[boost.name] !== undefined;
            break;
          }
        }
        if (isActive) active.push(boost);
      }
      console.log("[Boosts]", active.map(b => `${b.name} √ó${b.multiplier}`), "multiplier:", computeFlowerMultiplier(active));
      return active;
    }

    function computeFlowerMultiplier(activeBoosts) {
      return activeBoosts.reduce((m, b) => m * b.multiplier, 1);
    }

    function applyFlowerBoosts(multiplier) {
      for (const sd of Object.values(SEED_DATA)) {
        sd.seconds = sd.baseSeconds * multiplier;
        sd.hours = sd.seconds / 3600;
      }
    }

    // Initialize with no boosts (multiplier = 1)
    applyFlowerBoosts(1);

    const SEED_ORDER = [
      "Sunpetal Seed", "Bloom Seed",
      "Edelweiss Seed", "Gladiolus Seed", "Lavender Seed", "Clover Seed",
      "Lily Seed",
    ];

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  FLOWER RECIPES
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const FLOWER_RECIPES = {
      "Red Pansy":       { seed: "Sunpetal Seed", input: "Radish" },
      "Yellow Pansy":    { seed: "Sunpetal Seed", input: "Sunflower" },
      "Purple Cosmos":   { seed: "Sunpetal Seed", input: "Beetroot" },
      "Blue Cosmos":     { seed: "Sunpetal Seed", input: "Cauliflower" },
      "Blue Pansy":      { seed: "Sunpetal Seed", input: "Purple Cosmos" },
      "Yellow Cosmos":   { seed: "Sunpetal Seed", input: "Yellow Pansy" },
      "Purple Pansy":    { seed: "Sunpetal Seed", input: "Blue Pansy" },
      "White Pansy":     { seed: "Sunpetal Seed", input: "Yellow Cosmos" },
      "White Cosmos":    { seed: "Sunpetal Seed", input: "Prism Petal" },
      "Prism Petal":     { seed: "Sunpetal Seed", input: "Blue Lotus" },
      "Red Cosmos":      { seed: "Sunpetal Seed", input: "Yellow Daffodil" },

      "Red Balloon Flower":   { seed: "Bloom Seed", input: "Sunflower" },
      "Blue Balloon Flower":  { seed: "Bloom Seed", input: "Cauliflower" },
      "Purple Daffodil":      { seed: "Bloom Seed", input: "Radish" },
      "Red Daffodil":         { seed: "Bloom Seed", input: "Yellow Pansy" },
      "White Daffodil":       { seed: "Bloom Seed", input: "Yellow Cosmos" },
      "Celestial Frostbloom": { seed: "Bloom Seed", input: "White Pansy" },
      "White Balloon Flower": { seed: "Bloom Seed", input: "White Cosmos" },
      "Yellow Daffodil":      { seed: "Bloom Seed", input: "Red Cosmos" },
      "Blue Daffodil":        { seed: "Bloom Seed", input: "Purple Balloon Flower" },
      "Yellow Balloon Flower":{ seed: "Bloom Seed", input: "Yellow Lotus" },
      "Purple Balloon Flower":{ seed: "Bloom Seed", input: "Blue Carnation" },

      "Purple Carnation": { seed: "Lily Seed", input: "Eggplant" },
      "Red Lotus":        { seed: "Lily Seed", input: "Beetroot" },
      "White Lotus":      { seed: "Lily Seed", input: "Cauliflower" },
      "Yellow Carnation": { seed: "Lily Seed", input: "Sunflower" },
      "White Carnation":  { seed: "Lily Seed", input: "Yellow Pansy" },
      "Yellow Lotus":     { seed: "Lily Seed", input: "Red Pansy" },
      "Blue Lotus":       { seed: "Lily Seed", input: "Blue Pansy" },
      "Blue Carnation":   { seed: "Lily Seed", input: "Purple Daffodil" },
      "Red Carnation":    { seed: "Lily Seed", input: "Purple Pansy" },
      "Purple Lotus":     { seed: "Lily Seed", input: "Blue Carnation" },
      "Primula Enigma":   { seed: "Lily Seed", input: "Purple Balloon Flower" },

      "Red Edelweiss":    { seed: "Edelweiss Seed", input: "Artichoke" },
      "Yellow Edelweiss": { seed: "Edelweiss Seed", input: "Onion" },
      "Purple Edelweiss": { seed: "Edelweiss Seed", input: "Rhubarb" },
      "White Edelweiss":  { seed: "Edelweiss Seed", input: "Blue Edelweiss" },
      "Blue Edelweiss":   { seed: "Edelweiss Seed", input: "Purple Edelweiss" },

      "Red Gladiolus":    { seed: "Gladiolus Seed", input: "Yellow Edelweiss" },
      "Yellow Gladiolus": { seed: "Gladiolus Seed", input: "Pepper" },
      "Purple Gladiolus": { seed: "Gladiolus Seed", input: "Artichoke" },
      "White Gladiolus":  { seed: "Gladiolus Seed", input: "White Edelweiss" },
      "Blue Gladiolus":   { seed: "Gladiolus Seed", input: "Rhubarb" },

      "Red Lavender":     { seed: "Lavender Seed", input: "Pepper" },
      "Yellow Lavender":  { seed: "Lavender Seed", input: "Red Gladiolus" },
      "Purple Lavender":  { seed: "Lavender Seed", input: "Blue Lavender" },
      "White Lavender":   { seed: "Lavender Seed", input: "Rhubarb" },
      "Blue Lavender":    { seed: "Lavender Seed", input: "White Edelweiss" },

      "Red Clover":       { seed: "Clover Seed", input: "Red Edelweiss" },
      "Yellow Clover":    { seed: "Clover Seed", input: "Pepper" },
      "Purple Clover":    { seed: "Clover Seed", input: "Red Lavender" },
      "White Clover":     { seed: "Clover Seed", input: "Blue Edelweiss" },
      "Blue Clover":      { seed: "Clover Seed", input: "Rhubarb" },
    };

    const CROPS_AND_FRUITS = new Set([
      "Sunflower","Potato","Pumpkin","Carrot","Cabbage","Soybean",
      "Beetroot","Cauliflower","Parsnip","Eggplant","Corn","Radish",
      "Wheat","Kale","Turnip","Onion","Pepper","Rhubarb","Artichoke",
      "Barley","Zucchini","Yam","Broccoli",
      "Tomato","Lemon","Blueberry","Orange","Apple","Banana",
      "Grape","Rice","Olive",
      "Celestine","Lunara","Duskberry",
    ]);

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  DOLL RECIPES
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const DOLL_RECIPES = {
      "Doll":           [{ item: "Leather", qty: 4 }, { item: "Wool", qty: 5 }],
      "Angler Doll":    [{ item: "Kelp Fibre", qty: 8 }, { item: "Doll", qty: 1 }],
      "Bloom Doll":     [{ item: "Doll", qty: 1 }, { item: "Prism Petal", qty: 3 }, { item: "Celestial Frostbloom", qty: 2 }, { item: "Primula Enigma", qty: 3 }],
      "Buzz Doll":      [{ item: "Honey", qty: 8 }, { item: "Doll", qty: 1 }],
      "Cluck Doll":     [{ item: "Feather", qty: 8 }, { item: "Doll", qty: 1 }],
      "Crude Doll":     [{ item: "Oil", qty: 8 }, { item: "Doll", qty: 1 }],
      "Ember Doll":     [{ item: "Crimsteel", qty: 8 }, { item: "Doll", qty: 1 }],
      "Gilded Doll":    [{ item: "Gold", qty: 8 }, { item: "Doll", qty: 1 }],
      "Harvest Doll":   [{ item: "Turnip", qty: 8 }, { item: "Doll", qty: 1 }],
      "Juicy Doll":     [{ item: "Tomato", qty: 8 }, { item: "Doll", qty: 1 }],
      "Lumber Doll":    [{ item: "Timber", qty: 8 }, { item: "Doll", qty: 1 }],
      "Lunar Doll":     [{ item: "Lunara", qty: 3 }, { item: "Duskberry", qty: 2 }, { item: "Doll", qty: 1 }, { item: "Celestine", qty: 3 }],
      "Moo Doll":       [{ item: "Leather", qty: 8 }, { item: "Doll", qty: 1 }],
      "Sizzle Doll":    [{ item: "Synthetic Fabric", qty: 8 }, { item: "Doll", qty: 1 }],
      "Wooly Doll":     [{ item: "Merino Wool", qty: 8 }, { item: "Doll", qty: 1 }],
      "Shadow Doll":    [{ item: "Obsidian", qty: 8 }, { item: "Doll", qty: 1 }],
      "Frosty Doll":    [{ item: "Celestial Frostbloom", qty: 8 }, { item: "Harvest Doll", qty: 1 }],
      "Grubby Doll":    [{ item: "Shadow Doll", qty: 1 }, { item: "Ember Doll", qty: 1 }, { item: "Gilded Doll", qty: 1 }],
      "Dune Doll":      [{ item: "Coral", qty: 8 }, { item: "Lumber Doll", qty: 1 }],
      "Solar Doll":     [],
      "Nefari Doll":    [],
      "Cosmo Doll":     [],
      "Bigfin Doll":    [],
    };

    const TRACKED_DOLLS_DEFAULT = {
      "Doll": true, "Angler Doll": true, "Bloom Doll": true, "Buzz Doll": true,
      "Cluck Doll": true, "Crude Doll": true, "Ember Doll": true, "Gilded Doll": true,
      "Harvest Doll": true, "Juicy Doll": true, "Lumber Doll": true, "Lunar Doll": true,
      "Moo Doll": true, "Sizzle Doll": true, "Wooly Doll": true,
      "Solar Doll": false, "Shadow Doll": false, "Nefari Doll": false, "Grubby Doll": false,
      "Frosty Doll": false, "Dune Doll": false, "Cosmo Doll": false, "Bigfin Doll": false,
    };

    function getTrackedDolls() {
      try {
        const saved = localStorage.getItem("sfl_tracked_dolls");
        if (saved) {
          const parsed = JSON.parse(saved);
          // Merge with defaults (in case new dolls were added)
          const result = { ...TRACKED_DOLLS_DEFAULT };
          for (const k of Object.keys(result)) {
            if (parsed[k] !== undefined) result[k] = parsed[k];
          }
          return result;
        }
      } catch (e) {}
      return { ...TRACKED_DOLLS_DEFAULT };
    }

    function saveTrackedDolls(tracked) {
      localStorage.setItem("sfl_tracked_dolls", JSON.stringify(tracked));
    }

    function toggleDollTracked(name) {
      const tracked = getTrackedDolls();
      tracked[name] = !tracked[name];
      saveTrackedDolls(tracked);
      // Re-render dolls page with cached data
      if (cachedFarmData) renderDolls(cachedFarmData);
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  CRUSTACEAN RECIPES
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const CRUSTACEAN_RECIPES = {
      "Blue Crab":    { pot: "Crab Pot", chum: "Heart Leaf", qty: 3, alt: "Ribbon x3", time: "4h" },
      "Lobster":      { pot: "Crab Pot", chum: "Wild Grass", qty: 3, alt: "Frost Pebble x3", time: "4h" },
      "Hermit Crab":  { pot: "Crab Pot", chum: "Grape", qty: 5, alt: "Rice x5", time: "4h" },
      "Shrimp":       { pot: "Crab Pot", chum: "Crimstone", qty: 2, alt: null, time: "4h" },
      "Mussel":       { pot: "Crab Pot", chum: "Moonfur", qty: 1, alt: null, time: "4h" },
      "Oyster":       { pot: "Crab Pot", chum: "Fish Stick", qty: 2, alt: null, time: "4h" },
      "Anemone":      { pot: "Crab Pot", chum: "Fish Oil", qty: 2, alt: "Crab Stick x2", time: "4h" },
      "Isopod":       { pot: "Crab Pot", chum: null, qty: 0, alt: null, time: "4h" },
      "Sea Slug":     { pot: "Mariner Pot", chum: "Crimstone", qty: 2, alt: null, time: "8h" },
      "Sea Snail":    { pot: "Mariner Pot", chum: "Chewed Bone", qty: 3, alt: "Ruffroot x3", time: "8h" },
      "Garden Eel":   { pot: "Mariner Pot", chum: "Dewberry", qty: 3, alt: "Duskberry x3", time: "8h" },
      "Sea Grapes":   { pot: "Mariner Pot", chum: "Lunara", qty: 3, alt: null, time: "8h" },
      "Octopus":      { pot: "Mariner Pot", chum: "Moonfur", qty: 1, alt: null, time: "8h" },
      "Sea Urchin":   { pot: "Mariner Pot", chum: "Fish Stick", qty: 2, alt: null, time: "8h" },
      "Horseshoe Crab":{ pot: "Mariner Pot", chum: "Crab Stick", qty: 2, alt: null, time: "8h" },
      "Barnacle":     { pot: "Mariner Pot", chum: null, qty: 0, alt: null, time: "8h" },
    };

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  BUMPKIN XP TABLE (total XP for levels 1-200)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const BUMPKIN_XP_TABLE = [
      // Lvl 1-10
      0, 2, 22, 205, 555, 1155, 2155, 3405, 5405, 7905,
      // Lvl 11-20
      10905, 14405, 18405, 22905, 27905, 33655, 40155, 47405, 55405, 64155,
      // Lvl 21-30
      73905, 84655, 96405, 109155, 122905, 137405, 152905, 169405, 186905, 205405,
      // Lvl 31-40
      225405, 246905, 269905, 294405, 320405, 348405, 378405, 410405, 444405, 480405,
      // Lvl 41-50
      518905, 559905, 603405, 649405, 697905, 749405, 803905, 861405, 921905, 985405,
      // Lvl 51-60
      1053905, 1127405, 1205905, 1289405, 1377905, 1476405, 1584905, 1703405, 1831905, 1970405,
      // Lvl 61-70
      2128905, 2287405, 2485905, 2704405, 2942905, 3221405, 3539905, 3898405, 4296905, 4735405,
      // Lvl 71-80
      5233905, 5743905, 6263905, 6793905, 7333905, 7883905, 8443905, 9013905, 9593905, 10183905,
      // Lvl 81-90
      10783905, 11393905, 12013905, 12643905, 13283905, 13933905, 14593905, 15263905, 15943905, 16633905,
      // Lvl 91-100
      17333905, 18043905, 18763905, 19493905, 20233905, 20983905, 21743905, 22513905, 23293905, 24083905,
      // Lvl 101-110
      24893905, 25723905, 26573905, 27443905, 28333905, 29243905, 30173905, 31123905, 32093905, 33083905,
      // Lvl 111-120
      34093905, 35123905, 36173905, 37243905, 38333905, 39443905, 40573905, 41723905, 42893905, 44083905,
      // Lvl 121-130
      45293905, 46523905, 47773905, 49043905, 50333905, 51653905, 53003905, 54383905, 55793905, 57233905,
      // Lvl 131-140
      58708905, 60218905, 61763905, 63343905, 64958905, 66613905, 68308905, 70043905, 71818905, 73633905,
      // Lvl 141-150
      75493905, 77398905, 79348905, 81343905, 83383905, 85473905, 87613905, 89803905, 92043905, 94333905,
      // Lvl 151-160
      95662605, 97031166, 98440783, 99892688, 101388150, 102928475, 104515009, 106149139, 107832292, 109565939,
      // Lvl 161-170
      111351595, 113190820, 115085221, 117036454, 119046223, 121116285, 123248448, 125444575, 127706585, 130036455,
      // Lvl 171-180
      132436221, 134907979, 137453889, 140076176, 142777131, 145559114, 148424556, 151375961, 154415908, 157547053,
      // Lvl 181-190
      160772132, 164093963, 167515448, 171039577, 174669429, 178408176, 182259085, 186225521, 190310950, 194518941,
      // Lvl 191-200
      198853171, 203317427, 207915610, 212651738, 217529949, 222554506, 227729799, 233060350, 238550817, 244206000,
    ];

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  COOKING RECIPES (84 foods, 5 buildings)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const COOKING_RECIPES_DATA = {
      // Fire Pit (18)
      "Mashed Potato":        { building: "Fire Pit",       xp: 3,     cookSec: 30,     usesHoney: false },
      "Rhubarb Tart":         { building: "Fire Pit",       xp: 5,     cookSec: 60,     usesHoney: false },
      "Pumpkin Soup":         { building: "Fire Pit",       xp: 24,    cookSec: 180,    usesHoney: false },
      "Reindeer Carrot":      { building: "Fire Pit",       xp: 36,    cookSec: 300,    usesHoney: false },
      "Mushroom Soup":        { building: "Fire Pit",       xp: 56,    cookSec: 600,    usesHoney: false },
      "Boiled Eggs":          { building: "Fire Pit",       xp: 90,    cookSec: 3600,   usesHoney: false },
      "Bumpkin Broth":        { building: "Fire Pit",       xp: 96,    cookSec: 1200,   usesHoney: false },
      "Popcorn":              { building: "Fire Pit",       xp: 200,   cookSec: 720,    usesHoney: false },
      "Cabbers n Mash":       { building: "Fire Pit",       xp: 250,   cookSec: 2400,   usesHoney: false },
      "Rapid Roast":          { building: "Fire Pit",       xp: 300,   cookSec: 10,     usesHoney: false },
      "Kale Stew":            { building: "Fire Pit",       xp: 400,   cookSec: 7200,   usesHoney: false },
      "Fried Tofu":           { building: "Fire Pit",       xp: 400,   cookSec: 5400,   usesHoney: false },
      "Gumbo":                { building: "Fire Pit",       xp: 600,   cookSec: 14400,  usesHoney: false },
      "Kale Omelette":        { building: "Fire Pit",       xp: 1250,  cookSec: 12600,  usesHoney: false },
      "Rice Bun":             { building: "Fire Pit",       xp: 2600,  cookSec: 18000,  usesHoney: false },
      "Antipasto":            { building: "Fire Pit",       xp: 3000,  cookSec: 10800,  usesHoney: false },
      "Pizza Margherita":     { building: "Fire Pit",       xp: 25000, cookSec: 72000,  usesHoney: false },
      // Kitchen (27)
      "Sunflower Crunch":     { building: "Kitchen",        xp: 50,    cookSec: 600,    usesHoney: false },
      "Club Sandwich":        { building: "Kitchen",        xp: 170,   cookSec: 10800,  usesHoney: false },
      "Roast Veggies":        { building: "Kitchen",        xp: 170,   cookSec: 7200,   usesHoney: false },
      "Fruit Salad":          { building: "Kitchen",        xp: 225,   cookSec: 1800,   usesHoney: false },
      "Mushroom Jacket Potatoes": { building: "Kitchen",    xp: 240,   cookSec: 600,    usesHoney: false },
      "Cauliflower Burger":   { building: "Kitchen",        xp: 255,   cookSec: 10800,  usesHoney: false },
      "Bumpkin Salad":        { building: "Kitchen",        xp: 290,   cookSec: 12600,  usesHoney: false },
      "Goblin's Treat":       { building: "Kitchen",        xp: 500,   cookSec: 21600,  usesHoney: false },
      "Pancakes":             { building: "Kitchen",        xp: 1000,  cookSec: 3600,   usesHoney: true  },
      "Bumpkin ganoush":      { building: "Kitchen",        xp: 1000,  cookSec: 18000,  usesHoney: false },
      "Chowder":              { building: "Kitchen",        xp: 1000,  cookSec: 28800,  usesHoney: false },
      "Tofu Scramble":        { building: "Kitchen",        xp: 1000,  cookSec: 10800,  usesHoney: false },
      "Fish Burger":          { building: "Kitchen",        xp: 1300,  cookSec: 7200,   usesHoney: false },
      "Fish Omelette":        { building: "Kitchen",        xp: 1500,  cookSec: 18000,  usesHoney: false },
      "Fried Calamari":       { building: "Kitchen",        xp: 1500,  cookSec: 18000,  usesHoney: false },
      "Beetroot Blaze":       { building: "Kitchen",        xp: 2000,  cookSec: 30,     usesHoney: false },
      "Sushi Roll":           { building: "Kitchen",        xp: 2000,  cookSec: 3600,   usesHoney: false },
      "Ocean's Olive":        { building: "Kitchen",        xp: 2000,  cookSec: 7200,   usesHoney: false },
      "Fish n Chips":         { building: "Kitchen",        xp: 2000,  cookSec: 14400,  usesHoney: false },
      "Seafood Basket":       { building: "Kitchen",        xp: 2200,  cookSec: 18000,  usesHoney: false },
      "Bumpkin Roast":        { building: "Kitchen",        xp: 2500,  cookSec: 43200,  usesHoney: false },
      "Goblin Brunch":        { building: "Kitchen",        xp: 2500,  cookSec: 43200,  usesHoney: false },
      "Steamed Red Rice":     { building: "Kitchen",        xp: 3000,  cookSec: 14400,  usesHoney: false },
      "Caprese Salad":        { building: "Kitchen",        xp: 6000,  cookSec: 10800,  usesHoney: false },
      "Spaghetti al Limone":  { building: "Kitchen",        xp: 15000, cookSec: 54000,  usesHoney: false },
      // Bakery (17)
      "Sunflower Cake":       { building: "Bakery",         xp: 525,   cookSec: 23400,  usesHoney: false },
      "Cornbread":            { building: "Bakery",         xp: 600,   cookSec: 43200,  usesHoney: false },
      "Pumpkin Cake":         { building: "Bakery",         xp: 625,   cookSec: 37800,  usesHoney: false },
      "Potato Cake":          { building: "Bakery",         xp: 650,   cookSec: 37800,  usesHoney: false },
      "Apple Pie":            { building: "Bakery",         xp: 720,   cookSec: 14400,  usesHoney: false },
      "Kale & Mushroom Pie":  { building: "Bakery",         xp: 720,   cookSec: 14400,  usesHoney: false },
      "Orange Cake":          { building: "Bakery",         xp: 730,   cookSec: 14400,  usesHoney: false },
      "Carrot Cake":          { building: "Bakery",         xp: 750,   cookSec: 46800,  usesHoney: false },
      "Cabbage Cake":         { building: "Bakery",         xp: 860,   cookSec: 54000,  usesHoney: false },
      "Wheat Cake":           { building: "Bakery",         xp: 1100,  cookSec: 86400,  usesHoney: false },
      "Cauliflower Cake":     { building: "Bakery",         xp: 1190,  cookSec: 79200,  usesHoney: false },
      "Radish Cake":          { building: "Bakery",         xp: 1200,  cookSec: 86400,  usesHoney: false },
      "Beetroot Cake":        { building: "Bakery",         xp: 1250,  cookSec: 79200,  usesHoney: false },
      "Parsnip Cake":         { building: "Bakery",         xp: 1300,  cookSec: 86400,  usesHoney: false },
      "Eggplant Cake":        { building: "Bakery",         xp: 1400,  cookSec: 86400,  usesHoney: false },
      "Honey Cake":           { building: "Bakery",         xp: 4000,  cookSec: 28800,  usesHoney: true  },
      "Lemon Cheesecake":     { building: "Bakery",         xp: 30000, cookSec: 108000, usesHoney: false },
      // Deli (9)
      "Cheese":               { building: "Deli",           xp: 1,     cookSec: 1200,   usesHoney: false },
      "Fermented Carrots":    { building: "Deli",           xp: 250,   cookSec: 86400,  usesHoney: false },
      "Blueberry Jam":        { building: "Deli",           xp: 500,   cookSec: 43200,  usesHoney: false },
      "Sauerkraut":           { building: "Deli",           xp: 500,   cookSec: 86400,  usesHoney: false },
      "Fancy Fries":          { building: "Deli",           xp: 1000,  cookSec: 86400,  usesHoney: false },
      "Fermented Fish":       { building: "Deli",           xp: 3000,  cookSec: 86400,  usesHoney: false },
      "Blue Cheese":          { building: "Deli",           xp: 6000,  cookSec: 10800,  usesHoney: false },
      "Shroom Syrup":         { building: "Deli",           xp: 10000, cookSec: 10,     usesHoney: true  },
      "Honey Cheddar":        { building: "Deli",           xp: 15000, cookSec: 43200,  usesHoney: true  },
      // Smoothie Shack (12)
      "Quick Juice":          { building: "Smoothie Shack", xp: 100,   cookSec: 1800,   usesHoney: false },
      "Carrot Juice":         { building: "Smoothie Shack", xp: 200,   cookSec: 3600,   usesHoney: false },
      "Purple Smoothie":      { building: "Smoothie Shack", xp: 310,   cookSec: 1800,   usesHoney: false },
      "Orange Juice":         { building: "Smoothie Shack", xp: 375,   cookSec: 2700,   usesHoney: false },
      "Apple Juice":          { building: "Smoothie Shack", xp: 500,   cookSec: 3600,   usesHoney: false },
      "Power Smoothie":       { building: "Smoothie Shack", xp: 775,   cookSec: 5400,   usesHoney: false },
      "Bumpkin Detox":        { building: "Smoothie Shack", xp: 975,   cookSec: 7200,   usesHoney: false },
      "Sour Shake":           { building: "Smoothie Shack", xp: 1000,  cookSec: 3600,   usesHoney: false },
      "Banana Blast":         { building: "Smoothie Shack", xp: 1200,  cookSec: 10800,  usesHoney: false },
      "The Lot":              { building: "Smoothie Shack", xp: 1500,  cookSec: 12600,  usesHoney: false },
      "Grape Juice":          { building: "Smoothie Shack", xp: 3300,  cookSec: 10800,  usesHoney: false },
      "Slow Juice":           { building: "Smoothie Shack", xp: 7500,  cookSec: 86400,  usesHoney: false },
    };

    const COOKING_BUILDING_NAMES = ["Fire Pit", "Kitchen", "Bakery", "Deli", "Smoothie Shack"];
    const COOKING_BUILDING_EMOJI = { "Fire Pit": "üî•", "Kitchen": "üç≥", "Bakery": "üßÅ", "Deli": "ü•©", "Smoothie Shack": "ü•§" };

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  POWER ANALYZER DATA
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    // Grow times in seconds (approximate ‚Äî base values before boosts)
    const CROP_GROW_DATA = {
      "Sunflower": 60, "Potato": 300, "Pumpkin": 1800, "Carrot": 3600,
      "Cabbage": 7200, "Soybean": 3600, "Beetroot": 14400, "Cauliflower": 28800,
      "Parsnip": 43200, "Eggplant": 28800, "Corn": 21600, "Radish": 43200,
      "Wheat": 14400, "Kale": 43200, "Turnip": 14400, "Onion": 28800,
      "Pepper": 7200, "Zucchini": 600, "Yam": 3600, "Broccoli": 3600,
      "Artichoke": 43200, "Barley": 43200,
    };

    const FRUIT_GROW_DATA = {
      "Apple": 43200, "Blueberry": 21600, "Orange": 43200, "Banana": 43200,
      "Lemon": 14400, "Tomato": 7200, "Grape": 86400, "Rice": 86400, "Olive": 86400,
    };

    const ANIMAL_CYCLE_DATA = {
      "Chicken": { cycleSec: 48 * 3600, product: "Egg", farmKey: "chickens" },
      "Cow":     { cycleSec: 48 * 3600, product: "Milk", farmKey: "cows" },
      "Sheep":   { cycleSec: 48 * 3600, product: "Wool", farmKey: "sheep" },
    };

    const RESOURCE_RESPAWN_DATA = {
      "Stone":     { respawnSec: 14400, yield: 2, farmKey: "stones" },
      "Iron":      { respawnSec: 28800, yield: 1, farmKey: "iron" },
      "Gold":      { respawnSec: 43200, yield: 1, farmKey: "gold" },
      "Crimstone": { respawnSec: 64800, yield: 1, farmKey: "crimstones" },
      "Wood":      { respawnSec: 7200,  yield: 3, farmKey: "trees" },
    };

    // Full skill tree data from sfl.world/tools/skills
    const SKILL_TREE_DATA = {
      // ‚îÄ‚îÄ Crops ‚îÄ‚îÄ
      "Green Thumb":        { tree: "Crops", points: 1, tier: 1, buff: "-5% Crop Growth Time", debuff: null },
      "Young Farmer":       { tree: "Crops", points: 1, tier: 1, buff: "+0.1 Basic Crop yield", debuff: null },
      "Experienced Farmer": { tree: "Crops", points: 1, tier: 1, buff: "+0.1 Medium Crop yield", debuff: null },
      "Old Farmer":         { tree: "Crops", points: 1, tier: 1, buff: "+0.1 Advanced Crop yield", debuff: null },
      "Chonky Scarecrow":   { tree: "Crops", points: 1, tier: 1, buff: "+0.1 Basic Crop yield", debuff: null },
      "Betty's Friend":     { tree: "Crops", points: 1, tier: 1, buff: "+30% Betty Coin delivery revenue", debuff: null },
      "Strong Roots":       { tree: "Crops", points: 2, tier: 2, buff: "-10% Advanced Crop Growth Time", debuff: null },
      "Coin Swindler":      { tree: "Crops", points: 2, tier: 2, buff: "+10% coins selling crops at Market", debuff: null },
      "Golden Sunflower":   { tree: "Crops", points: 2, tier: 2, buff: "1/700 chance +0.35 Gold harvesting Sunflower", debuff: null },
      "Horror Mike":        { tree: "Crops", points: 2, tier: 2, buff: "+0.1 Medium Crop yield", debuff: null },
      "Laurie's Gains":     { tree: "Crops", points: 2, tier: 2, buff: "+0.1 Advanced Crop yield", debuff: null },
      "Instant Growth":     { tree: "Crops", points: 3, tier: 3, buff: "Instantly harvest all growing crops", debuff: null, power: true },
      "Acre Farm":          { tree: "Crops", points: 3, tier: 3, buff: "+1 Advanced Crop yield", debuff: "-0.5 Basic and Medium Crop yield" },
      "Hectare Farm":       { tree: "Crops", points: 3, tier: 3, buff: "+1 Basic and Medium Crop yield", debuff: "-0.5 Advanced Crop yield" },
      // ‚îÄ‚îÄ Fruit Patch ‚îÄ‚îÄ
      "Fruitful Fumble":    { tree: "Fruit Patch", points: 1, tier: 1, buff: "+0.1 Fruit yield", debuff: null },
      "Fruity Heaven":      { tree: "Fruit Patch", points: 1, tier: 1, buff: "-10% Fruit seeds cost", debuff: null },
      "Fruity Profit":      { tree: "Fruit Patch", points: 1, tier: 1, buff: "+50% coins from Tango deliveries", debuff: null },
      "Loyal Macaw":        { tree: "Fruit Patch", points: 1, tier: 1, buff: "Double Macaw effect", debuff: null },
      "No Axe No Worries":  { tree: "Fruit Patch", points: 1, tier: 1, buff: "Chop fruit without axes", debuff: "-1 Wood from fruit" },
      "Catchup":            { tree: "Fruit Patch", points: 2, tier: 2, buff: "-10% Fruit Growth Time", debuff: null },
      "Fruity Woody":       { tree: "Fruit Patch", points: 2, tier: 2, buff: "+1 Wood from fruit branches", debuff: null },
      "Pear Turbocharge":   { tree: "Fruit Patch", points: 2, tier: 2, buff: "Double Immortal Pear effect", debuff: null },
      "Crime Fruit":        { tree: "Fruit Patch", points: 2, tier: 2, buff: "+10 Tomato and Lemon seed stock", debuff: null },
      "Generous Orchard":   { tree: "Fruit Patch", points: 3, tier: 3, buff: "20% chance +1 Fruit yield", debuff: null },
      "Long Pickings":      { tree: "Fruit Patch", points: 3, tier: 3, buff: "-50% Apple and Banana Growth Time", debuff: "+100% Growth Time other fruits" },
      "Short Pickings":     { tree: "Fruit Patch", points: 3, tier: 3, buff: "-50% Blueberry and Orange Growth Time", debuff: "+100% Growth Time other fruits" },
      "Zesty Vibes":        { tree: "Fruit Patch", points: 3, tier: 3, buff: "+1 Tomato and Lemon yield", debuff: "-0.25 yield other fruits" },
      // ‚îÄ‚îÄ Trees ‚îÄ‚îÄ
      "Lumberjack's Extra": { tree: "Trees", points: 1, tier: 1, buff: "+0.1 Wood yield", debuff: null },
      "Tree Charge":        { tree: "Trees", points: 1, tier: 1, buff: "-10% Tree Recovery Time", debuff: null },
      "More Axes":          { tree: "Trees", points: 1, tier: 1, buff: "+50 axe stock", debuff: null },
      "Insta-Chop":         { tree: "Trees", points: 1, tier: 1, buff: "1 Tap Trees", debuff: null },
      "Tough Tree":         { tree: "Trees", points: 2, tier: 2, buff: "10% chance x3 Wood yield", debuff: null },
      "Feller's Discount":  { tree: "Trees", points: 2, tier: 2, buff: "-20% axe cost", debuff: null },
      "Money Tree":         { tree: "Trees", points: 2, tier: 2, buff: "1% chance +200 Coins chopping trees", debuff: null },
      "Tree Turnaround":    { tree: "Trees", points: 3, tier: 3, buff: "15% chance trees grow instantly", debuff: null },
      "Tree Blitz":         { tree: "Trees", points: 3, tier: 3, buff: "Instantly grow all trees", debuff: null, power: true },
      // ‚îÄ‚îÄ Mining ‚îÄ‚îÄ
      "Rock'N'Roll":        { tree: "Mining", points: 1, tier: 1, buff: "+0.1 Stone Yield", debuff: null },
      "Iron Bumpkin":       { tree: "Mining", points: 1, tier: 1, buff: "+0.1 Iron Yield", debuff: null },
      "Speed Miner":        { tree: "Mining", points: 1, tier: 1, buff: "-20% Stone Recovery Time", debuff: null },
      "Tap Prospector":     { tree: "Mining", points: 1, tier: 1, buff: "1 tap mineral nodes", debuff: null },
      "Forge-Ward Profits": { tree: "Mining", points: 1, tier: 1, buff: "+20% Blacksmith delivery revenue", debuff: null },
      "Iron Hustle":        { tree: "Mining", points: 2, tier: 2, buff: "-30% Iron Recovery Time", debuff: null },
      "Frugal Miner":       { tree: "Mining", points: 2, tier: 2, buff: "-20% pickaxe cost", debuff: null },
      "Rocky Favor":        { tree: "Mining", points: 2, tier: 2, buff: "+1 Stone yield", debuff: "-0.5 Iron yield" },
      "Fire Kissed":        { tree: "Mining", points: 2, tier: 2, buff: "+1 Crimstone on 5th consecutive mine", debuff: null },
      "Midas Sprint":       { tree: "Mining", points: 2, tier: 2, buff: "-10% Gold Recovery Time", debuff: null },
      "Ferrous Favor":      { tree: "Mining", points: 3, tier: 3, buff: "+1 Iron yield", debuff: "-0.5 Stone yield" },
      "Golden Touch":       { tree: "Mining", points: 3, tier: 3, buff: "+0.5 Gold Yield", debuff: null },
      "More Picks":         { tree: "Mining", points: 3, tier: 3, buff: "Increased pickaxe stock", debuff: null },
      "Fireside Alchemist": { tree: "Mining", points: 3, tier: 3, buff: "-15% Crimstone Recovery Time", debuff: null },
      "Midas Rush":         { tree: "Mining", points: 3, tier: 3, buff: "-20% Gold Recovery Time", debuff: null },
      // ‚îÄ‚îÄ Fishing ‚îÄ‚îÄ
      "Fisherman's 5 Fold": { tree: "Fishing", points: 1, tier: 1, buff: "+5 daily fishing limit", debuff: null },
      "Fishy Chance":       { tree: "Fishing", points: 1, tier: 1, buff: "10% chance +1 basic fish", debuff: null },
      "Fishy Roll":         { tree: "Fishing", points: 1, tier: 1, buff: "10% chance +1 advanced fish", debuff: null },
      "Reel Deal":          { tree: "Fishing", points: 1, tier: 1, buff: "-50% rod cost", debuff: null },
      "Fisherman's 10 Fold":{ tree: "Fishing", points: 2, tier: 2, buff: "+10 daily fishing limit", debuff: null },
      "Fishy Fortune":      { tree: "Fishing", points: 2, tier: 2, buff: "+100% coins from Corale deliveries", debuff: null },
      "Fishy Gamble":       { tree: "Fishing", points: 2, tier: 2, buff: "20% chance +1 expert fish", debuff: null },
      "Frenzied Fish":      { tree: "Fishing", points: 3, tier: 3, buff: "Fish frenzy: +1 fish, 50% chance +1", debuff: null },
      "More With Less":     { tree: "Fishing", points: 3, tier: 3, buff: "+15 daily fishing limit", debuff: "-1 worm from composters" },
      "Fishy Feast":        { tree: "Fishing", points: 3, tier: 3, buff: "+20% Fish XP", debuff: null },
      // ‚îÄ‚îÄ Animals ‚îÄ‚îÄ
      "Efficient Feeding":  { tree: "Animals", points: 1, tier: 1, buff: "-5% feed for all animals", debuff: null },
      "Restless Animals":   { tree: "Animals", points: 1, tier: 1, buff: "-10% Animal sleep time", debuff: null },
      "Fine Fibers":        { tree: "Animals", points: 1, tier: 1, buff: "+0.1 Feather, Leather, Merino Wool yield", debuff: null },
      "Bountiful Bounties": { tree: "Animals", points: 1, tier: 1, buff: "+50% Coins from Animal Bounties", debuff: null },
      "Double Bale":        { tree: "Animals", points: 1, tier: 1, buff: "Double Bale effect", debuff: null },
      "Bale Economy":       { tree: "Animals", points: 1, tier: 1, buff: "Bale affects milk and wool production", debuff: null },
      "Featherweight":      { tree: "Animals", points: 1, tier: 1, buff: "+0.25 Feather yield", debuff: "-0.35 Leather & Merino Wool yield" },
      "Abundant Harvest":   { tree: "Animals", points: 2, tier: 2, buff: "+0.2 Egg, Wool and Milk yield", debuff: null },
      "Heartwarming Instruments": { tree: "Animals", points: 2, tier: 2, buff: "+50% Animal XP from tools", debuff: null },
      "Kale Mix":           { tree: "Animals", points: 2, tier: 2, buff: "Mixed Grain requires 3 Kale instead", debuff: null },
      "Alternate Medicine": { tree: "Animals", points: 2, tier: 2, buff: "Barn Delight requires -1 Lemon and Honey", debuff: null },
      "Healthy Livestock":  { tree: "Animals", points: 2, tier: 2, buff: "-50% chance of sickness", debuff: null },
      "Merino Whisperer":   { tree: "Animals", points: 2, tier: 2, buff: "+0.25 Merino Wool yield", debuff: "-0.35 Leather & Feather yield" },
      "Clucky Grazing":     { tree: "Animals", points: 3, tier: 3, buff: "-25% feed for Chickens", debuff: "+50% feed other animals" },
      "Sheepwise Diet":     { tree: "Animals", points: 3, tier: 3, buff: "-25% feed for Sheep", debuff: "+50% feed other animals" },
      "Cow-Smart Nutrition":{ tree: "Animals", points: 3, tier: 3, buff: "-25% feed for Cows", debuff: "+50% feed other animals" },
      "Chonky Feed":        { tree: "Animals", points: 3, tier: 3, buff: "2x animal XP from feed", debuff: "+50% feed all animals" },
      "Leathercraft Mastery":{ tree: "Animals", points: 3, tier: 3, buff: "+0.25 Leather yield", debuff: "-0.35 Feather & Merino Wool yield" },
      "Barnyard Rouse":     { tree: "Animals", points: 3, tier: 3, buff: "Instantly wake all animals", debuff: null, power: true },
      // ‚îÄ‚îÄ Bees & Flowers ‚îÄ‚îÄ
      "Sweet Bonus":        { tree: "Bees & Flowers", points: 1, tier: 1, buff: "+0.1 Honey per hive", debuff: null },
      "Hyper Bees":         { tree: "Bees & Flowers", points: 1, tier: 1, buff: "+0.1 Honey production speed", debuff: null },
      "Blooming Boost":     { tree: "Bees & Flowers", points: 1, tier: 1, buff: "-10% Flower Growth Time", debuff: null },
      "Flower Sale":        { tree: "Bees & Flowers", points: 1, tier: 1, buff: "-20% Flower Seeds cost", debuff: null },
      "Buzzworthy Treats":  { tree: "Bees & Flowers", points: 2, tier: 2, buff: "+10% XP on food with Honey", debuff: null },
      "Blossom Bonding":    { tree: "Bees & Flowers", points: 2, tier: 2, buff: "+2 relationship points gifting flowers", debuff: null },
      "Pollen Power Up":    { tree: "Bees & Flowers", points: 2, tier: 2, buff: "+0.1 Crop yield after pollination", debuff: null },
      "Petalled Perk":      { tree: "Bees & Flowers", points: 2, tier: 2, buff: "10% chance +1 Flower", debuff: null },
      "Bee Collective":     { tree: "Bees & Flowers", points: 3, tier: 3, buff: "+20% Bee Swarm chance", debuff: null },
      "Flower Power":       { tree: "Bees & Flowers", points: 3, tier: 3, buff: "-20% Flower Growth Time", debuff: null },
      "Flowery Abode":      { tree: "Bees & Flowers", points: 3, tier: 3, buff: "+0.5 Honey production speed", debuff: "+50% Flower Growth Time" },
      "Petal Blessed":      { tree: "Bees & Flowers", points: 3, tier: 3, buff: "Instantly harvest all flowers", debuff: null, power: true },
      // ‚îÄ‚îÄ Cooking ‚îÄ‚îÄ
      "Fast Feasts":        { tree: "Cooking", points: 1, tier: 1, buff: "-10% Firepit and Kitchen cook time", debuff: null },
      "Nom Nom":            { tree: "Cooking", points: 1, tier: 1, buff: "+10% Food delivery revenue", debuff: null },
      "Munching Mastery":   { tree: "Cooking", points: 1, tier: 1, buff: "+5% XP from eating meals", debuff: null },
      "Swift Sizzle":       { tree: "Cooking", points: 1, tier: 1, buff: "-40% Fire Pit cook time with oil", debuff: null },
      "Frosted Cakes":      { tree: "Cooking", points: 2, tier: 2, buff: "-10% Cakes cook time", debuff: null },
      "Juicy Boost":        { tree: "Cooking", points: 2, tier: 2, buff: "+10% XP Smoothie Shack drinks", debuff: null },
      "Turbo Fry":          { tree: "Cooking", points: 2, tier: 2, buff: "-50% Kitchen cook time with oil", debuff: null },
      "Drive-Through Deli": { tree: "Cooking", points: 2, tier: 2, buff: "+15% XP Deli meals", debuff: null },
      "Instant Gratification":{ tree: "Cooking", points: 3, tier: 3, buff: "Instantly finish all cooking", debuff: null, power: true },
      "Double Nom":         { tree: "Cooking", points: 3, tier: 3, buff: "+1 food from cooking", debuff: "2x ingredients required" },
      "Fiery Jackpot":      { tree: "Cooking", points: 3, tier: 3, buff: "20% chance +1 food from Firepit", debuff: null },
      "Fry Frenzy":         { tree: "Cooking", points: 3, tier: 3, buff: "-60% Deli cook time with oil", debuff: null },
      // ‚îÄ‚îÄ Greenhouse ‚îÄ‚îÄ
      "Glass Room":         { tree: "Greenhouse", points: 1, tier: 1, buff: "+0.1 Greenhouse yield", debuff: null },
      "Seedy Business":     { tree: "Greenhouse", points: 1, tier: 1, buff: "-15% Greenhouse seeds cost", debuff: null },
      "Rice and Shine":     { tree: "Greenhouse", points: 1, tier: 1, buff: "-5% Greenhouse Growth Time", debuff: null },
      "Victoria's Secretary":{ tree: "Greenhouse", points: 1, tier: 1, buff: "+50% coins Victoria deliveries", debuff: null },
      "Olive Express":      { tree: "Greenhouse", points: 2, tier: 2, buff: "-10% Olive Growth Time", debuff: null },
      "Rice Rocket":        { tree: "Greenhouse", points: 2, tier: 2, buff: "-10% Rice Growth Time", debuff: null },
      "Vine Velocity":      { tree: "Greenhouse", points: 2, tier: 2, buff: "-10% Grape Growth Time", debuff: null },
      "Seeded Bounty":      { tree: "Greenhouse", points: 2, tier: 2, buff: "+0.5 Greenhouse yield", debuff: "+1 seed to plant" },
      "Greenhouse Guru":    { tree: "Greenhouse", points: 3, tier: 3, buff: "Instantly harvest greenhouse", debuff: null, power: true },
      "Greenhouse Gamble":  { tree: "Greenhouse", points: 3, tier: 3, buff: "25% chance +1 greenhouse produce", debuff: null },
      "Slick Saver":        { tree: "Greenhouse", points: 3, tier: 3, buff: "-1 Oil for greenhouse", debuff: null },
      "Greasy Plants":      { tree: "Greenhouse", points: 3, tier: 3, buff: "+1 Greenhouse yield", debuff: "+100% Oil consumption" },
      // ‚îÄ‚îÄ Machinery ‚îÄ‚îÄ
      "Crop Extension Module I":  { tree: "Machinery", points: 1, tier: 1, buff: "Rhubarb/Zucchini in crop machine", debuff: null },
      "Crop Processor Unit":      { tree: "Machinery", points: 1, tier: 1, buff: "-5% Crop Machine growth time", debuff: "+10% Oil in Crop Machine" },
      "Oil Gadget":               { tree: "Machinery", points: 1, tier: 1, buff: "-10% Oil in Crop Machine", debuff: null },
      "Oil Extraction":           { tree: "Machinery", points: 1, tier: 1, buff: "+1 Oil from reserves", debuff: null },
      "Leak-Proof Tank":          { tree: "Machinery", points: 1, tier: 1, buff: "3x oil tank in crop machine", debuff: null },
      "Crop Extension Module II": { tree: "Machinery", points: 2, tier: 2, buff: "Carrot/Cabbage in crop machine", debuff: null },
      "Crop Extension Module III":{ tree: "Machinery", points: 2, tier: 2, buff: "Yam/Broccoli in crop machine", debuff: null },
      "Rapid Rig":                { tree: "Machinery", points: 2, tier: 2, buff: "-20% Crop Machine growth time", debuff: "+40% Oil in Crop Machine" },
      "Oil Be Back":              { tree: "Machinery", points: 2, tier: 2, buff: "-20% Oil refill time", debuff: null },
      "Oil Rig":                  { tree: "Machinery", points: 2, tier: 2, buff: "Oil Drill uses Wool instead of Leather", debuff: null },
      "Field Expansion Module":   { tree: "Machinery", points: 3, tier: 3, buff: "+5 packs in machine queue", debuff: null },
      "Field Extension Module":   { tree: "Machinery", points: 3, tier: 3, buff: "+5 plots in machine", debuff: null },
      "Efficiency Extension Module":{ tree: "Machinery", points: 3, tier: 3, buff: "-30% Oil in Crop Machine", debuff: null },
      "Grease Lightning":         { tree: "Machinery", points: 3, tier: 3, buff: "Instantly refill oil wells", debuff: null, power: true },
      // ‚îÄ‚îÄ Compost ‚îÄ‚îÄ
      "Efficient Bin":      { tree: "Compost", points: 1, tier: 1, buff: "+5 Sprout Mix", debuff: null },
      "Turbo Charged":      { tree: "Compost", points: 1, tier: 1, buff: "+5 Fruitful Blend", debuff: null },
      "Wormy Treat":        { tree: "Compost", points: 1, tier: 1, buff: "+1 Worm", debuff: null },
      "Feathery Business":  { tree: "Compost", points: 1, tier: 1, buff: "Feathers instead of eggs for compost", debuff: "2x feathers needed" },
      "Sprout Surge":       { tree: "Compost", points: 1, tier: 1, buff: "Sprout Mix on all plots", debuff: null, power: true },
      "Blend-tastic":       { tree: "Compost", points: 1, tier: 1, buff: "Fruitful Blend on all plots", debuff: null, power: true },
      "Premium Worms":      { tree: "Compost", points: 2, tier: 2, buff: "+10 Rapid Root", debuff: null },
      "Fruitful Bounty":    { tree: "Compost", points: 2, tier: 2, buff: "Double Fruitful Blend effect", debuff: null },
      "Swift Decomposer":   { tree: "Compost", points: 2, tier: 2, buff: "-10% compost time", debuff: null },
      "Composting Bonanza":  { tree: "Compost", points: 2, tier: 2, buff: "+1h compost speed when boosting", debuff: "2x resources to boost" },
      "Root Rocket":        { tree: "Compost", points: 2, tier: 2, buff: "Rapid Root on all plots", debuff: null, power: true },
      "Composting Overhaul":{ tree: "Compost", points: 3, tier: 3, buff: "+2 Worms", debuff: "-5 fertilisers" },
      "Composting Revamp":  { tree: "Compost", points: 3, tier: 3, buff: "+5 fertilisers", debuff: "-3 Worms" },
    };

    // Recipe ingredients for skill cost calculation ‚Äî verified from sfl.world/info/cooking
    // XP values come from COOKING_RECIPES_DATA at runtime
    // Only recipes with P2P-tradeable ingredients (+ Cheese derived from Milk)
    const RECIPE_INGREDIENTS = {
      // Fire Pit
      "Pumpkin Soup":        { Pumpkin: 10 },
      "Bumpkin Broth":       { Carrot: 10, Cabbage: 5 },
      "Boiled Eggs":         { Egg: 10 },
      "Popcorn":             { Sunflower: 100, Corn: 5 },
      "Kale Stew":           { Kale: 10 },
      "Fried Tofu":          { Soybean: 15, Sunflower: 200 },
      "Kale Omelette":       { Egg: 40, Kale: 5 },
      "Rice Bun":            { Rice: 2, Wheat: 50 },
      "Antipasto":           { Olive: 2, Grape: 2 },
      "Pizza Margherita":    { Tomato: 30, Cheese: 5, Wheat: 20 },
      "Rhubarb Tart":        { Rhubarb: 3 },
      "Mashed Potato":       { Potato: 8 },
      // Kitchen
      "Sunflower Crunch":    { Sunflower: 300 },
      "Cauliflower Burger":  { Cauliflower: 15, Wheat: 5 },
      "Pancakes":            { Wheat: 10, Egg: 10, Honey: 6 },
      "Roast Veggies":       { Cauliflower: 15, Carrot: 10 },
      "Goblin's Treat":      { Pumpkin: 10, Radish: 20, Cabbage: 10 },
      "Club Sandwich":       { Sunflower: 100, Carrot: 25, Wheat: 5 },
      "Spaghetti al Limone": { Wheat: 10, Lemon: 15, Cheese: 3 },
      "Caprese Salad":       { Cheese: 1, Tomato: 25, Kale: 20 },
      "Steamed Red Rice":    { Rice: 3, Beetroot: 50 },
      "Tofu Scramble":       { Soybean: 20, Egg: 20, Cauliflower: 10 },
      "Bumpkin Salad":       { Beetroot: 20, Parsnip: 10 },
      "Fruit Salad":         { Apple: 1, Orange: 1, Blueberry: 1 },
      // Bakery
      "Lemon Cheesecake":    { Lemon: 20, Cheese: 5, Egg: 40 },
      "Honey Cake":          { Honey: 10, Wheat: 10, Egg: 20 },
      "Apple Pie":           { Apple: 5, Wheat: 10, Egg: 20 },
      "Orange Cake":         { Orange: 5, Egg: 30, Wheat: 10 },
      "Cornbread":           { Corn: 15, Wheat: 5, Egg: 10 },
      "Sunflower Cake":      { Sunflower: 1000, Wheat: 10, Egg: 30 },
      "Potato Cake":         { Potato: 500, Wheat: 10, Egg: 30 },
      "Pumpkin Cake":        { Pumpkin: 130, Wheat: 10, Egg: 30 },
      "Carrot Cake":         { Carrot: 120, Wheat: 10, Egg: 30 },
      "Cabbage Cake":        { Cabbage: 90, Wheat: 10, Egg: 30 },
      "Wheat Cake":          { Wheat: 35, Egg: 30 },
      "Cauliflower Cake":    { Cauliflower: 60, Wheat: 10, Egg: 30 },
      "Beetroot Cake":       { Beetroot: 100, Wheat: 10, Egg: 30 },
      "Parsnip Cake":        { Parsnip: 45, Wheat: 10, Egg: 30 },
      "Radish Cake":         { Radish: 25, Wheat: 10, Egg: 30 },
      "Eggplant Cake":       { Eggplant: 30, Wheat: 10, Egg: 30 },
      // Deli
      "Honey Cheddar":       { Cheese: 3, Honey: 5 },
      "Blue Cheese":         { Cheese: 2, Blueberry: 10 },
      "Blueberry Jam":       { Blueberry: 5 },
      "Sauerkraut":          { Cabbage: 20 },
      "Fermented Carrots":   { Carrot: 20 },
      "Fancy Fries":         { Sunflower: 500, Potato: 500 },
      // Smoothie Shack
      "Grape Juice":         { Grape: 5, Radish: 20 },
      "Slow Juice":          { Grape: 10, Kale: 100 },
      "Sour Shake":          { Lemon: 20 },
      "Purple Smoothie":     { Blueberry: 5, Cabbage: 10 },
      "Power Smoothie":      { Blueberry: 10, Kale: 5 },
      "Orange Juice":        { Orange: 5 },
      "Apple Juice":         { Apple: 5 },
      "Bumpkin Detox":       { Apple: 5, Orange: 5, Carrot: 10 },
      "The Lot":             { Blueberry: 1, Orange: 1, Grape: 1, Apple: 1, Banana: 1 },
      "Banana Blast":        { Banana: 10, Egg: 10 },
      "Carrot Juice":        { Carrot: 30 },
      "Quick Juice":         { Sunflower: 50, Pumpkin: 40 },
    };

    // Crop tier classification for "Basic/Medium/Advanced Crop" skill boosts
    const CROP_TIERS = {
      basic:    ["Sunflower", "Potato", "Pumpkin", "Carrot", "Cabbage", "Soybean", "Beetroot", "Cauliflower", "Parsnip", "Eggplant", "Corn", "Radish", "Wheat", "Kale"],
      medium:   ["Turnip", "Onion", "Pepper", "Zucchini", "Yam", "Broccoli"],
      advanced: ["Artichoke", "Barley"],
    };

    // Crafted ingredient recipes ‚Äî derive price from sub-ingredients
    const CRAFTED_INGREDIENT_RECIPES = {
      "Cheese": { "Milk": 3 },
    };

    // Calculate the SFL cost per skill point for current bumpkin
    function calcSkillPointCost(bumpkin, p2pPrices, farm) {
      const xp = bumpkin?.experience || 0;
      const level = getBumpkinLevel(xp);
      if (level <= 1) return { sflPerPoint: 0, bestRecipe: null, level, totalXP: xp };

      const totalXP = BUMPKIN_XP_TABLE[level - 1] || 0;

      // Build effective prices including crafted ingredients
      const prices = { ...p2pPrices };
      for (const [crafted, recipe] of Object.entries(CRAFTED_INGREDIENT_RECIPES)) {
        if (!prices[crafted]) {
          let derivedCost = 0;
          for (const [item, qty] of Object.entries(recipe)) {
            derivedCost += (prices[item] || 0) * qty;
          }
          if (derivedCost > 0) prices[crafted] = derivedCost;
        }
      }

      // Detect cooking boosts to apply XP multipliers
      const cookingBoosts = farm ? detectCookingBoosts(farm) : { xpBoosts: [], timeBoosts: [] };

      // Hardcoded: Pizza Margherita for verification (TODO: restore best-recipe search after verified)
      const recipeName = "Pizza Margherita";
      const ingredients = RECIPE_INGREDIENTS[recipeName];
      const recipeData = COOKING_RECIPES_DATA[recipeName];
      let cost = 0;
      let missingIngredient = false;
      for (const [item, qty] of Object.entries(ingredients)) {
        const price = prices[item] || 0;
        if (price === 0) { missingIngredient = true; break; }
        cost += price * qty;
      }
      if (missingIngredient || cost <= 0) return { sflPerPoint: 0, bestRecipe: null, level, totalXP };

      const boostedXP = computeFoodXP(recipeName, recipeData, recipeData.building, cookingBoosts);
      const bestRatio = boostedXP / cost;
      const bestRecipe = { name: recipeName, xp: recipeData.xp, boostedXP: Math.round(boostedXP), cost, ratio: bestRatio, building: recipeData.building, ingredients };

      if (bestRatio === 0) return { sflPerPoint: 0, bestRecipe: null, level, totalXP };

      // Total SFL to reach current level via most efficient cooking
      const totalSFL = totalXP / bestRatio;
      const sflPerLevel = totalSFL / level;
      // 1 level = 1 skill point
      const xpBoostNames = cookingBoosts.xpBoosts.filter(b =>
        !b.buildings || b.buildings.includes(bestRecipe.building)
      ).map(b => `${b.name} (√ó${b.multiplier})`);

      return { sflPerPoint: sflPerLevel, bestRecipe, level, totalXP, totalSFL, sflPerLevel, xpBoostNames };
    }

    // Power category definitions
    const POWER_CATEGORIES = {
      // Quantifiable
      crops:    { label: "CROPS",    emoji: "üåæ", selector: "crop",  quantifiable: true },
      fruits:   { label: "FRUITS",   emoji: "üçé", selector: "fruit", quantifiable: true },
      chickens: { label: "CHICKENS", emoji: "üêî", selector: null,   quantifiable: true },
      cows:     { label: "COWS",     emoji: "üêÑ", selector: null,   quantifiable: true },
      sheep:    { label: "SHEEP",    emoji: "üêë", selector: null,   quantifiable: true },
      flowers:  { label: "FLOWERS",  emoji: "üå∏", selector: "flower", quantifiable: true },
      stone:    { label: "STONE",    emoji: "‚õèÔ∏è", selector: null,   quantifiable: true },
      iron:     { label: "IRON",     emoji: "ü™®", selector: null,   quantifiable: true },
      gold:      { label: "GOLD",      emoji: "ü•á", selector: null,   quantifiable: true },
      crimstone: { label: "CRIMSTONE",emoji: "üíé", selector: null,   quantifiable: true },
      trees:     { label: "TREES",    emoji: "üå≥", selector: null,   quantifiable: true },
      fishing:  { label: "FISHING",  emoji: "üé£", selector: null,   quantifiable: true },
      bees:     { label: "BEES",     emoji: "üêù", selector: null,   quantifiable: true },
      // Qualitative
      cooking:    { label: "COOKING / XP",  emoji: "üç≥", selector: null, quantifiable: false },
      coins:      { label: "COINS / SFL",   emoji: "ü™ô", selector: null, quantifiable: false },
      protection: { label: "PROTECTION",    emoji: "üõ°Ô∏è", selector: null, quantifiable: false },
      other:      { label: "OTHER",         emoji: "‚ùì", selector: null, quantifiable: false },
    };

    // Map product names ‚Üí category IDs
    const PRODUCT_TO_CATEGORY = {};
    Object.keys(CROP_GROW_DATA).forEach(k => PRODUCT_TO_CATEGORY[k] = "crops");
    Object.keys(FRUIT_GROW_DATA).forEach(k => PRODUCT_TO_CATEGORY[k] = "fruits");
    ["Egg", "Feather"].forEach(k => PRODUCT_TO_CATEGORY[k] = "chickens");
    ["Milk", "Leather"].forEach(k => PRODUCT_TO_CATEGORY[k] = "cows");
    ["Wool", "Merino Wool"].forEach(k => PRODUCT_TO_CATEGORY[k] = "sheep");
    PRODUCT_TO_CATEGORY["Honey"] = "bees";
    PRODUCT_TO_CATEGORY["Stone"] = "stone";
    PRODUCT_TO_CATEGORY["Iron"] = "iron";
    PRODUCT_TO_CATEGORY["Gold"] = "gold";
    PRODUCT_TO_CATEGORY["Crimstone"] = "crimstone";
    PRODUCT_TO_CATEGORY["Wood"] = "trees";
    PRODUCT_TO_CATEGORY["Fish"] = "fishing";

    // Boost text parser rules (ordered by priority)
    const BOOST_PARSE_RULES = [
      // Specific product growth time: "-20% Pumpkin Growth Time"
      { rx: /([+-]?\d+\.?\d*)%\s+([\w\s]+?)\s+(?:Growth|Growing)\s+Time/i,
        fn: m => {
          const prod = m[2].trim();
          const cat = PRODUCT_TO_CATEGORY[prod];
          return cat ? { type: "speed_pct", value: parseFloat(m[1]), cat, product: prod }
                     : { type: "speed_pct", value: parseFloat(m[1]), cat: "other", product: prod };
        }},
      // Generic crop growth: "-10% Crop Growth Time"
      { rx: /([+-]?\d+\.?\d*)%\s+Crop\s+(?:Growth|Growing)\s+Time/i,
        fn: m => ({ type: "speed_pct", value: parseFloat(m[1]), cat: "crops" }) },
      // Fruit growth
      { rx: /([+-]?\d+\.?\d*)%\s+Fruit.*(?:Growth|Growing)\s+Time/i,
        fn: m => ({ type: "speed_pct", value: parseFloat(m[1]), cat: "fruits" }) },
      // Flower growth %
      { rx: /([+-]?\d+\.?\d*)%\s+Flower\s+(?:Growth|Growing)\s+Time/i,
        fn: m => ({ type: "speed_pct", value: parseFloat(m[1]), cat: "flowers" }) },
      // Flower growth multiplier: √ó0.9 Flower Growing Time
      { rx: /[√óx](\d+\.?\d*)\s+Flower\s+(?:Growth|Growing)\s+Time/i,
        fn: m => ({ type: "speed_mult", value: parseFloat(m[1]), cat: "flowers" }) },
      // Tree recovery
      { rx: /([+-]?\d+\.?\d*)%\s+Tree\s+Recovery\s+Time/i,
        fn: m => ({ type: "speed_pct", value: parseFloat(m[1]), cat: "trees" }) },
      // Animal time: "-10% Chicken Time"
      { rx: /([+-]?\d+\.?\d*)%\s+(Chicken|Cow|Sheep)\s+.*Time/i,
        fn: m => {
          const animalCats = { "Chicken": "chickens", "Cow": "cows", "Sheep": "sheep" };
          return { type: "speed_pct", value: parseFloat(m[1]), cat: animalCats[m[2]] || "other" };
        }},
      // Generic animal time / sleep
      { rx: /([+-]?\d+\.?\d*)%\s+Animal\s+(?:sleep\s+)?time/i,
        fn: m => ({ type: "speed_pct", value: parseFloat(m[1]), cat: "chickens", alsoApply: ["cows", "sheep"] }) },
      // Crop yield %
      { rx: /([+-]?\d+\.?\d*)%\s+Crop\s+Yield/i,
        fn: m => ({ type: "yield_pct", value: parseFloat(m[1]), cat: "crops" }) },
      // Basic/Medium/Advanced Crop yield flat: "+0.1 Basic Crop yield"
      { rx: /([+-]?\d+\.?\d*)\s+(Basic|Medium|Advanced)\s+Crop\s+yield/i,
        fn: m => ({ type: "yield_flat", value: parseFloat(m[1]), cat: "crops", cropTier: m[2].toLowerCase() }) },
      // Basic/Medium/Advanced Crop growth time
      { rx: /([+-]?\d+\.?\d*)%\s+(Basic|Medium|Advanced)\s+Crop\s+(?:Growth|Growing)\s+Time/i,
        fn: m => ({ type: "speed_pct", value: parseFloat(m[1]), cat: "crops", cropTier: m[2].toLowerCase() }) },
      // Fruit yield %
      { rx: /([+-]?\d+\.?\d*)%\s+Fruit\s+Yield/i,
        fn: m => ({ type: "yield_pct", value: parseFloat(m[1]), cat: "fruits" }) },
      // Animal yield %
      { rx: /([+-]?\d+\.?\d*)%\s+Animal\s+Yield/i,
        fn: m => ({ type: "yield_pct", value: parseFloat(m[1]), cat: "chickens", alsoApply: ["cows", "sheep"] }) },
      // Specific product yield %: "+10% Egg Yield" or "+10% Wood"
      { rx: /([+-]?\d+\.?\d*)%\s+(Egg|Milk|Wool|Merino Wool|Wood|Honey|Stone|Iron|Gold|Feather|Leather)\b/i,
        fn: m => {
          const cat = PRODUCT_TO_CATEGORY[m[2]] || "other";
          return { type: "yield_pct", value: parseFloat(m[1]), cat, product: m[2] };
        }},
      // Flat yield: "+0.1 Stone", "+1 Egg" (longer names first to prevent partial match)
      { rx: /([+-]?\d+\.?\d*)\s+(Merino Wool|Eggplant|Cauliflower|Sunflower|Blueberry|Artichoke|Beetroot|Broccoli|Parsnip|Zucchini|Cabbage|Soybean|Pumpkin|Leather|Feather|Potato|Carrot|Turnip|Pepper|Barley|Banana|Orange|Tomato|Radish|Wheat|Olive|Onion|Apple|Lemon|Grape|Honey|Stone|Rice|Corn|Kale|Wood|Gold|Iron|Wool|Milk|Yam|Egg)\b/i,
        fn: m => {
          const cat = PRODUCT_TO_CATEGORY[m[2]] || "other";
          return { type: "yield_flat", value: parseFloat(m[1]), cat, product: m[2] };
        }},
      // Chance: "20% Chance +1 Egg"
      { rx: /(\d+\.?\d*)%\s+Chance.*\+(\d+\.?\d*)\s+(\w+)/i,
        fn: m => {
          const cat = PRODUCT_TO_CATEGORY[m[3]] || "other";
          return { type: "chance", pct: parseFloat(m[1]), extra: parseFloat(m[2]), cat, product: m[3] };
        }},
      // Fishing: "+X daily fish" or fishing-specific
      { rx: /(\d+)\s+daily/i,
        fn: m => ({ type: "daily_flat", value: parseFloat(m[1]), cat: "fishing" }) },
      // XP boosts
      { rx: /([+-]?\d+\.?\d*)%?\s*(Cook|Bake|Food|Meal|Dish|Kitchen|Delivery|XP)\b/i,
        fn: m => ({ type: "qualitative", cat: "cooking", raw: m[0] }) },
      // Coin / SFL boosts
      { rx: /(Coin|SFL|Sell\s+Price|Revenue)/i,
        fn: m => ({ type: "qualitative", cat: "coins", raw: m[0] }) },
      // Protection
      { rx: /(Protect|Guard|Shield|Disaster|Repel)/i,
        fn: m => ({ type: "qualitative", cat: "protection", raw: m[0] }) },
      // Bee-specific
      { rx: /([+-]?\d+\.?\d*)%?\s*Honey/i,
        fn: m => {
          const v = parseFloat(m[1]);
          if (isNaN(v)) return { type: "qualitative", cat: "bees", raw: m[0] };
          return m[0].includes("%") ? { type: "yield_pct", value: v, cat: "bees" }
                                     : { type: "yield_flat", value: v, cat: "bees", product: "Honey" };
        }},
    ];

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  GLOBALS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    let FARM_ID, LIMIT, FLOWER_BEDS, TRAP_COUNT;
    let lastInventory = null, lastInProgress = null;
    let cachedFarmData = null;
    let configExpanded = false;
    let growingTimerInterval = null;
    let pbTimerInterval = null;

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  ROUTER
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function getPage() {
      const p = new URLSearchParams(window.location.search);
      const page = p.get("page");
      if (page && PAGES.includes(page)) return page;
      const cfg = getConfig();
      return cfg.farm ? "flowers" : "hub";
    }

    function navigateTo(page) {
      const url = new URL(window.location);
      url.searchParams.set("page", page);
      history.pushState(null, "", url);
      configExpanded = false;
      main();
    }

    window.addEventListener("popstate", () => main());

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  CONFIG (localStorage + URL)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function migrateApiKey() {
      const p = new URLSearchParams(window.location.search);
      let changed = false;
      // Clean up legacy URL params
      for (const legacy of ["key", "sunpetal"]) {
        if (p.has(legacy)) { p.delete(legacy); changed = true; }
      }
      // Clean up localStorage key (no longer needed)
      localStorage.removeItem("sfl_api_key");
      if (changed) {
        const newUrl = window.location.pathname + (p.toString() ? "?" + p.toString() : "");
        history.replaceState(null, "", newUrl);
      }
    }

    function getConfig() {
      const p = new URLSearchParams(window.location.search);
      return {
        farm: p.get("farm") || DEFAULTS.farm,
        limit: parseInt(p.get("limit") || DEFAULTS.limit, 10) || 5,
      };
    }

    function saveConfig(farm, limit) {
      const p = new URLSearchParams(window.location.search);
      if (farm) p.set("farm", farm); else p.delete("farm");
      if (limit) p.set("limit", limit);
      // Clean up legacy params
      p.delete("sunpetal");
      p.delete("key");
      // Preserve page param
      const page = p.get("page");
      if (!page) p.set("page", getPage());
      const newURL = window.location.pathname + "?" + p.toString();
      history.replaceState(null, "", newURL);
    }

    function applyConfig() {
      const farm = document.getElementById("cfg-farm").value.trim();
      const limit = document.getElementById("cfg-limit").value.trim();
      if (!farm) return;
      saveConfig(farm, limit);
      cachedFarmData = null;
      configExpanded = false;
      main();
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  NAV BAR
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function renderNavBar(page) {
      const links = [
        { id: "hub", label: "HUB" },
        { id: "flowers", label: "FLOWERS" },
        { id: "dolls", label: "DOLLS" },
        { id: "crustaceans", label: "CRABS" },
        { id: "bumpkin", label: "BUMPKIN" },
        { id: "treasury", label: "TREASURY" },
        { id: "sales", label: "SALES" },
        { id: "power", label: "POWER" },
      ];
      let html = '<div class="nav-bar pixel-panel">';
      for (const l of links) {
        const cls = page === l.id ? " active" : "";
        html += `<button class="nav-link${cls}" onclick="navigateTo('${l.id}')">${l.label}</button>`;
      }
      html += '<button class="nav-link help-btn" onclick="openHelp()">?</button>';
      html += '</div>';
      document.getElementById("nav-bar").innerHTML = html;
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  CONFIG BAR
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function renderConfigBar(page) {
      const cfg = getConfig();
      const el = document.getElementById("config-bar");
      const isHub = page === "hub";

      if (!isHub && !configExpanded && cfg.farm) {
        el.innerHTML = `<div class="config-collapsed pixel-panel pixel-font" onclick="expandConfig()">
          <span>Farm #${escHTML(cfg.farm)}</span>
          <span>Limit: ${cfg.limit}</span>
          <span class="config-toggle">EDIT &#9660;</span>
        </div>`;
        return;
      }

      el.innerHTML = `
        <div class="config-bar pixel-panel">
          <div class="config-field">
            <label class="pixel-font">FARM ID</label>
            <input id="cfg-farm" type="text" value="${escHTML(cfg.farm)}" placeholder="e.g. 155498">
          </div>
          <div class="config-field small">
            <label class="pixel-font">LIMIT</label>
            <input id="cfg-limit" type="number" min="1" max="99" value="${cfg.limit}">
          </div>
          <button class="config-go" onclick="applyConfig()">LOAD</button>
        </div>`;
    }

    function expandConfig() {
      configExpanded = true;
      renderConfigBar(getPage());
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  DONATE
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function renderDonate() {
      const qrURL = `https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=${encodeURIComponent(DONATE_ADDR)}&bgcolor=ffffff&color=2c1810`;
      document.getElementById("donate-section").innerHTML = `
        <div class="donate-section pixel-panel pixel-font">
          <h3>SUPPORT THE PROJECT</h3>
          <p>If this tool helped you, consider sending<br>a flower or some ETH</p>
          <div class="donate-qr">
            <img src="${qrURL}" alt="Donate QR">
          </div>
          <br>
          <div class="donate-addr-wrap">
            <span class="donate-addr">${DONATE_ADDR}</span>
            <button class="donate-copy" onclick="copyAddr()">COPY</button>
          </div>
          <div class="donate-chain-label">ETH / Polygon / Base / Arbitrum</div>
          <div style="margin-top:16px;padding-top:12px;border-top:2px solid rgba(92,58,30,0.4);font-size:10px;color:var(--text-dim)">
            Created by 0xStableFarmer - #155498<br>
            Based on data from <a href="https://sfl.world" target="_blank" style="color:var(--sunpetal);text-decoration:none">sfl.world</a><br>
            <span class="changelog-toggle" onclick="toggleChangelog()"><span id="changelog-arrow">‚ñ∂</span> v1.8</span>
            <div id="changelog-content" class="changelog-content" style="display:none">
              ${renderChangelog()}
            </div>
          </div>
        </div>`;
    }

    function copyAddr() {
      navigator.clipboard.writeText(DONATE_ADDR).then(() => {
        const btn = document.querySelector(".donate-copy");
        btn.textContent = "COPIED!";
        setTimeout(() => btn.textContent = "COPY", 2000);
      });
    }

    function toggleChangelog() {
      const el = document.getElementById("changelog-content");
      const arrow = document.getElementById("changelog-arrow");
      if (!el) return;
      const show = el.style.display === "none";
      el.style.display = show ? "block" : "none";
      arrow.textContent = show ? "‚ñº" : "‚ñ∂";
    }

    function renderChangelog() {
      const log = [
        { ver: "v1.8", items: [
          { t: "new", text: "Power Analyzer v2 ‚Äî full boost ROI calculator" },
          { t: "new", text: "120+ skills from complete skill tree (11 categories)" },
          { t: "new", text: "Skill cost estimation from bumpkin level + best cooking recipe" },
          { t: "new", text: "Per-category product selectors (crop/fruit/flower dropdown)" },
          { t: "new", text: "Solo + synergy SFL/day calculations for every boost" },
          { t: "new", text: "Expandable formula details with full calculation breakdown" },
          { t: "new", text: "Top 10 Best Buys section ‚Äî missing boosts sorted by ROI" },
          { t: "new", text: "Quantifiable (12) + qualitative (4) boost categories" },
          { t: "new", text: "Grow Planner on flowers page ‚Äî schedule until next Petal Blessed" },
          { t: "new", text: "Sales Tracker ‚Äî active listings/offers with P2P price comparison" },
          { t: "new", text: "API caching via Upstash Redis (5min TTL)" },
          { t: "new", text: "PWA support ‚Äî installable app with offline caching" },
          { t: "new", text: "Treasury: coin mode toggle, Betty sell prices, Treasures category" },
        ]},
        { ver: "v1.7", items: [
          { t: "new", text: "Treasury page ‚Äî farm value visualizer" },
          { t: "new", text: "5 value categories: Resources, Treasures, Collectibles, Wearables, Liquid" },
          { t: "new", text: "Treasure sell prices with Treasure Map (+20%) and Camel (+30%) boosts" },
          { t: "new", text: "NFT collectible & wearable valuations from sfl.world" },
          { t: "new", text: "SFL/USD/BTC conversion with live exchange rates" },
          { t: "new", text: "Pie chart breakdown + collapsible detail tables" },
          { t: "new", text: "Gems + coins liquid balance with best-tier conversion" },
          { t: "new", text: "Expandable version changelog in footer" },
        ]},
        { ver: "v1.6", items: [
          { t: "new", text: "Bumpkin XP Calculator page" },
          { t: "new", text: "Current level/XP with progress bar to target level" },
          { t: "new", text: "Building cards with recipe selectors (sorted by XP/hour)" },
          { t: "new", text: "Auto-detect cooking boosts (skills + collectibles)" },
          { t: "new", text: "Combined XP/day + days to target level calculation" },
          { t: "new", text: "Food in inventory XP breakdown" },
          { t: "new", text: "Pet streak detection with weekly status" },
        ]},
        { ver: "v1.5", items: [
          { t: "new", text: "Usage stats tracking (anonymous)" },
          { t: "fix", text: "Unified colors: green = have, red = don't have" },
          { t: "new", text: "Season detection ‚Äî IN SEASON / OFF SEASON badges" },
          { t: "new", text: "Current season shown in flower tracker header" },
          { t: "new", text: "Vercel Web Analytics" },
        ]},
        { ver: "v1.4", items: [
          { t: "new", text: "Multi-page app with nav bar (HUB | FLOWERS | DOLLS | CRABS)" },
          { t: "new", text: "Auto-detected flower boosts (7 boosts, multiplicative)" },
          { t: "new", text: "Dolls tracker with configurable tracking + ingredient breakdown" },
          { t: "new", text: "Crustaceans tracker ‚Äî Crab Pot / Mariner Pot sections" },
          { t: "new", text: "Help modal with usage instructions" },
          { t: "new", text: "No API key needed ‚Äî just enter your Farm ID" },
        ]},
        { ver: "v1.3", items: [
          { t: "new", text: "Auto-detect flower beds from API" },
          { t: "new", text: "Currently growing section with live timers" },
          { t: "new", text: "Clickable flower rows with dependency chain details" },
          { t: "new", text: "Favicon" },
        ]},
        { ver: "v1.2", items: [
          { t: "fix", text: "Proxy: use Node.js res API for Vercel compatibility" },
        ]},
        { ver: "v1.1", items: [
          { t: "new", text: "Vercel deployment with API proxy (CORS fix)" },
          { t: "new", text: "Custom domain: sunflower.sajmonium.quest" },
        ]},
        { ver: "v1.0", items: [
          { t: "new", text: "Initial release ‚Äî flower collection tracker" },
          { t: "new", text: "Progress bars, dependency chains, time estimates" },
          { t: "new", text: "Petal Blessed optimizer" },
        ]},
      ];
      return log.map(v =>
        `<div class="changelog-ver">${v.ver}</div>` +
        v.items.map(i =>
          `<div class="changelog-item"><span class="changelog-${i.t}">${i.t === "new" ? "NEW" : "FIX"}</span> ${escHTML(i.text)}</div>`
        ).join("")
      ).join("");
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  HELP MODAL
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function openHelp() {
      const el = document.getElementById("help-modal");
      el.style.display = "flex";
      el.innerHTML = `<div class="modal-content pixel-panel pixel-font">
        <h2>HOW TO USE</h2>
        <h3>1. GET YOUR FARM ID</h3>
        <p>In the game: <b>Settings &gt; Farm ID</b></p>
        <h3>2. ENTER YOUR FARM ID</h3>
        <p><b>Farm ID</b> - your farm number (e.g. 155498)<br>
        <b>Limit</b> - target count per item (default: 5)</p>
        <h3>FLOWER BOOSTS</h3>
        <p>Flower grow time boosts are <b>auto-detected</b> from your farm data:<br>
        Flower Crown, Moth Shrine, Flower Fox,<br>
        Blossom Hourglass, Blooming Boost,<br>
        Flower Power, Flowery Abode</p>
        <h3>3. BOOKMARK THIS PAGE</h3>
        <p>Your Farm ID and settings are saved in the URL.<br>
        Bookmark this page for quick access!</p>
        <h3>TRACKERS</h3>
        <p><b>FLOWERS</b> - All flower types with dependency chains and Petal Blessed planning<br>
        <b>DOLLS</b> - Doll crafting with ingredient requirements<br>
        <b>CRABS</b> - Crab/Mariner pot catches with chum needs</p>
        <h3>BUGS &amp; FEEDBACK</h3>
        <p><a href="https://github.com/hlavasim/sfl-flower-tracker/issues" target="_blank">github.com/hlavasim/sfl-flower-tracker/issues</a></p>
        <button class="modal-close" onclick="closeHelp()">CLOSE</button>
      </div>`;
    }

    function closeHelp() {
      document.getElementById("help-modal").style.display = "none";
    }

    document.addEventListener("click", (e) => {
      const modal = document.getElementById("help-modal");
      if (e.target === modal) closeHelp();
    });

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  HELPERS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function getCount(inv, name) {
      const v = inv[name];
      if (v === undefined || v === null) return 0;
      return Math.floor(parseFloat(v));
    }

    function formatHours(h) {
      if (h <= 0) return "Done";
      const totalMin = Math.round(h * 60);
      const d = Math.floor(totalMin / 1440);
      const hrs = Math.floor((totalMin % 1440) / 60);
      const min = totalMin % 60;
      if (d > 0 && hrs > 0) return `${d}d ${hrs}h`;
      if (d > 0) return `${d}d`;
      if (hrs > 0 && min > 0) return `${hrs}h ${min}m`;
      if (hrs > 0) return `${hrs}h`;
      return `${min}m`;
    }

    function flowerColorCSS(name) {
      if (name.startsWith("Red")) return "#e74c3c";
      if (name.startsWith("Yellow")) return "#f1c40f";
      if (name.startsWith("Purple")) return "#9b59b6";
      if (name.startsWith("Blue")) return "#3498db";
      if (name.startsWith("White")) return "#ecf0f1";
      if (name === "Prism Petal") return "linear-gradient(135deg,#e74c3c,#f1c40f,#3498db,#9b59b6)";
      if (name === "Celestial Frostbloom") return "#a8d8ea";
      if (name === "Primula Enigma") return "#d5a6e6";
      return "#bdc3c7";
    }

    function barClass(pct) {
      return pct >= 100 ? "bar-green" : "bar-red";
    }

    function escHTML(s) {
      return String(s).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;");
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  BUMPKIN HELPERS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function getBumpkinLevel(xp) {
      for (let i = BUMPKIN_XP_TABLE.length - 1; i >= 0; i--) {
        if (xp >= BUMPKIN_XP_TABLE[i]) return i + 1;
      }
      return 1;
    }

    function getAllEquippedWearables(farm) {
      // Main bumpkin + all farm hands (additional bumpkins)
      const all = [];
      if (farm.bumpkin?.equipped) all.push(farm.bumpkin.equipped);
      // Farm hands ‚Äî try common API field names
      const hands = farm.farmHands?.bumpkins || farm.farmHands || {};
      for (const hand of Object.values(hands)) {
        if (hand?.equipped) all.push(hand.equipped);
      }
      return all;
    }

    function isWearableEquipped(farm, name) {
      for (const equipped of getAllEquippedWearables(farm)) {
        if (Object.values(equipped).flat().includes(name)) return true;
      }
      return false;
    }

    function detectCookingBoosts(farm) {
      const skills = farm.bumpkin?.skills || {};
      const xpBoosts = [];
      const timeBoosts = [];

      // Check collectible OR wearable (handles both cases)
      function hasItem(name) {
        return findCollectible(farm, name).length > 0 || isWearableEquipped(farm, name);
      }
      // Try multiple name variants
      function hasAny(...names) {
        return names.some(n => hasItem(n));
      }

      // Debug: log all available items so user can spot missing boosts
      console.log("[Cooking Boosts] Collectibles:", Object.keys(farm.collectibles || {}));
      console.log("[Cooking Boosts] Home collectibles:", Object.keys(farm.home?.collectibles || {}));
      const allEquipped = getAllEquippedWearables(farm);
      console.log("[Cooking Boosts] Main bumpkin equipped:", allEquipped[0]);
      console.log("[Cooking Boosts] Farm hands equipped:", allEquipped.slice(1));
      console.log("[Cooking Boosts] farmHands raw:", farm.farmHands);
      console.log("[Cooking Boosts] Skills:", Object.keys(skills));

      // === XP BOOSTS ===
      // Skills
      if (skills["Munching Mastery"]) xpBoosts.push({ name: "Munching Mastery", multiplier: 1.05 });
      if (skills["Juicy Boost"]) xpBoosts.push({ name: "Juicy Boost", multiplier: 1.1, buildings: ["Smoothie Shack"] });
      if (skills["Drive-Through Deli"]) xpBoosts.push({ name: "Drive-Through Deli", multiplier: 1.15, buildings: ["Deli"] });
      if (skills["Buzzworthy Treats"]) xpBoosts.push({ name: "Buzzworthy Treats", multiplier: 1.1, honeyOnly: true });
      // Items (check both collectibles + wearables)
      if (hasItem("Golden Spatula")) xpBoosts.push({ name: "Golden Spatula", multiplier: 1.1 });
      if (hasItem("Observatory")) xpBoosts.push({ name: "Observatory", multiplier: 1.05 });
      if (hasItem("Blossombeard")) xpBoosts.push({ name: "Blossombeard", multiplier: 1.1 });
      if (hasItem("Grain Grinder")) xpBoosts.push({ name: "Grain Grinder", multiplier: 1.2, buildings: ["Bakery"] });
      if (hasItem("Lifetime Farmer Banner")) xpBoosts.push({ name: "Lifetime Farmer Banner", multiplier: 1.1 });

      // === PET STREAK (auto-detect from faction) ===
      const faction = farm.faction || {};
      const factionHistory = faction.history || {};
      const sortedWeeks = Object.keys(factionHistory).sort();
      const currentWeekKey = sortedWeeks[sortedWeeks.length - 1] || "";
      const prevWeekKey = sortedWeeks[sortedWeeks.length - 2] || "";
      const currentWeekData = factionHistory[currentWeekKey] || {};
      const prevWeekData = factionHistory[prevWeekKey] || {};
      const petStreak = currentWeekData.collectivePet?.streak || 0;
      const streakMultiplier = petStreak >= 8 ? 1.5 : petStreak >= 6 ? 1.3 : petStreak >= 4 ? 1.2 : petStreak >= 2 ? 1.1 : 1.0;
      const weeksToMax = petStreak >= 8 ? 0 : 8 - petStreak;
      // This week: boost active if player fed pet LAST week (petXP > 0)
      const thisWeekActive = (prevWeekData.petXP || 0) > 0 && streakMultiplier > 1;
      // Next week: qualifiesForBoost = player fed pet THIS week
      const nextWeekQualified = faction.pet?.qualifiesForBoost === true;
      const manualPetStreak = localStorage.getItem("sfl_pet_streak") === "1";

      if (thisWeekActive) {
        xpBoosts.push({ name: "Pet's Streak", multiplier: streakMultiplier, petStreak: true });
      } else if (manualPetStreak) {
        xpBoosts.push({ name: "Pet's Streak (simulate)", multiplier: 1.5, petStreak: true, manual: true });
      }

      const petStreakInfo = { streak: petStreak, multiplier: streakMultiplier, thisWeekActive, nextWeekQualified, weeksToMax, manualOverride: manualPetStreak };

      // === TIME BOOSTS ===
      // Skills
      if (skills["Double Nom"]) timeBoosts.push({ name: "Double Nom", multiplier: 0.5 });
      if (skills["Fast Feasts"]) timeBoosts.push({ name: "Fast Feasts", multiplier: 0.9, buildings: ["Fire Pit", "Kitchen"] });
      if (skills["Frosted Cakes"]) timeBoosts.push({ name: "Frosted Cakes", multiplier: 0.9, buildings: ["Bakery"] });
      // Items
      if (hasItem("Luna's Hat")) timeBoosts.push({ name: "Luna's Hat", multiplier: 0.5 });
      if (hasItem("Desert Gnome")) timeBoosts.push({ name: "Desert Gnome", multiplier: 0.9 });
      if (hasAny("Nightshade Medallion")) timeBoosts.push({ name: "Nightshade Medallion", multiplier: 0.75 });
      if (hasAny("Master Chefs Cleaver", "Master Chef's Cleaver")) timeBoosts.push({ name: "Master Chefs Cleaver", multiplier: 0.85 });

      console.log("[Cooking Boosts] Detected XP:", xpBoosts.map(b => b.name));
      console.log("[Cooking Boosts] Detected Time:", timeBoosts.map(b => b.name));
      console.log("[Cooking Boosts] Pet Streak:", petStreakInfo);

      return { xpBoosts, timeBoosts, petStreakInfo };
    }

    function computeFoodXP(foodName, food, buildingName, boosts) {
      let xp = food.xp;
      for (const b of boosts.xpBoosts) {
        if (b.buildings && !b.buildings.includes(buildingName)) continue;
        if (b.honeyOnly && !food.usesHoney) continue;
        xp *= b.multiplier;
      }
      return xp;
    }

    function computeCookTime(baseSec, buildingName, boosts) {
      let time = baseSec;
      for (const b of boosts.timeBoosts) {
        if (b.buildings && !b.buildings.includes(buildingName)) continue;
        time *= b.multiplier;
      }
      return time;
    }

    function formatCookTime(seconds) {
      if (seconds <= 0) return "Instant";
      const h = Math.floor(seconds / 3600);
      const m = Math.floor((seconds % 3600) / 60);
      const s = Math.floor(seconds % 60);
      if (h >= 24) { const d = Math.floor(h / 24); const rh = h % 24; return rh > 0 ? `${d}d ${rh}h` : `${d}d`; }
      if (h > 0 && m > 0) return `${h}h ${m}m`;
      if (h > 0) return `${h}h`;
      if (m > 0 && s > 0) return `${m}m ${s}s`;
      if (m > 0) return `${m}m`;
      return `${s}s`;
    }

    const BUMPKIN_DEFAULT_RECIPES = {
      "Fire Pit": "Pizza Margherita",
      "Kitchen": "Spaghetti al Limone",
      "Bakery": "Lemon Cheesecake",
      "Deli": "Honey Cheddar",
      "Smoothie Shack": "Sour Shake",
    };

    function getSavedBumpkinRecipes() {
      try {
        const saved = localStorage.getItem("sfl_bumpkin_recipes");
        return saved ? JSON.parse(saved) : {};
      } catch (e) { return {}; }
    }

    function selectBumpkinRecipe(building, recipe) {
      const saved = getSavedBumpkinRecipes();
      saved[building] = recipe;
      localStorage.setItem("sfl_bumpkin_recipes", JSON.stringify(saved));
      if (cachedFarmData) renderBumpkin(cachedFarmData);
    }

    function togglePetStreak() {
      const on = localStorage.getItem("sfl_pet_streak") === "1";
      localStorage.setItem("sfl_pet_streak", on ? "0" : "1");
      if (cachedFarmData) renderBumpkin(cachedFarmData);
    }

    function toggleFoodInventory() {
      const el = document.getElementById("food-inv-list");
      if (el) el.style.display = el.style.display === "none" ? "block" : "none";
      const arrow = document.getElementById("food-inv-arrow");
      if (arrow) arrow.textContent = el.style.display === "none" ? "‚ñ∂" : "‚ñº";
    }

    function setBumpkinTargetLevel(val) {
      localStorage.setItem("sfl_bumpkin_target", val);
      if (cachedFarmData) renderBumpkin(cachedFarmData);
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  DEPENDENCY COMPUTATION (flowers)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function isFlowerInput(inputName) {
      return FLOWER_RECIPES[inputName] !== undefined;
    }

    function buildDependencyGraph() {
      const dependents = {};
      for (const [name, recipe] of Object.entries(FLOWER_RECIPES)) {
        if (isFlowerInput(recipe.input)) {
          if (!dependents[recipe.input]) dependents[recipe.input] = [];
          dependents[recipe.input].push(name);
        }
      }
      return dependents;
    }

    function computeAllTotalNeeded(inventory, inProgress) {
      const dependents = buildDependencyGraph();
      const memo = {};
      const visiting = new Set();

      function compute(name) {
        if (memo[name] !== undefined) return memo[name];
        if (visiting.has(name)) return LIMIT;
        visiting.add(name);
        let total = LIMIT;
        const deps = dependents[name] || [];
        for (const dep of deps) {
          const depNeeded = compute(dep);
          const depHave = getCount(inventory, dep) + (inProgress[dep] || 0);
          total += Math.max(0, depNeeded - depHave);
        }
        visiting.delete(name);
        memo[name] = total;
        return total;
      }

      const result = {};
      for (const name of Object.keys(FLOWER_RECIPES)) {
        result[name] = compute(name);
      }
      return { totalNeeded: result, dependents };
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  API FETCH
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function extractInProgress(farm) {
      const pending = {};
      const add = (name, qty) => { pending[name] = (pending[name] || 0) + qty; };

      // Flowers
      const beds = farm.flowers?.flowerBeds || {};
      for (const bed of Object.values(beds)) {
        if (bed.flower?.name) {
          const crits = bed.flower.criticalHit || {};
          const bonus = Object.values(crits).reduce((s, c) => s + c, 0);
          add(bed.flower.name, 1 + bonus);
        }
      }

      // Dolls: craftingBox
      const cb = farm.craftingBox;
      if (cb && cb.status === "crafting" && cb.item?.collectible) {
        add(cb.item.collectible, 1);
      }

      // Crustaceans: crabTraps (only count if trap is ready)
      const traps = farm.crabTraps?.trapSpots || {};
      const nowMs = Date.now();
      for (const spot of Object.values(traps)) {
        const wt = spot.waterTrap;
        if (!wt) continue;
        const readyAt = toMs(wt.readyAt || 0);
        if (readyAt > nowMs) continue; // trap not ready yet
        const caught = wt.caught || {};
        for (const [name, qty] of Object.entries(caught)) {
          add(name, qty);
        }
      }

      return pending;
    }

    function toMs(ts) {
      // SFL API timestamps may be in seconds or milliseconds
      return ts < 1e12 ? ts * 1000 : ts;
    }

    function extractBedDetails(flowerBeds) {
      const beds = [];
      for (const [id, bed] of Object.entries(flowerBeds)) {
        if (bed.flower?.name) {
          const name = bed.flower.name;
          const recipe = FLOWER_RECIPES[name];
          const seedType = recipe ? recipe.seed : "Unknown";
          const baseSeconds = recipe ? SEED_DATA[seedType].baseSeconds : 86400;
          const plantedAt = toMs(bed.flower.plantedAt);
          const crits = bed.flower.criticalHit || {};
          const bonus = Object.values(crits).reduce((s, c) => s + c, 0);
          const totalYield = 1 + bonus;
          const readyAt = plantedAt + baseSeconds * 1000;
          beds.push({ id, name, plantedAt, seedType, bonus, totalYield, readyAt });
        } else {
          beds.push({ id, name: null, empty: true });
        }
      }
      beds.sort((a, b) => {
        if (a.empty && !b.empty) return 1;
        if (!a.empty && b.empty) return -1;
        if (a.empty && b.empty) return 0;
        return a.readyAt - b.readyAt;
      });
      return beds;
    }

    const PETAL_BLESSED_COOLDOWN = 96 * 60 * 60;

    function extractPetalBlessed(farm) {
      const powers = farm.bumpkin?.previousPowerUseAt;
      if (!powers || powers["Petal Blessed"] === undefined) {
        return { status: "unavailable" };
      }
      const hasLunas = farm.wardrobe?.["Luna's Crescent"] > 0;
      const cooldownMs = PETAL_BLESSED_COOLDOWN * (hasLunas ? 0.5 : 1) * 1000;
      const lastUsed = toMs(powers["Petal Blessed"]);
      const nextAt = lastUsed + cooldownMs;
      if (Date.now() >= nextAt) {
        return { status: "ready" };
      }
      return { status: "cooldown", nextAt };
    }

    async function fetchFarmData() {
      if (!FARM_ID) {
        throw new Error("Enter your Farm ID, then click LOAD");
      }

      const apiUrl = `https://api.sunflower-land.com/community/farms/${FARM_ID}`;
      const proxyUrl = `/api/proxy?url=${encodeURIComponent(apiUrl)}`;

      let data, lastErr;

      try {
        const resp = await fetch(proxyUrl);
        if (!resp.ok) throw new Error(`Proxy ${resp.status}`);
        data = await resp.json();
      } catch (proxyErr) {
        lastErr = proxyErr;
        console.warn("Proxy fetch failed:", proxyErr);
      }

      if (!data) throw lastErr || new Error("Failed to load farm data");

      const farm = data.farm || {};
      const inventory = farm.inventory || {};
      const flowerBeds = farm.flowers?.flowerBeds || {};
      const craftingBox = farm.craftingBox || null;
      const trapSpots = farm.crabTraps?.trapSpots || {};
      const inProgress = extractInProgress(farm);
      const petalBlessed = extractPetalBlessed(farm);
      const activeBoosts = detectFlowerBoosts(farm);
      const flowerMultiplier = computeFlowerMultiplier(activeBoosts);
      const season = farm.season?.season || null;
      const trades = farm.trades || {};
      return { inventory, inProgress, petalBlessed, flowerBeds, craftingBox, trapSpots, activeBoosts, flowerMultiplier, season, bumpkin: farm.bumpkin, buildings: farm.buildings, trades, farm };
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  TIMERS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function startGrowingTimers() {
      if (growingTimerInterval) clearInterval(growingTimerInterval);
      growingTimerInterval = setInterval(() => {
        const els = document.querySelectorAll(".growing-bed-time[data-ready]");
        if (els.length === 0) { clearInterval(growingTimerInterval); return; }
        const now = Date.now();
        els.forEach(el => {
          const readyAt = parseInt(el.dataset.ready, 10);
          const diff = readyAt - now;
          if (diff <= 0) {
            el.textContent = "Ready!";
            el.classList.remove("growing");
            el.classList.add("ready");
          } else {
            const h = Math.floor(diff / 3600000);
            const m = Math.floor((diff % 3600000) / 60000);
            const s = Math.floor((diff % 60000) / 1000);
            el.textContent = h > 0
              ? `${h}h ${String(m).padStart(2,"0")}m`
              : `${m}m ${String(s).padStart(2,"0")}s`;
          }
        });
      }, 1000);
    }

    function startPBTimer() {
      if (pbTimerInterval) clearInterval(pbTimerInterval);
      const el = document.getElementById("pb-timer");
      if (!el) return;
      const nextAt = parseInt(el.dataset.next, 10);

      function tick() {
        const el = document.getElementById("pb-timer");
        if (!el) { clearInterval(pbTimerInterval); return; }
        const diff = nextAt - Date.now();
        if (diff <= 0) {
          clearInterval(pbTimerInterval);
          refresh();
          return;
        }
        const h = Math.floor(diff / 3600000);
        const m = Math.floor((diff % 3600000) / 60000);
        const s = Math.floor((diff % 60000) / 1000);
        el.textContent = `${h}h ${String(m).padStart(2,"0")}m ${String(s).padStart(2,"0")}s`;
      }

      tick();
      pbTimerInterval = setInterval(tick, 1000);
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  CHAIN DETAILS (clickable expand)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function buildChainHTML(name, inventory, inProgress, visited) {
      if (!visited) visited = new Set();
      if (visited.has(name)) return `<div class="chain-step"><span class="chain-flower">${escHTML(name)}</span> (circular ref)</div>`;
      visited.add(name);

      const recipe = FLOWER_RECIPES[name];
      if (!recipe) return "";

      const sd = SEED_DATA[recipe.seed];
      const have = getCount(inventory, name) + (inProgress[name] || 0);
      const haveClass = have > 0 ? "chain-have" : "chain-need";

      let html = `<div class="chain-step">`;
      html += `<span class="${haveClass}">${escHTML(name)}</span>`;
      html += ` <span style="color:var(--text-dim)">(have: ${have})</span>`;
      html += ` = <span class="chain-seed">${sd.label} Seed</span>`;

      if (isFlowerInput(recipe.input)) {
        html += ` + <span class="chain-flower">${escHTML(recipe.input)}</span>`;
        html += buildChainHTML(recipe.input, inventory, inProgress, visited);
      } else {
        html += ` + <span class="chain-crop">${escHTML(recipe.input)}</span> <span style="color:var(--text-dim)">(crop)</span>`;
      }
      html += `</div>`;
      return html;
    }

    function toggleChain(el) {
      const row = el.closest(".flower-row");
      const existing = row.nextElementSibling;
      if (existing && existing.classList.contains("chain-detail")) {
        existing.remove();
        return;
      }
      document.querySelectorAll(".chain-detail").forEach(d => d.remove());

      const name = row.dataset.flower;
      if (!name || !lastInventory) return;

      const recipe = FLOWER_RECIPES[name];
      if (!recipe) return;

      const sd = SEED_DATA[recipe.seed];
      let html = `<strong>Recipe:</strong> <span class="chain-seed">${sd.label} Seed</span> + `;

      if (isFlowerInput(recipe.input)) {
        html += `<span class="chain-flower">${escHTML(recipe.input)}</span>`;
        html += buildChainHTML(recipe.input, lastInventory, lastInProgress || {});
      } else {
        html += `<span class="chain-crop">${escHTML(recipe.input)}</span> <span style="color:var(--text-dim)">(crop)</span>`;
      }

      const detail = document.createElement("div");
      detail.className = "chain-detail";
      detail.innerHTML = html;
      row.after(detail);
    }

    function toggleDollChain(el) {
      const row = el.closest(".flower-row");
      const existing = row.nextElementSibling;
      if (existing && existing.classList.contains("chain-detail")) {
        existing.remove();
        return;
      }
      document.querySelectorAll(".chain-detail").forEach(d => d.remove());

      const name = row.dataset.doll;
      if (!name || !lastInventory) return;

      const ingredients = DOLL_RECIPES[name];
      if (!ingredients || ingredients.length === 0) {
        const detail = document.createElement("div");
        detail.className = "chain-detail";
        detail.innerHTML = `<span style="color:var(--text-dim)">Recipe unknown</span>`;
        row.after(detail);
        return;
      }

      let html = `<strong>Ingredients per craft:</strong>`;
      for (const ing of ingredients) {
        const have = getCount(lastInventory, ing.item);
        const ok = have >= ing.qty;
        html += `<div class="chain-step">
          <span class="${ok ? "chain-have" : "chain-need"}">${escHTML(ing.item)}</span>
          x${ing.qty} <span style="color:var(--text-dim)">(have: ${have})</span>
          ${ok ? '<span style="color:var(--green)">OK</span>' : `<span style="color:var(--red)">need ${Math.max(0, ing.qty - have)} more</span>`}
        </div>`;
      }

      const detail = document.createElement("div");
      detail.className = "chain-detail";
      detail.innerHTML = html;
      row.after(detail);
    }

    function toggleCrustChain(el) {
      const row = el.closest(".flower-row");
      const existing = row.nextElementSibling;
      if (existing && existing.classList.contains("chain-detail")) {
        existing.remove();
        return;
      }
      document.querySelectorAll(".chain-detail").forEach(d => d.remove());

      const name = row.dataset.crust;
      if (!name || !lastInventory) return;

      const recipe = CRUSTACEAN_RECIPES[name];
      if (!recipe) return;

      let html = `<strong>Pot:</strong> ${escHTML(recipe.pot)} (${recipe.time})`;

      if (recipe.chum) {
        const chumHave = getCount(lastInventory, recipe.chum);
        const ok = chumHave >= recipe.qty;
        html += `<div class="chain-step">
          <strong>Chum:</strong> <span class="${ok ? "chain-have" : "chain-need"}">${escHTML(recipe.chum)}</span>
          x${recipe.qty} <span style="color:var(--text-dim)">(have: ${chumHave})</span>
          ${ok ? '<span style="color:var(--green)">OK</span>' : `<span style="color:var(--red)">need ${Math.max(0, recipe.qty - chumHave)} more</span>`}
        </div>`;
      } else {
        html += `<div class="chain-step"><span style="color:var(--text-dim)">No chum required</span></div>`;
      }

      if (recipe.alt) {
        html += `<div class="chain-step"><strong>Alt chum:</strong> <span style="color:var(--text-secondary)">${escHTML(recipe.alt)}</span></div>`;
      }

      const detail = document.createElement("div");
      detail.className = "chain-detail";
      detail.innerHTML = html;
      row.after(detail);
    }

    function togglePlannerChain(el) {
      const row = el.closest(".planner-row");
      const existing = row.nextElementSibling;
      if (existing && existing.classList.contains("chain-detail")) {
        existing.remove();
        return;
      }
      document.querySelectorAll(".planner-row + .chain-detail").forEach(d => d.remove());

      const name = row.dataset.flower;
      if (!name || !lastInventory) return;

      const recipe = FLOWER_RECIPES[name];
      if (!recipe) return;

      const sd = SEED_DATA[recipe.seed];
      let html = `<strong>Recipe:</strong> <span class="chain-seed">${sd.label} Seed</span> + `;

      if (isFlowerInput(recipe.input)) {
        html += `<span class="chain-flower">${escHTML(recipe.input)}</span>`;
        html += buildChainHTML(recipe.input, lastInventory, lastInProgress || {});
      } else {
        const cropHave = getCount(lastInventory, recipe.input);
        html += `<span class="chain-crop">${escHTML(recipe.input)}</span> <span style="color:var(--text-dim)">(have: ${cropHave})</span>`;
      }

      const detail = document.createElement("div");
      detail.className = "chain-detail";
      detail.innerHTML = html;
      row.after(detail);
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  PETAL BLESSED
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function getPetalBlessedRecommendation(inventory, inProgress) {
      const { totalNeeded } = computeAllTotalNeeded(inventory, inProgress);
      const candidates = [];
      for (const [name, needed] of Object.entries(totalNeeded)) {
        const have = getCount(inventory, name);
        const pend = inProgress[name] || 0;
        const remaining = Math.max(0, needed - have - pend);
        if (remaining <= 0) continue;
        const recipe = FLOWER_RECIPES[name];
        const seedHours = SEED_DATA[recipe.seed].hours;
        const inputIsFlower = isFlowerInput(recipe.input);
        let inputReady = true;
        if (inputIsFlower) {
          const inputHave = getCount(inventory, recipe.input) + (inProgress[recipe.input] || 0);
          if (inputHave <= 0) inputReady = false;
        }
        candidates.push({ name, remaining, seedHours, seed: recipe.seed, input: recipe.input, inputIsFlower, inputReady });
      }
      candidates.sort((a, b) => {
        if (b.seedHours !== a.seedHours) return b.seedHours - a.seedHours;
        if (a.inputReady !== b.inputReady) return a.inputReady ? -1 : 1;
        return b.remaining - a.remaining;
      });
      const picks = [];
      const used = {};
      for (const c of candidates) {
        if (picks.length >= FLOWER_BEDS) break;
        const canUse = Math.min(c.remaining - (used[c.name] || 0), FLOWER_BEDS - picks.length);
        for (let i = 0; i < canUse; i++) {
          picks.push(c);
          used[c.name] = (used[c.name] || 0) + 1;
        }
      }
      return picks;
    }

    function togglePetalBlessed() {
      const container = document.getElementById("petal-blessed-container");
      if (container.innerHTML) {
        container.innerHTML = "";
        return;
      }
      if (!lastInventory) return;

      const picks = getPetalBlessedRecommendation(lastInventory, lastInProgress);
      if (picks.length === 0) {
        container.innerHTML = `<div class="petal-blessed-panel pixel-font">
          <h3>PETAL BLESSED</h3>
          <p class="pb-subtitle">All flowers are complete! Nothing to grow.</p>
        </div>`;
        return;
      }

      const totalSaved = picks.reduce((s, p) => s + p.seedHours, 0);
      let bedsHTML = "";
      picks.forEach((p, i) => {
        const sd = SEED_DATA[p.seed];
        const inputLabel = p.inputIsFlower
          ? `${sd.label} Seed + <span style="color:var(--yellow)">${escHTML(p.input)}</span>${p.inputReady ? "" : " <span style='color:var(--red)'>(!)</span>"}`
          : `${sd.label} Seed + ${escHTML(p.input)}`;
        bedsHTML += `<div class="pb-bed">
          <div class="pb-bed-num">${i + 1}</div>
          <img class="pb-bed-img" src="${IMG_BASE}${encodeURIComponent(p.name)}.png" onerror="this.style.display='none'" alt="">
          <div class="pb-bed-info">
            <div class="pb-bed-name">${escHTML(p.name)}</div>
            <div class="pb-bed-recipe">${inputLabel}</div>
          </div>
          <div class="pb-bed-time">${formatHours(p.seedHours)}<div class="saved">saved</div></div>
        </div>`;
      });

      container.innerHTML = `<div class="petal-blessed-panel pixel-font">
        <h3>PETAL BLESSED</h3>
        <div class="pb-subtitle">Plant these ${picks.length} flowers, then use instant grow ‚Äî saves ${formatHours(totalSaved)}</div>
        ${bedsHTML}
        <button class="pb-close" onclick="togglePetalBlessed()">CLOSE</button>
      </div>`;
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  GROW PLANNER
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function getSleepSchedule() {
      try {
        const s = localStorage.getItem("sfl_sleep_schedule");
        if (s) return JSON.parse(s);
      } catch(e) {}
      return { start: 23, end: 7 };
    }

    function saveSleepSchedule(s) {
      localStorage.setItem("sfl_sleep_schedule", JSON.stringify(s));
    }

    function isHourDuringSleep(hour, sleep) {
      const s = sleep.start, e = sleep.end;
      return s < e ? (hour >= s && hour < e) : (hour >= s || hour < e);
    }

    function formatTimeShort(ms) {
      const d = new Date(ms);
      const days = ["Sun","Mon","Tue","Wed","Thu","Fri","Sat"];
      return `${days[d.getDay()]} ${String(d.getHours()).padStart(2,"0")}:${String(d.getMinutes()).padStart(2,"0")}`;
    }

    function buildGrowPlan(flowerData, beds, petalBlessed, sleep) {
      const now = Date.now();
      let pbTime = null, pbReady = false;
      if (petalBlessed.status === "ready") { pbTime = now; pbReady = true; }
      else if (petalBlessed.status === "cooldown") { pbTime = petalBlessed.nextAt; }

      // Collect plantable incomplete flowers sorted by grow time desc
      const incomplete = [];
      for (const [name, f] of Object.entries(flowerData)) {
        if (f.isComplete || f.remaining <= 0) continue;
        const growH = SEED_DATA[f.seed].hours;
        let inputOk = !f.inputIsFlower;
        if (f.inputIsFlower) {
          const id = flowerData[f.input];
          inputOk = id && id.have > 0;
        }
        incomplete.push({ name, seed: f.seed, growH, growMs: growH * 3600000, inputOk, remaining: f.remaining });
      }
      incomplete.sort((a, b) => b.growH !== a.growH ? b.growH - a.growH : b.remaining - a.remaining);

      const alloc = {};
      const canA = f => (alloc[f.name] || 0) < f.remaining;
      const doA = f => { alloc[f.name] = (alloc[f.name] || 0) + 1; };

      const bedFree = beds.map(b => b.empty ? now : Math.max(now, b.readyAt));
      const steps = [];

      if (!pbReady) {
        for (let i = 0; i < bedFree.length; i++) {
          let t = bedFree[i];
          const limit = pbTime || (t + 30 * 24 * 3600000);
          let safety = 10;
          while (safety-- > 0 && t < limit) {
            const rem = limit - t;
            let best = null;
            for (const f of incomplete) {
              if (!f.inputOk || !canA(f)) continue;
              if (pbTime && f.growMs > rem) continue;
              best = f;
              break;
            }
            if (!best) break;
            const fin = t + best.growMs;
            const fH = new Date(fin).getHours();
            steps.push({
              flower: best.name, seed: best.seed, growH: best.growH,
              startAt: t, finishAt: fin,
              sleepWaste: isHourDuringSleep(fH, sleep),
              bedIdx: i,
            });
            doA(best);
            t = fin;
            if (!pbTime) break;
          }
        }
      }

      // PB flowers: always longest incomplete
      const pbFlowers = [];
      if (pbTime) {
        for (const f of incomplete) {
          if (pbFlowers.length >= beds.length) break;
          if (!f.inputOk || !canA(f)) continue;
          pbFlowers.push({ name: f.name, seed: f.seed, growH: f.growH });
          doA(f);
        }
      }

      // Idle before PB
      let idleH = 0;
      if (pbTime && !pbReady) {
        const lastFin = steps.length > 0 ? Math.max(...steps.map(s => s.finishAt)) : Math.min(...bedFree);
        idleH = Math.max(0, (pbTime - lastFin) / 3600000);
      }

      return { steps, pbFlowers, pbTime, pbReady, idleH };
    }

    function renderGrowPlanner(flowerData, beds, petalBlessed) {
      if (Object.values(flowerData).every(f => f.isComplete)) return "";

      const sleep = getSleepSchedule();
      const plan = buildGrowPlan(flowerData, beds, petalBlessed, sleep);
      const now = Date.now();

      let html = `<div class="planner-section">`;

      // Header
      html += `<div class="planner-header" onclick="document.getElementById('planner-body').style.display=document.getElementById('planner-body').style.display==='none'?'block':'none'">
        <span class="pixel-font" style="font-size:11px">üìã GROW PLANNER</span>
        <span style="display:flex;align-items:center;gap:10px;font-size:9px">`;
      if (plan.pbTime && !plan.pbReady) {
        const d = plan.pbTime - now;
        html += `<span class="pixel-font" style="color:var(--lily)">‚ö° PB ${Math.floor(d/3600000)}h ${Math.floor((d%3600000)/60000)}m</span>`;
      } else if (plan.pbReady) {
        html += `<span class="pixel-font" style="color:var(--green)">‚ö° PB READY</span>`;
      }
      html += `<span class="pixel-font" style="color:var(--text-dim)">üí§ ${String(sleep.start).padStart(2,"0")}-${String(sleep.end).padStart(2,"0")}</span>`;
      html += `</span></div>`;

      html += `<div id="planner-body">`;

      if (plan.pbReady && plan.pbFlowers.length > 0) {
        // PB ready NOW
        html += `<div class="planner-body"><div class="planner-batch planner-pb-box">
          <div class="planner-batch-label pixel-font" style="color:var(--lily)">‚ö° USE PETAL BLESSED NOW</div>`;
        for (const f of plan.pbFlowers) {
          html += `<div class="planner-row" data-flower="${escHTML(f.name)}" onclick="togglePlannerChain(this)">
            <img src="${IMG_BASE}${encodeURIComponent(f.name)}.png" onerror="this.style.display='none'" alt="">
            <div class="planner-row-info"><div class="planner-row-name">${escHTML(f.name)}</div>
            <div class="planner-row-detail">${SEED_DATA[f.seed]?.label || "?"} ¬∑ saves ${formatHours(f.growH)}</div></div>
          </div>`;
        }
        const saved = plan.pbFlowers.reduce((s, f) => s + f.growH, 0);
        html += `<div class="planner-pb-saved pixel-font">Total saved: ${formatHours(saved)}</div>`;
        html += `</div></div>`;
      } else {
        html += `<div class="planner-body">`;

        // Group regular steps by approximate start time into batches
        if (plan.steps.length > 0) {
          const batches = [];
          const sorted = [...plan.steps].sort((a, b) => a.startAt - b.startAt);
          let cur = null;
          for (const s of sorted) {
            if (!cur || s.startAt - cur.t > 3600000) {
              cur = { t: s.startAt, items: [] };
              batches.push(cur);
            }
            cur.items.push(s);
          }

          for (const batch of batches) {
            const isNow = batch.t <= now + 60000;
            html += `<div class="planner-batch">
              <div class="planner-batch-label pixel-font">‚ñ∏ ${isNow ? "PLANT NOW" : "PLANT " + formatTimeShort(batch.t)}</div>`;
            for (const s of batch.items) {
              const cls = s.sleepWaste ? "planner-row-time sleep" : "planner-row-time";
              html += `<div class="planner-row" data-flower="${escHTML(s.flower)}" onclick="togglePlannerChain(this)">
                <img src="${IMG_BASE}${encodeURIComponent(s.flower)}.png" onerror="this.style.display='none'" alt="">
                <div class="planner-row-info"><div class="planner-row-name">${escHTML(s.flower)}</div>
                <div class="planner-row-detail">${SEED_DATA[s.seed]?.label || "?"} ¬∑ ${formatHours(s.growH)}</div></div>
                <div class="${cls}">‚Üí ${formatTimeShort(s.finishAt)}${s.sleepWaste ? " üí§" : ""}</div>
              </div>`;
            }
            html += `</div>`;
          }

          if (plan.idleH > 0.5 && plan.pbTime) {
            html += `<div class="planner-idle">‚è≥ ${Math.round(plan.idleH * 10) / 10}h idle before Petal Blessed</div>`;
          }
        } else if (!plan.pbTime) {
          html += `<div class="planner-idle">No Petal Blessed data ¬∑ plant highest priority flowers</div>`;
        } else {
          html += `<div class="planner-idle">‚è≥ No flowers fit before Petal Blessed ‚Äî wait for PB</div>`;
        }

        // PB batch (future)
        if (plan.pbFlowers.length > 0 && plan.pbTime && !plan.pbReady) {
          html += `<div class="planner-batch planner-pb-box">
            <div class="planner-batch-label pixel-font"><span style="color:var(--lily)">‚ö° PETAL BLESSED</span> <span style="color:var(--text-dim)">${formatTimeShort(plan.pbTime)}</span></div>`;
          for (const f of plan.pbFlowers) {
            html += `<div class="planner-row" data-flower="${escHTML(f.name)}" onclick="togglePlannerChain(this)">
              <img src="${IMG_BASE}${encodeURIComponent(f.name)}.png" onerror="this.style.display='none'" alt="">
              <div class="planner-row-info"><div class="planner-row-name">${escHTML(f.name)}</div>
              <div class="planner-row-detail">${SEED_DATA[f.seed]?.label || "?"} ¬∑ saves ${formatHours(f.growH)}</div></div>
            </div>`;
          }
          const saved = plan.pbFlowers.reduce((s, f) => s + f.growH, 0);
          html += `<div class="planner-pb-saved pixel-font">Total saved: ${formatHours(saved)}</div>`;
          html += `</div>`;
        }

        html += `</div>`;
      }

      // Sleep config
      html += `<div class="planner-sleep-cfg">
        üí§ Sleep:
        <input type="number" min="0" max="23" value="${sleep.start}" onchange="updateSleepSchedule(this,'start')">:00 ‚Äî
        <input type="number" min="0" max="23" value="${sleep.end}" onchange="updateSleepSchedule(this,'end')">:00
      </div>`;

      html += `</div></div>`;
      return html;
    }

    function updateSleepSchedule(input, field) {
      const s = getSleepSchedule();
      s[field] = Math.max(0, Math.min(23, parseInt(input.value) || 0));
      saveSleepSchedule(s);
      if (cachedFarmData) renderFlowers(cachedFarmData);
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  RENDER: HUB
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function renderHub(data) {
      const app = document.getElementById("app");
      const flowerTotal = Object.keys(FLOWER_RECIPES).length;
      const trackedDolls = getTrackedDolls();
      const dollTotal = Object.entries(trackedDolls).filter(([,v]) => v).length;
      const crustTotal = Object.keys(CRUSTACEAN_RECIPES).length;

      let flowerProgress = "", dollProgress = "", crustProgress = "", bumpkinProgress = "";

      if (data) {
        const { inventory, inProgress } = data;
        const { totalNeeded } = computeAllTotalNeeded(inventory, inProgress);

        let fc = 0;
        for (const [name, needed] of Object.entries(totalNeeded)) {
          if (getCount(inventory, name) + (inProgress[name] || 0) >= needed) fc++;
        }
        flowerProgress = `<div class="hub-card-progress pixel-font">${fc}/${flowerTotal} complete</div>`;

        let dc = 0;
        for (const [name, tracked] of Object.entries(trackedDolls)) {
          if (!tracked) continue;
          if (getCount(inventory, name) + (inProgress[name] || 0) >= LIMIT) dc++;
        }
        dollProgress = `<div class="hub-card-progress pixel-font">${dc}/${dollTotal} complete</div>`;

        let cc = 0;
        for (const name of Object.keys(CRUSTACEAN_RECIPES)) {
          if (getCount(inventory, name) + (inProgress[name] || 0) >= LIMIT) cc++;
        }
        crustProgress = `<div class="hub-card-progress pixel-font">${cc}/${crustTotal} complete</div>`;

        if (data.bumpkin) {
          const bxp = parseFloat(data.bumpkin.experience || 0);
          const blvl = getBumpkinLevel(bxp);
          bumpkinProgress = `<div class="hub-card-progress pixel-font">Level ${blvl}/200</div>`;
        }
      }

      let html = `<div class="header pixel-panel pixel-font">
        <h1>SFL COLLECTION TRACKER</h1>
        ${FARM_ID ? `<div class="farm-id">Farm #${escHTML(FARM_ID)} | Target: ${LIMIT} of each</div>` : `<div class="farm-id">Enter your Farm ID to get started</div>`}
      </div>`;

      html += `<div class="hub-cards">
        <div class="hub-card pixel-panel" onclick="navigateTo('flowers')">
          <div class="hub-card-icon">üå∏</div>
          <h3 class="pixel-font">FLOWERS</h3>
          <div class="hub-card-count pixel-font">${flowerTotal} types</div>
          ${flowerProgress}
        </div>
        <div class="hub-card pixel-panel" onclick="navigateTo('dolls')">
          <div class="hub-card-icon">ü™Ü</div>
          <h3 class="pixel-font">DOLLS</h3>
          <div class="hub-card-count pixel-font">${dollTotal} tracked</div>
          ${dollProgress}
        </div>
        <div class="hub-card pixel-panel" onclick="navigateTo('crustaceans')">
          <div class="hub-card-icon">ü¶Ä</div>
          <h3 class="pixel-font">CRUSTACEANS</h3>
          <div class="hub-card-count pixel-font">${crustTotal} types</div>
          ${crustProgress}
        </div>
        <div class="hub-card pixel-panel" onclick="navigateTo('bumpkin')">
          <div class="hub-card-icon">üë®‚Äçüç≥</div>
          <h3 class="pixel-font">BUMPKIN</h3>
          <div class="hub-card-count pixel-font">XP Calculator</div>
          ${bumpkinProgress}
        </div>
        <div class="hub-card pixel-panel" onclick="navigateTo('treasury')">
          <div class="hub-card-icon">üí∞</div>
          <h3 class="pixel-font">TREASURY</h3>
          <div class="hub-card-count pixel-font">Farm Value</div>
        </div>
        <div class="hub-card pixel-panel" onclick="navigateTo('sales')">
          <div class="hub-card-icon">üì§</div>
          <h3 class="pixel-font">SALES</h3>
          <div class="hub-card-count pixel-font">Marketplace</div>
        </div>
        <div class="hub-card pixel-panel" onclick="navigateTo('power')">
          <div class="hub-card-icon">‚ö°</div>
          <h3 class="pixel-font">POWER</h3>
          <div class="hub-card-count pixel-font">Boost ROI Analyzer</div>
        </div>
      </div>`;

      app.innerHTML = html;
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  RENDER: FLOWERS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function renderFlowers(data) {
      const { inventory, inProgress, petalBlessed, flowerBeds, activeBoosts, flowerMultiplier, season } = data;
      lastInventory = inventory;
      lastInProgress = inProgress;

      const { totalNeeded, dependents } = computeAllTotalNeeded(inventory, inProgress);
      const app = document.getElementById("app");

      const groups = {};
      for (const seed of SEED_ORDER) groups[seed] = [];
      for (const [name, recipe] of Object.entries(FLOWER_RECIPES)) {
        groups[recipe.seed].push(name);
      }

      const flowerData = {};
      let totalComplete = 0, totalAll = 0, grandRemaining = 0;

      for (const [name, needed] of Object.entries(totalNeeded)) {
        const have = getCount(inventory, name);
        const pend = inProgress[name] || 0;
        const remaining = Math.max(0, needed - have - pend);
        const isComplete = remaining === 0;
        if (isComplete) totalComplete++;
        totalAll++;
        grandRemaining += remaining;
        const recipe = FLOWER_RECIPES[name];
        flowerData[name] = {
          name, needed, have, pend, remaining, isComplete,
          seed: recipe.seed, input: recipe.input,
          inputIsFlower: isFlowerInput(recipe.input),
          consumedBy: dependents[name] || [],
          ownNeed: LIMIT, depNeed: needed - LIMIT,
        };
      }

      const seedStats = {};
      for (const seed of SEED_ORDER) {
        const flowers = groups[seed];
        let rem = 0, complete = 0;
        for (const f of flowers) {
          rem += flowerData[f].remaining;
          if (flowerData[f].isComplete) complete++;
        }
        const batches = Math.ceil(rem / FLOWER_BEDS);
        const hours = batches * SEED_DATA[seed].hours;
        seedStats[seed] = { remaining: rem, complete, total: flowers.length, batches, hours };
      }

      const grandHours = Object.values(seedStats).reduce((s, x) => s + x.hours, 0);
      const pctComplete = totalAll > 0 ? Math.round((totalComplete / totalAll) * 100) : 0;

      let html = "";

      html += `<div class="header pixel-panel pixel-font">
        <h1>FLOWER TRACKER</h1>
        <div class="farm-id">Farm #${escHTML(FARM_ID)} | Target: ${LIMIT} of each${season ? ` | Season: ${escHTML(season)}` : ""}</div>
      </div>`;

      html += `<div class="summary-bar pixel-panel pixel-font">
        <div class="summary-stat"><div class="label">COMPLETE</div><div class="value complete">${totalComplete} / ${totalAll}</div></div>
        <div class="summary-stat"><div class="label">REMAINING</div><div class="value pending">${grandRemaining} grows</div></div>
        <div class="summary-stat"><div class="label">BEDS</div><div class="value" style="color:var(--sunpetal)">${FLOWER_BEDS}</div></div>
        <div class="summary-stat"><div class="label">EST. TIME</div><div class="value time">${formatHours(grandHours)}</div></div>
      </div>`;

      if (activeBoosts && activeBoosts.length > 0) {
        const pctStr = Math.round(Math.abs(1 - flowerMultiplier) * 100);
        const sign = flowerMultiplier <= 1 ? "-" : "+";
        const color = flowerMultiplier <= 1 ? "var(--green)" : "var(--red)";
        html += `<div class="boost-bar pixel-panel pixel-font" style="padding:8px 12px;display:flex;flex-wrap:wrap;align-items:center;gap:6px 12px;font-size:9px">
          <span style="color:${color}">BOOSTS ${sign}${pctStr}%</span>
          ${activeBoosts.map(b => `<span style="color:var(--text-secondary)">${escHTML(b.name)} <span style="color:var(--text-dim)">&times;${b.multiplier}</span></span>`).join("")}
          <span style="color:var(--text-dim);margin-left:auto">Sunpetal: ${formatHours(SEED_DATA["Sunpetal Seed"].hours)}</span>
        </div>`;
      }

      html += `<div class="progress-overview pixel-panel">
        <div class="progress-label pixel-font"><span>Progress</span><span>${pctComplete}%</span></div>
        <div class="progress-bar-outer"><div class="progress-bar-fill green" style="width:${pctComplete}%"></div></div>
      </div>`;

      // Currently Growing
      const plannerBeds = flowerBeds ? extractBedDetails(flowerBeds) : [];
      if (plannerBeds.length > 0) {
        html += `<div class="growing-section pixel-panel pixel-font">
          <div class="growing-title">CURRENTLY GROWING</div>
          <div class="growing-grid">`;
        const now = Date.now();
        for (const bed of plannerBeds) {
          if (bed.empty) {
            html += `<div class="growing-bed empty-bed">
              <div style="width:28px;height:28px;display:flex;align-items:center;justify-content:center;font-size:18px;opacity:0.3">üå±</div>
              <div class="growing-bed-info"><div class="growing-bed-name" style="color:var(--text-dim)">Empty</div></div>
            </div>`;
          } else {
            const diff = bed.readyAt - now;
            const isReady = diff <= 0;
            let timeStr;
            if (isReady) { timeStr = "Ready!"; }
            else { const h = Math.floor(diff/3600000); const m = Math.floor((diff%3600000)/60000); timeStr = h > 0 ? `${h}h ${String(m).padStart(2,"0")}m` : `${m}m`; }
            const sdLabel = SEED_DATA[bed.seedType]?.label || "?";
            html += `<div class="growing-bed">
              <img class="growing-bed-img" src="${IMG_BASE}${encodeURIComponent(bed.name)}.png" onerror="this.style.display='none'" alt="">
              <div class="growing-bed-info">
                <div class="growing-bed-name">${escHTML(bed.name)}</div>
                <div class="growing-bed-detail">${sdLabel} | yield: ${bed.totalYield}${bed.bonus > 0 ? ` (1+${bed.bonus})` : ""}</div>
              </div>
              <div class="growing-bed-time ${isReady ? "ready" : "growing"}" data-ready="${bed.readyAt}">${timeStr}</div>
            </div>`;
          }
        }
        html += `</div></div>`;
      }

      // Petal Blessed
      if (petalBlessed.status === "ready") {
        html += `<button class="petal-blessed-btn" onclick="togglePetalBlessed()">Petal Blessed READY ‚Äî tap to plan!</button>`;
      } else if (petalBlessed.status === "cooldown") {
        html += `<div class="petal-blessed-btn pb-cooldown" style="cursor:default;opacity:0.7;background:linear-gradient(180deg,#3b1768,#2a1050,#1e0a3c)">Petal Blessed in <span id="pb-timer" data-next="${petalBlessed.nextAt}">--:--:--</span></div>`;
      }
      html += `<div id="petal-blessed-container"></div>`;

      // Grow Planner
      html += renderGrowPlanner(flowerData, plannerBeds, petalBlessed);

      // Seed sections
      for (const seed of SEED_ORDER) {
        const sd = SEED_DATA[seed];
        const ss = seedStats[seed];
        const flowers = groups[seed];
        if (flowers.length === 0) continue;

        html += `<div class="seed-section">`;
        html += `<div class="seed-header pixel-font">
          <img class="seed-icon" src="${IMG_BASE}${encodeURIComponent(seed)}.webp" onerror="this.style.display='none'" alt="">
          <h2 style="color:${sd.color}">${sd.label}</h2>
          ${sd.season ? (() => { const inSeason = sd.season.toLowerCase() === (season || "").toLowerCase(); return `<span class="seed-badge" style="border-color:${inSeason ? 'var(--green)' : 'var(--text-dim)'};color:${inSeason ? 'var(--green)' : 'var(--text-dim)'};${inSeason ? '' : 'opacity:0.5;text-decoration:line-through'}">${sd.season}</span>`; })() : ""}
          <div class="seed-meta">
            <span>${formatHours(sd.hours)} / grow</span>
            <span>${ss.complete}/${ss.total} done</span>
            <span>${ss.remaining > 0 ? `~${ss.batches} batches = ${formatHours(ss.hours)}` : "All complete!"}</span>
          </div>
        </div>`;

        html += `<div class="flower-grid">`;

        const sorted = [...flowers].sort((a, b) => {
          const fa = flowerData[a], fb = flowerData[b];
          if (fa.isComplete !== fb.isComplete) return fa.isComplete ? 1 : -1;
          return fb.remaining - fa.remaining;
        });

        for (const fname of sorted) {
          const f = flowerData[fname];
          const pct = f.needed > 0 ? Math.min(100, Math.round(((f.have + f.pend) / f.needed) * 100)) : 100;
          const color = flowerColorCSS(fname);
          const isGradient = color.includes("gradient");

          let chainHTML = "";
          if (f.inputIsFlower) {
            const inputData = flowerData[f.input];
            const avail = inputData ? inputData.have + inputData.pend : 0;
            const inputOk = avail > 0;
            chainHTML += `<span style="color:${inputOk ? 'var(--green)' : 'var(--red)'}">${escHTML(f.input)}</span>`;
            chainHTML += ` (${avail} avail)`;
          } else {
            const cropHave = getCount(inventory, f.input);
            const cropOk = cropHave > 0;
            chainHTML += `<span style="color:${cropOk ? 'var(--green)' : 'var(--red)'}">${escHTML(f.input)}</span> (${cropHave} avail)`;
          }
          if (f.consumedBy.length > 0) {
            const tags = f.consumedBy.map(c => {
              const cd = flowerData[c];
              return `<span class="consumed-tag">${escHTML(c)} (x${cd ? cd.needed : "?"})</span>`;
            }).join("");
            chainHTML += ` <span class="consumed-by">used in</span>${tags}`;
          }

          html += `<div class="flower-row ${f.isComplete ? "complete" : ""}" data-flower="${escHTML(fname)}" onclick="toggleChain(this)">
            <div class="flower-img-wrap">
              <img class="flower-img" src="${IMG_BASE}${encodeURIComponent(fname)}.png" onerror="this.style.display='none';this.nextElementSibling.style.display='flex'" alt="">
              <div class="flower-color-dot" style="display:none;${isGradient ? "background:" + color : "background-color:" + color}"></div>
            </div>
            <div class="flower-info">
              <div class="flower-name">${escHTML(fname)}</div>
              <div class="flower-chain">${chainHTML}</div>
            </div>
            <div class="flower-progress">
              <div class="flower-bar-outer"><div class="flower-bar-fill ${barClass(pct)}" style="width:${pct}%"></div></div>
              <div class="flower-count">
                <span class="have">${f.have}${f.pend > 0 ? `<span class="pending">+${f.pend}</span>` : ""} / ${f.needed}</span>
                ${f.depNeed > 0 ? `<span style="color:var(--text-dim);font-size:9px">(${f.ownNeed}+${f.depNeed})</span>` : ""}
              </div>
            </div>
            <div class="flower-time">
              ${f.isComplete
                ? `<div class="done pixel-font">DONE</div>`
                : `<div class="remaining-count pixel-font">-${f.remaining}</div><div class="remaining-time">${formatHours(f.remaining * sd.hours)}</div>`}
            </div>
          </div>`;
        }

        html += `</div></div>`;
      }

      html += `<div class="footer">
        <button class="refresh-btn" onclick="refresh()">REFRESH</button>
        <div class="timestamp pixel-font">Updated: ${new Date().toLocaleTimeString("cs-CZ")}</div>
      </div>`;

      app.innerHTML = html;
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  RENDER: DOLLS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function renderDolls(data) {
      const { inventory, inProgress, craftingBox } = data;
      lastInventory = inventory;
      lastInProgress = inProgress;
      const app = document.getElementById("app");

      const trackedDolls = getTrackedDolls();
      const dollList = [];
      let totalComplete = 0, totalAll = 0, grandRemaining = 0;

      for (const [name, tracked] of Object.entries(trackedDolls)) {
        if (!tracked) continue;
        totalAll++;
        const have = getCount(inventory, name);
        const pend = inProgress[name] || 0;
        const remaining = Math.max(0, LIMIT - have - pend);
        const isComplete = remaining === 0;
        if (isComplete) totalComplete++;
        grandRemaining += remaining;
        dollList.push({ name, have, pend, remaining, isComplete, ingredients: DOLL_RECIPES[name] || [], needed: LIMIT });
      }

      const pctComplete = totalAll > 0 ? Math.round((totalComplete / totalAll) * 100) : 0;

      let html = `<div class="header pixel-panel pixel-font">
        <h1>DOLL TRACKER</h1>
        <div class="farm-id">Farm #${escHTML(FARM_ID)} | Target: ${LIMIT} of each</div>
      </div>`;

      // Tracked dolls toggle
      const allDollNames = Object.keys(DOLL_RECIPES);
      const trackedCount = Object.values(trackedDolls).filter(v => v).length;
      html += `<div class="config-collapsed pixel-panel pixel-font" onclick="this.nextElementSibling.style.display=this.nextElementSibling.style.display==='none'?'block':'none'" style="cursor:pointer">
        <span>Tracking ${trackedCount}/${allDollNames.length} dolls</span>
        <span class="config-toggle">CONFIGURE &#9660;</span>
      </div>
      <div style="display:none;margin-bottom:16px;padding:12px 16px;background:var(--bg-dark);border:4px solid var(--border-brown);box-shadow:0 0 0 3px #000">
        <div style="display:flex;flex-wrap:wrap;gap:6px">
          ${allDollNames.map(name => {
            const on = trackedDolls[name];
            return `<button onclick="event.stopPropagation();toggleDollTracked('${escHTML(name)}')" style="font-family:'Press Start 2P',cursive;font-size:8px;padding:6px 8px;border:2px solid ${on ? 'var(--green)' : 'var(--border-brown)'};background:${on ? 'rgba(48,209,88,0.15)' : 'var(--bg-card)'};color:${on ? 'var(--green)' : 'var(--text-dim)'};cursor:pointer;white-space:nowrap">${escHTML(name.replace(' Doll',''))}</button>`;
          }).join("")}
        </div>
      </div>`;

      html += `<div class="summary-bar pixel-panel pixel-font">
        <div class="summary-stat"><div class="label">COMPLETE</div><div class="value complete">${totalComplete} / ${totalAll}</div></div>
        <div class="summary-stat"><div class="label">REMAINING</div><div class="value pending">${grandRemaining} crafts</div></div>
      </div>`;

      html += `<div class="progress-overview pixel-panel">
        <div class="progress-label pixel-font"><span>Progress</span><span>${pctComplete}%</span></div>
        <div class="progress-bar-outer"><div class="progress-bar-fill green" style="width:${pctComplete}%"></div></div>
      </div>`;

      // Currently Crafting
      if (craftingBox && craftingBox.status === "crafting" && craftingBox.item?.collectible) {
        const readyAttr = craftingBox.readyAt ? ` data-ready="${craftingBox.readyAt}"` : "";
        html += `<div class="growing-section pixel-panel pixel-font">
          <div class="growing-title">CURRENTLY CRAFTING</div>
          <div class="growing-grid">
            <div class="growing-bed">
              <div style="font-size:24px;flex-shrink:0">ü™Ü</div>
              <div class="growing-bed-info">
                <div class="growing-bed-name">${escHTML(craftingBox.item.collectible)}</div>
                <div class="growing-bed-detail">Crafting Box</div>
              </div>
              <div class="growing-bed-time growing"${readyAttr}>Crafting...</div>
            </div>
          </div>
        </div>`;
      }

      // Doll list
      const sorted = dollList.sort((a, b) => {
        if (a.isComplete !== b.isComplete) return a.isComplete ? 1 : -1;
        return b.remaining - a.remaining;
      });

      html += `<div class="flower-grid" style="border:3px solid var(--border-dark)">`;
      for (const d of sorted) {
        const pct = d.needed > 0 ? Math.min(100, Math.round(((d.have + d.pend) / d.needed) * 100)) : 100;

        let ingredientHTML = "";
        if (d.ingredients.length === 0) {
          ingredientHTML = `<span style="color:var(--text-dim)">Recipe unknown</span>`;
        } else {
          ingredientHTML = d.ingredients.map(ing => {
            const have = getCount(inventory, ing.item);
            const ok = have >= ing.qty;
            return `<span style="color:${ok ? 'var(--green)' : 'var(--red)'}">${escHTML(ing.item)} x${ing.qty}</span>`;
          }).join(", ");
        }

        html += `<div class="flower-row ${d.isComplete ? 'complete' : ''}" data-doll="${escHTML(d.name)}" onclick="toggleDollChain(this)">
          <div class="flower-img-wrap" style="font-size:22px">ü™Ü</div>
          <div class="flower-info">
            <div class="flower-name">${escHTML(d.name)}</div>
            <div class="flower-chain">${ingredientHTML}</div>
          </div>
          <div class="flower-progress">
            <div class="flower-bar-outer"><div class="flower-bar-fill ${barClass(pct)}" style="width:${pct}%"></div></div>
            <div class="flower-count">
              <span class="have">${d.have}${d.pend > 0 ? `<span class="pending">+${d.pend}</span>` : ""} / ${d.needed}</span>
            </div>
          </div>
          <div class="flower-time">
            ${d.isComplete
              ? `<div class="done pixel-font">DONE</div>`
              : `<div class="remaining-count pixel-font">-${d.remaining}</div>`}
          </div>
        </div>`;
      }
      html += `</div>`;

      html += `<div class="footer">
        <button class="refresh-btn" onclick="refresh()">REFRESH</button>
        <div class="timestamp pixel-font">Updated: ${new Date().toLocaleTimeString("cs-CZ")}</div>
      </div>`;

      app.innerHTML = html;
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  RENDER: CRUSTACEANS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function renderCrustaceans(data) {
      const { inventory, inProgress, trapSpots } = data;
      lastInventory = inventory;
      lastInProgress = inProgress;
      const app = document.getElementById("app");

      TRAP_COUNT = Math.max(1, Object.keys(trapSpots).length);

      let totalComplete = 0, totalAll = 0, grandRemaining = 0;
      const crustData = {};

      for (const [name, recipe] of Object.entries(CRUSTACEAN_RECIPES)) {
        totalAll++;
        const have = getCount(inventory, name);
        const pend = inProgress[name] || 0;
        const remaining = Math.max(0, LIMIT - have - pend);
        const isComplete = remaining === 0;
        if (isComplete) totalComplete++;
        grandRemaining += remaining;
        crustData[name] = { name, have, pend, remaining, isComplete, ...recipe, needed: LIMIT };
      }

      const pctComplete = totalAll > 0 ? Math.round((totalComplete / totalAll) * 100) : 0;

      let html = `<div class="header pixel-panel pixel-font">
        <h1>CRUSTACEAN TRACKER</h1>
        <div class="farm-id">Farm #${escHTML(FARM_ID)} | Target: ${LIMIT} of each</div>
      </div>`;

      html += `<div class="summary-bar pixel-panel pixel-font">
        <div class="summary-stat"><div class="label">COMPLETE</div><div class="value complete">${totalComplete} / ${totalAll}</div></div>
        <div class="summary-stat"><div class="label">REMAINING</div><div class="value pending">${grandRemaining} traps</div></div>
        <div class="summary-stat"><div class="label">TRAPS</div><div class="value" style="color:var(--sunpetal)">${TRAP_COUNT}</div></div>
      </div>`;

      html += `<div class="progress-overview pixel-panel">
        <div class="progress-label pixel-font"><span>Progress</span><span>${pctComplete}%</span></div>
        <div class="progress-bar-outer"><div class="progress-bar-fill green" style="width:${pctComplete}%"></div></div>
      </div>`;

      // Currently Trapping ‚Äî show ready + in-progress
      const readyItems = [];
      const trappingItems = [];
      const nowMs = Date.now();
      for (const [id, spot] of Object.entries(trapSpots)) {
        const wt = spot.waterTrap;
        if (!wt) continue;
        const readyAt = toMs(wt.readyAt || 0);
        const caught = wt.caught || {};
        const names = Object.entries(caught);
        if (names.length === 0) continue;
        if (readyAt <= nowMs) {
          for (const [name, qty] of names) readyItems.push({ id, name, qty });
        } else {
          for (const [name, qty] of names) trappingItems.push({ id, name, qty, readyAt });
        }
      }

      if (trappingItems.length > 0) {
        html += `<div class="growing-section pixel-panel pixel-font">
          <div class="growing-title">TRAPPING</div>
          <div class="growing-grid">`;
        for (const c of trappingItems) {
          const diff = c.readyAt - nowMs;
          const timeStr = diff > 3600000 ? `${(diff / 3600000).toFixed(1)}h` : `${Math.ceil(diff / 60000)}m`;
          html += `<div class="growing-bed">
            <div style="font-size:24px;flex-shrink:0">‚è≥</div>
            <div class="growing-bed-info">
              <div class="growing-bed-name">${escHTML(c.name)}</div>
              <div class="growing-bed-detail">x${c.qty}</div>
            </div>
            <div class="growing-bed-time growing" data-ready="${c.readyAt}">${timeStr}</div>
          </div>`;
        }
        html += `</div></div>`;
      }

      if (readyItems.length > 0) {
        html += `<div class="growing-section pixel-panel pixel-font">
          <div class="growing-title">READY TO COLLECT</div>
          <div class="growing-grid">`;
        for (const c of readyItems) {
          html += `<div class="growing-bed">
            <div style="font-size:24px;flex-shrink:0">ü¶Ä</div>
            <div class="growing-bed-info">
              <div class="growing-bed-name">${escHTML(c.name)}</div>
              <div class="growing-bed-detail">x${c.qty}</div>
            </div>
            <div class="growing-bed-time ready">Collect!</div>
          </div>`;
        }
        html += `</div></div>`;
      }

      // Pot sections
      const potGroups = {
        "Crab Pot": { label: "CRAB POT", time: "4h", emoji: "ü¶Ä", items: [] },
        "Mariner Pot": { label: "MARINER POT", time: "8h", emoji: "üêü", items: [] },
      };

      for (const [name, d] of Object.entries(crustData)) {
        potGroups[d.pot].items.push(d);
      }

      for (const [potType, group] of Object.entries(potGroups)) {
        const sorted = [...group.items].sort((a, b) => {
          if (a.isComplete !== b.isComplete) return a.isComplete ? 1 : -1;
          return b.remaining - a.remaining;
        });

        const complete = sorted.filter(d => d.isComplete).length;

        html += `<div class="seed-section">
          <div class="seed-header pixel-font">
            <div style="font-size:22px">${group.emoji}</div>
            <h2 style="color:var(--blue)">${group.label}</h2>
            <div class="seed-meta">
              <span>${group.time} / trap</span>
              <span>${complete}/${sorted.length} done</span>
            </div>
          </div>
          <div class="flower-grid">`;

        for (const d of sorted) {
          const pct = d.needed > 0 ? Math.min(100, Math.round(((d.have + d.pend) / d.needed) * 100)) : 100;

          let chumHTML = "";
          if (d.chum) {
            const chumHave = getCount(inventory, d.chum);
            const ok = chumHave >= d.qty;
            chumHTML = `<span style="color:${ok ? 'var(--green)' : 'var(--red)'}">${escHTML(d.chum)} x${d.qty}</span>`;
            if (d.alt) chumHTML += ` <span style="color:var(--text-dim);font-size:10px">alt: ${escHTML(d.alt)}</span>`;
          } else {
            chumHTML = `<span style="color:var(--text-dim)">No chum needed</span>`;
          }

          html += `<div class="flower-row ${d.isComplete ? 'complete' : ''}" data-crust="${escHTML(d.name)}" onclick="toggleCrustChain(this)">
            <div class="flower-img-wrap" style="font-size:18px">${group.emoji}</div>
            <div class="flower-info">
              <div class="flower-name">${escHTML(d.name)}</div>
              <div class="flower-chain">${chumHTML}</div>
            </div>
            <div class="flower-progress">
              <div class="flower-bar-outer"><div class="flower-bar-fill ${barClass(pct)}" style="width:${pct}%"></div></div>
              <div class="flower-count">
                <span class="have">${d.have}${d.pend > 0 ? `<span class="pending">+${d.pend}</span>` : ""} / ${d.needed}</span>
              </div>
            </div>
            <div class="flower-time">
              ${d.isComplete
                ? `<div class="done pixel-font">DONE</div>`
                : `<div class="remaining-count pixel-font">-${d.remaining}</div>`}
            </div>
          </div>`;
        }

        html += `</div></div>`;
      }

      html += `<div class="footer">
        <button class="refresh-btn" onclick="refresh()">REFRESH</button>
        <div class="timestamp pixel-font">Updated: ${new Date().toLocaleTimeString("cs-CZ")}</div>
      </div>`;

      app.innerHTML = html;
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  RENDER: BUMPKIN
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function renderBumpkin(data) {
      const { bumpkin, buildings, farm } = data;
      const app = document.getElementById("app");

      if (!bumpkin) {
        app.innerHTML = `<div class="error-screen pixel-panel pixel-font">
          <div class="icon">‚ö†Ô∏è</div>
          <h2>No bumpkin data found</h2>
          <p>Make sure your Farm ID is correct.</p>
        </div>`;
        return;
      }

      const currentXP = parseFloat(bumpkin.experience || 0);
      const currentLevel = getBumpkinLevel(currentXP);
      const maxXP = BUMPKIN_XP_TABLE[199];

      // Target level (user-adjustable)
      const savedTarget = parseInt(localStorage.getItem("sfl_bumpkin_target") || "200");
      const targetLevel = Math.max(currentLevel + 1, Math.min(200, savedTarget));
      const targetXP = BUMPKIN_XP_TABLE[targetLevel - 1];
      const xpRemaining = Math.max(0, targetXP - currentXP);
      const xpPctTotal = Math.min(100, (currentXP / maxXP) * 100);
      const xpPctTarget = Math.min(100, (currentXP / targetXP) * 100);

      // Level progress within current level
      const nextLevelXP = currentLevel < 200 ? BUMPKIN_XP_TABLE[currentLevel] : maxXP;
      const prevLevelXP = BUMPKIN_XP_TABLE[currentLevel - 1];
      const levelProgress = currentLevel >= 200 ? 100 :
        Math.round(((currentXP - prevLevelXP) / (nextLevelXP - prevLevelXP)) * 100);

      // Detect owned cooking buildings
      const ownedBuildings = {};
      for (const name of COOKING_BUILDING_NAMES) {
        const count = (buildings?.[name] || []).length;
        if (count > 0) ownedBuildings[name] = count;
      }

      // Detect cooking boosts
      const boosts = detectCookingBoosts(farm);
      const savedRecipes = getSavedBumpkinRecipes();

      // Calculate XP banked in food inventory
      const inventory = data.inventory || {};
      const foodInInventory = [];
      let bankedXP = 0;
      for (const [foodName, recipe] of Object.entries(COOKING_RECIPES_DATA)) {
        const qty = getCount(inventory, foodName);
        if (qty > 0) {
          const xpEach = computeFoodXP(foodName, recipe, recipe.building, boosts);
          const totalFoodXP = xpEach * qty;
          bankedXP += totalFoodXP;
          foodInInventory.push({ name: foodName, qty, xpEach, totalFoodXP });
        }
      }
      foodInInventory.sort((a, b) => b.totalFoodXP - a.totalFoodXP);
      const xpAfterFood = Math.max(0, xpRemaining - bankedXP);

      let html = "";

      // Header
      html += `<div class="header pixel-panel pixel-font">
        <h1>BUMPKIN XP CALCULATOR</h1>
        <div class="farm-id">Farm #${escHTML(FARM_ID)}</div>
      </div>`;

      // Level section
      html += `<div class="bumpkin-xp-section pixel-panel pixel-font">
        <div class="bumpkin-level-big">LVL ${currentLevel}</div>
        <div class="bumpkin-xp-info">
          ${Math.floor(currentXP).toLocaleString()} XP${xpRemaining > 0 ? ` ‚Äî ${Math.ceil(xpRemaining).toLocaleString()} XP to level ${targetLevel}` : " ‚Äî MAX LEVEL!"}
        </div>
        <div style="display:flex;align-items:center;gap:8px;margin:8px 0 4px">
          <span style="font-size:9px;color:var(--text-dim);white-space:nowrap">Target LVL</span>
          <input type="range" min="${currentLevel + 1}" max="200" value="${targetLevel}" oninput="document.getElementById('target-val').textContent=this.value" onchange="setBumpkinTargetLevel(this.value)" style="flex:1;accent-color:var(--sunpetal);cursor:pointer">
          <span id="target-val" style="font-size:11px;color:var(--sunpetal);min-width:24px;text-align:right">${targetLevel}</span>
        </div>
        <div class="progress-bar-outer"><div class="progress-bar-fill green" style="width:${xpPctTarget.toFixed(2)}%"></div></div>
        <div style="font-size:9px;color:var(--text-dim);margin-top:2px">${xpPctTarget.toFixed(1)}% to level ${targetLevel}</div>
        ${currentLevel < 200 ? `<div style="margin-top:6px;font-size:9px;color:var(--text-dim)">Level ${currentLevel} ‚Üí ${currentLevel + 1}: ${levelProgress}%</div>` : ""}
      </div>`;

      // Food in inventory
      if (bankedXP > 0) {
        const fmtXP = (v) => v % 1 === 0 ? v.toLocaleString() : v.toLocaleString(undefined, { maximumFractionDigits: 0 });
        html += `<div class="bumpkin-boosts pixel-panel pixel-font" style="display:block">
          <h4 style="color:var(--sunpetal);margin-bottom:6px;padding-bottom:4px;border-bottom:2px solid rgba(92,58,30,0.4);font-size:10px;cursor:pointer" onclick="toggleFoodInventory()">
            <span id="food-inv-arrow">‚ñ∂</span> FOOD IN INVENTORY ‚Äî ${fmtXP(bankedXP)} XP (${foodInInventory.length} items)
          </h4>
          <div id="food-inv-list" style="display:none">
            <div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(200px,1fr));gap:2px 16px">
              ${foodInInventory.map(f => `<div class="boost-row"><span>${f.qty}√ó ${escHTML(f.name)}</span><span class="boost-val" style="color:var(--green)">${fmtXP(f.totalFoodXP)} XP</span></div>`).join("")}
            </div>
          </div>
          ${xpAfterFood > 0 ? `<div style="margin-top:6px;padding-top:4px;border-top:2px solid rgba(92,58,30,0.4);color:var(--text-secondary)">After eating: <span style="color:var(--yellow)">${fmtXP(xpAfterFood)}</span> XP still needed</div>` : `<div style="margin-top:6px;padding-top:4px;border-top:2px solid rgba(92,58,30,0.4);color:var(--green)">Eating all food would reach level ${targetLevel}!</div>`}
        </div>`;
      }

      // Boosts section ‚Äî always show both columns
      {
        const ps = boosts.petStreakInfo;
        const xpLabel = (b) => {
          let tag = "";
          if (b.buildings) tag = ` (${b.buildings.join(", ")})`;
          if (b.honeyOnly) tag = " (honey)";
          return tag;
        };
        // Pet streak section
        let petStreakHTML = `<div style="margin-top:8px;padding-top:8px;border-top:1px solid rgba(92,58,30,0.3)">`;
        // This week status
        if (ps.thisWeekActive) {
          petStreakHTML += `<div class="boost-row"><span>Pet's Streak (${ps.streak}w)</span><span class="boost-val" style="color:var(--green)">√ó${ps.multiplier}</span></div>`;
        } else {
          petStreakHTML += `<div class="boost-row" style="color:var(--text-dim)"><span>Pet's Streak (${ps.streak}w) ‚Äî inactive</span><span class="boost-val">√ó${ps.multiplier}</span></div>`;
        }
        // Next week status
        if (!ps.nextWeekQualified) {
          petStreakHTML += `<div style="font-size:9px;color:#c0392b;margin:2px 0">Feed pet to qualify for next week!</div>`;
        } else {
          petStreakHTML += `<div style="font-size:9px;color:var(--green);margin:2px 0">Qualified for next week</div>`;
        }
        if (ps.weeksToMax > 0) {
          petStreakHTML += `<div style="font-size:9px;color:var(--text-dim)">${ps.weeksToMax}w to max √ó1.5</div>`;
        }
        petStreakHTML += `<div class="boost-row" style="margin-top:4px">
          <label style="display:flex;align-items:center;gap:6px;cursor:pointer;color:${ps.manualOverride ? "var(--green)" : "var(--text-dim)"}">
            <input type="checkbox" ${ps.manualOverride ? "checked" : ""} onchange="togglePetStreak()" style="cursor:pointer;accent-color:var(--green)">
            Simulate √ó1.5
          </label>
          <span class="boost-val" style="color:${ps.manualOverride ? "var(--green)" : "var(--text-dim)"}">√ó1.5</span>
        </div></div>`;

        html += `<div class="bumpkin-boosts pixel-panel pixel-font">
          <div class="bumpkin-boosts-col">
            <h4 style="color:var(--green)">XP BOOSTS</h4>
            ${boosts.xpBoosts.filter(b => !b.petStreak).map(b => `<div class="boost-row"><span>${escHTML(b.name)}${xpLabel(b)}</span><span class="boost-val">√ó${b.multiplier}</span></div>`).join("") || '<div style="color:var(--text-dim)">None detected</div>'}
            ${petStreakHTML}
          </div>
          <div class="bumpkin-boosts-col">
            <h4 style="color:var(--blue)">TIME BOOSTS</h4>
            ${boosts.timeBoosts.length > 0 ? boosts.timeBoosts.map(b => `<div class="boost-row"><span>${escHTML(b.name)}${b.buildings ? " (" + b.buildings.join(", ") + ")" : ""}</span><span class="boost-val">√ó${b.multiplier}</span></div>`).join("") : '<div style="color:var(--text-dim)">None detected</div>'}
          </div>
        </div>`;
      }

      // Building cards
      const buildingEntries = Object.entries(ownedBuildings);
      if (buildingEntries.length === 0) {
        html += `<div class="bumpkin-summary pixel-panel pixel-font">
          <div style="font-size:11px;color:var(--text-dim)">No cooking buildings detected.</div>
        </div>`;
      } else {
        html += `<div class="bumpkin-buildings-grid">`;

        let totalXPPerDay = 0;
        const buildingStats = [];

        for (const [buildingName, count] of buildingEntries) {
          const recipes = Object.entries(COOKING_RECIPES_DATA)
            .filter(([, r]) => r.building === buildingName && r.cookSec > 0)
            .map(([name, r]) => {
              const xp = computeFoodXP(name, r, buildingName, boosts);
              const time = computeCookTime(r.cookSec, buildingName, boosts);
              const xpPerHour = time > 0 ? (xp / time) * 3600 : 0;
              return { name, xp, time, xpPerHour };
            })
            .sort((a, b) => b.xpPerHour - a.xpPerHour);

          const selectedName = savedRecipes[buildingName] !== undefined ? savedRecipes[buildingName] : (BUMPKIN_DEFAULT_RECIPES[buildingName] || "");
          const selected = selectedName ? recipes.find(r => r.name === selectedName) : null;

          let xpPerDay = 0, cooksPerDay = 0, daysNeeded = Infinity;

          if (selected && selected.time > 0) {
            cooksPerDay = (86400 / selected.time) * count;
            xpPerDay = selected.xp * cooksPerDay;
            totalXPPerDay += xpPerDay;
            daysNeeded = xpAfterFood > 0 ? Math.ceil(xpAfterFood / xpPerDay) : 0;
          }

          buildingStats.push({ buildingName, xpPerDay, count });

          const emoji = COOKING_BUILDING_EMOJI[buildingName] || "üè†";
          const fmtXP = (v) => v % 1 === 0 ? v.toLocaleString() : v.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });

          html += `<div class="bumpkin-building-card pixel-panel">
            <div class="bumpkin-building-header pixel-font">
              <span style="font-size:20px">${emoji}</span>
              <span class="bumpkin-building-name">${escHTML(buildingName)}</span>
              ${count > 1 ? `<span class="bumpkin-building-count">√ó${count}</span>` : ""}
            </div>
            <select class="bumpkin-recipe-select" onchange="selectBumpkinRecipe('${escHTML(buildingName)}', this.value)">
              <option value="" ${!selectedName ? "selected" : ""}>-- None --</option>
              ${recipes.map(r => `<option value="${escHTML(r.name)}" ${r.name === selectedName ? "selected" : ""}>${escHTML(r.name)} (${Math.round(r.xpPerHour).toLocaleString()} XP/h)</option>`).join("")}
            </select>
            ${selected ? `<div class="bumpkin-recipe-stats">
              XP per cook: <span style="color:var(--green)">${fmtXP(selected.xp)}</span><br>
              Cook time: <span style="color:var(--blue)">${formatCookTime(selected.time)}</span><br>
              XP/hour: <span style="color:var(--sunpetal)">${fmtXP(selected.xpPerHour)}</span><br>
              XP/day${count > 1 ? " (√ó" + count + ")" : ""}: <span style="color:var(--green)">${fmtXP(xpPerDay)}</span><br>
              ${xpRemaining > 0 ? `Solo days to ${targetLevel}: <span style="color:var(--text-dim)">${daysNeeded.toLocaleString()}d</span>` : ""}
            </div>` : `<div style="font-size:10px;color:var(--text-dim)">${recipes.length > 0 ? "Not cooking" : "No recipes available"}</div>`}
          </div>`;
        }

        html += `</div>`;

        // Summary
        const totalDays = totalXPPerDay > 0 && xpAfterFood > 0 ? Math.ceil(xpAfterFood / totalXPPerDay) : 0;

        html += `<div class="bumpkin-summary pixel-panel pixel-font">
          <div style="font-size:11px;color:var(--text-secondary);margin-bottom:4px">ALL BUILDINGS COMBINED</div>
          <div style="font-size:13px;color:var(--sunpetal);margin-bottom:8px">${Math.round(totalXPPerDay).toLocaleString()} XP / day</div>
          ${xpAfterFood > 0 ? `
            <div class="bumpkin-days-big">${totalDays.toLocaleString()} days</div>
            <div style="font-size:10px;color:var(--text-dim)">to reach level ${targetLevel}${bankedXP > 0 ? " (after eating food)" : ""}</div>
          ` : `<div class="bumpkin-days-big" style="color:var(--green)">${currentLevel >= targetLevel ? "TARGET REACHED!" : "Food covers it!"}</div>`}
          ${buildingStats.length > 1 ? `<div style="margin-top:12px;font-size:9px;color:var(--text-dim);line-height:2">
            ${buildingStats.map(b => `${COOKING_BUILDING_EMOJI[b.buildingName] || ""} ${escHTML(b.buildingName)}${b.count > 1 ? " √ó" + b.count : ""}: ${Math.round(b.xpPerDay).toLocaleString()} XP/day`).join("<br>")}
          </div>` : ""}
        </div>`;
      }

      // Footer
      html += `<div class="footer">
        <button class="refresh-btn" onclick="refresh()">REFRESH</button>
        <div class="timestamp pixel-font">Updated: ${new Date().toLocaleTimeString("cs-CZ")}</div>
      </div>`;

      app.innerHTML = html;
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  TREASURY
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const TREASURY_CAT_COLORS = {
      resources: "#2ECC71",
      treasures: "#F1C40F",
      collectibles: "#E67E22",
      wearables: "#9B59B6",
      liquid: "#3498DB",
    };

    // Treasure sell prices in COINS (base, no boosts)
    const TREASURE_SELL_PRICES = {
      "Crab": 18, "Camel Bone": 12, "Sea Cucumber": 27, "Vase": 60,
      "Starfish": 135, "Sand": 12, "Old Bottle": 27, "Seaweed": 90,
      "Cockle Shell": 120, "Clam Shell": 450, "Iron Compass": 225,
      "Pipi": 225, "Pearl": 4500, "Wooden Compass": 157.5,
      "Hieroglyph": 300, "Coral": 1800, "Broken Pillar": 240,
      "Coprolite": 240, "Pirate Bounty": 9000,
    };

    // Betty sell prices in COINS (from game source crops.ts / fruits.ts)
    const BETTY_SELL_PRICES = {
      "Sunflower": 0.02, "Potato": 0.14, "Rhubarb": 0.24, "Pumpkin": 0.4,
      "Zucchini": 0.4, "Carrot": 0.8, "Yam": 0.8, "Cabbage": 1.5,
      "Broccoli": 1.5, "Soybean": 2.3, "Beetroot": 2.8, "Pepper": 3,
      "Cauliflower": 4.25, "Parsnip": 6.5, "Eggplant": 8, "Corn": 9,
      "Onion": 10, "Radish": 9.5, "Wheat": 7, "Turnip": 8,
      "Kale": 10, "Artichoke": 12, "Barley": 12,
      "Tomato": 2, "Lemon": 6, "Blueberry": 12, "Orange": 18,
      "Apple": 25, "Banana": 25, "Celestine": 200, "Lunara": 500,
      "Duskberry": 1000, "Grape": 240, "Rice": 320, "Olive": 400,
    };

    function computeBettyRate(p2pPrices) {
      let bestRate = 0, bestItem = "";
      for (const [name, sellCoins] of Object.entries(BETTY_SELL_PRICES)) {
        const p2p = p2pPrices[name];
        if (!p2p || p2p <= 0) continue;
        const rate = sellCoins / p2p;
        if (rate > bestRate) { bestRate = rate; bestItem = name; }
      }
      return { rate: bestRate, item: bestItem };
    }

    const SFL_ICON_URL = "https://sfl.world/img/source/SFL.png";
    const ITEM_ICON_BASE = "https://sfl.world/img/source/";

    function formatSFL(v) {
      if (v >= 1e6) return (v / 1e6).toFixed(2) + "M";
      if (v >= 1e4) return Math.round(v).toLocaleString();
      if (v >= 100) return v.toFixed(1);
      if (v >= 1) return v.toFixed(2);
      return v.toFixed(4);
    }
    function formatUSD(v) {
      return "$" + v.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
    }
    function formatBTC(v) {
      if (v >= 0.01) return "‚Çø" + v.toFixed(4);
      return "‚Çø" + v.toFixed(8);
    }

    async function fetchTreasuryData() {
      const proxyFetch = async (url) => {
        try {
          const resp = await fetch(`/api/proxy?url=${encodeURIComponent(url)}`);
          if (resp.ok) return resp.json();
        } catch {}
        const resp = await fetch(url);
        if (!resp.ok) throw new Error(`Fetch ${url} failed: ${resp.status}`);
        return resp.json();
      };

      const [nftData, priceData, exchangeData, btcData] = await Promise.all([
        proxyFetch("https://sfl.world/api/v1/nfts"),
        proxyFetch("https://sfl.world/api/v1/prices"),
        proxyFetch("https://sfl.world/api/v1.1/exchange"),
        proxyFetch("https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd"),
      ]);

      const nftCollectibles = {};
      for (const c of (nftData.collectibles || [])) {
        nftCollectibles[c.name] = c;
      }
      const nftWearables = {};
      for (const w of (nftData.wearables || [])) {
        nftWearables[w.name] = w;
      }

      const p2pPrices = priceData?.data?.p2p || {};
      const sflUsd = exchangeData?.sfl?.usd || 0;
      const btcUsd = btcData?.bitcoin?.usd || 0;

      // Coins: API rate (best tier) + Betty rate (best crop to sell)
      const coinTiers = Object.values(exchangeData?.coins || {});
      const bestCoinTier = coinTiers.reduce((best, t) => (!best || (t.coin / t.sfl) > (best.coin / best.sfl)) ? t : best, null);
      const coinsPerSFL_api = bestCoinTier ? (bestCoinTier.coin / bestCoinTier.sfl) : 320;
      const betty = computeBettyRate(p2pPrices);
      const coinsPerSFL_betty = betty.rate;

      // Gems: best-value tier with -30% pack discount applied
      const gemTiers = Object.values(exchangeData?.gems || {});
      const bestGemTier = gemTiers.reduce((best, t) => (!best || (t.gem / t.sfl) > (best.gem / best.sfl)) ? t : best, null);
      const gemsPerSFL = bestGemTier ? (bestGemTier.gem / (bestGemTier.sfl * 0.7)) : 0;

      return { nftCollectibles, nftWearables, p2pPrices, sflUsd, coinsPerSFL_api, coinsPerSFL_betty, bettyItem: betty.item, gemsPerSFL, btcUsd };
    }

    function computeFarmValue(farm, td, coinMode) {
      const { nftCollectibles, nftWearables, p2pPrices, sflUsd, coinsPerSFL_api, coinsPerSFL_betty, bettyItem, gemsPerSFL, btcUsd } = td;
      const coinsPerSFL = coinMode === "api" ? coinsPerSFL_api : coinMode === "betty" ? coinsPerSFL_betty : 0;
      const inventory = farm.inventory || {};
      const wardrobe = farm.wardrobe || {};
      const MIN_VALUE = 0.01;

      // Debug: log farm keys to help find gems path
      console.log("[Treasury] farm keys:", Object.keys(farm));
      console.log("[Treasury] farm.gems:", farm.gems, "| farm.bank:", farm.bank, "| inventory Gem:", inventory["Gem"]);

      // --- Resources: inventory items with P2P prices ---
      const resources = [];
      for (const [name, price] of Object.entries(p2pPrices)) {
        const qty = getCount(inventory, name);
        if (qty <= 0) continue;
        const total = qty * price;
        if (total < MIN_VALUE) continue;
        resources.push({ name, qty, unitPrice: price, total });
      }
      resources.sort((a, b) => b.total - a.total);

      // --- Treasures: inventory items with coin sell prices ---
      const treasures = [];
      // Detect treasure sell boosts
      let treasureBoost = 1;
      if (findCollectible(farm, "Treasure Map").length > 0) treasureBoost += 0.2;
      // Camel: check inventory (might not be placed)
      if (getCount(inventory, "Camel") > 0 || findCollectible(farm, "Camel").length > 0) treasureBoost += 0.3;

      for (const [name, baseCoins] of Object.entries(TREASURE_SELL_PRICES)) {
        const qty = getCount(inventory, name);
        if (qty <= 0) continue;
        const boostedCoins = baseCoins * treasureBoost;
        const sflValue = coinsPerSFL > 0 ? boostedCoins / coinsPerSFL : 0;
        const total = qty * sflValue;
        if (total < MIN_VALUE) continue;
        treasures.push({ name, qty, unitPrice: sflValue, unitCoins: boostedCoins, total });
      }
      treasures.sort((a, b) => b.total - a.total);

      // --- Collectibles: inventory NFT collectibles (inventory includes placed) ---
      const collectibles = [];
      const countedCollectibles = new Set();

      for (const name of Object.keys(nftCollectibles)) {
        const nft = nftCollectibles[name];
        const floor = parseFloat(nft.floor) || 0;
        if (floor <= 0) continue;

        const qty = getCount(inventory, name);
        if (qty <= 0) continue;
        const total = qty * floor;
        if (total < MIN_VALUE) continue;
        collectibles.push({ name, qty, unitPrice: floor, total });
        countedCollectibles.add(name);
      }
      collectibles.sort((a, b) => b.total - a.total);

      // --- Wearables: wardrobe matched against NFT wearables ---
      const wearables = [];
      for (const [name, qty] of Object.entries(wardrobe)) {
        if (!qty || qty <= 0) continue;
        const nft = nftWearables[name];
        if (!nft) continue;
        const price = parseFloat(nft.lastSalePrice) || parseFloat(nft.floor) || 0;
        if (price <= 0) continue;
        const total = qty * price;
        if (total < MIN_VALUE) continue;
        wearables.push({ name, qty, unitPrice: price, total });
      }
      wearables.sort((a, b) => b.total - a.total);

      // --- Liquid: SFL balance + coins + gems ---
      const sflBalance = parseFloat(farm.balance) || 0;
      const coinBalance = parseFloat(farm.coins) || 0;
      // Try multiple paths for gems
      const gemBalance = parseFloat(farm.gems) || parseFloat(farm.bank?.gems) || getCount(inventory, "Gem") || 0;
      const coinsAsSFL = coinsPerSFL > 0 ? coinBalance / coinsPerSFL : 0;
      const gemsAsSFL = gemsPerSFL > 0 ? gemBalance / gemsPerSFL : 0;
      const liquidTotal = sflBalance + coinsAsSFL + gemsAsSFL;

      const resourcesTotal = resources.reduce((s, r) => s + r.total, 0);
      const treasuresTotal = treasures.reduce((s, t) => s + t.total, 0);
      const collectiblesTotal = collectibles.reduce((s, c) => s + c.total, 0);
      const wearablesTotal = wearables.reduce((s, w) => s + w.total, 0);
      const grandTotal = resourcesTotal + treasuresTotal + collectiblesTotal + wearablesTotal + liquidTotal;

      return {
        resources, treasures, collectibles, wearables,
        liquid: { sflBalance, coinBalance, gemBalance, coinsAsSFL, gemsAsSFL, total: liquidTotal },
        treasureBoost,
        totals: {
          resources: resourcesTotal,
          treasures: treasuresTotal,
          collectibles: collectiblesTotal,
          wearables: wearablesTotal,
          liquid: liquidTotal,
          grand: grandTotal,
        },
        rates: { sflUsd, btcUsd, coinsPerSFL, coinsPerSFL_api, coinsPerSFL_betty, bettyItem },
      };
    }

    let treasuryDetailOpen = {};
    let treasuryCoinMode = localStorage.getItem("sfl_coin_mode") || "betty";
    let cachedTreasuryData = null;

    function setCoinMode(mode) {
      treasuryCoinMode = mode;
      localStorage.setItem("sfl_coin_mode", mode);
      if (cachedTreasuryData && cachedFarmData) {
        renderTreasuryWithData(cachedFarmData, cachedTreasuryData);
      }
    }

    function toggleTreasuryDetail(cat) {
      treasuryDetailOpen[cat] = !treasuryDetailOpen[cat];
      const grid = document.getElementById("treasury-detail-" + cat);
      const arrow = document.getElementById("treasury-arrow-" + cat);
      if (grid) grid.style.display = treasuryDetailOpen[cat] ? "block" : "none";
      if (arrow) arrow.textContent = treasuryDetailOpen[cat] ? "‚ñº" : "‚ñ∂";
    }

    function renderPieChart(totals) {
      const cats = [
        { key: "resources", label: "Resources", color: TREASURY_CAT_COLORS.resources },
        { key: "treasures", label: "Treasures", color: TREASURY_CAT_COLORS.treasures },
        { key: "collectibles", label: "Collectibles", color: TREASURY_CAT_COLORS.collectibles },
        { key: "wearables", label: "Wearables", color: TREASURY_CAT_COLORS.wearables },
        { key: "liquid", label: "Liquid", color: TREASURY_CAT_COLORS.liquid },
      ];
      const grand = totals.grand || 1;
      let gradParts = [];
      let cumPct = 0;
      for (const c of cats) {
        const pct = (totals[c.key] / grand) * 100;
        if (pct < 0.1) continue;
        gradParts.push(`${c.color} ${cumPct}% ${cumPct + pct}%`);
        cumPct += pct;
      }
      if (gradParts.length === 0) gradParts.push("#333 0% 100%");
      const gradient = `conic-gradient(${gradParts.join(", ")})`;

      let legendHTML = "";
      for (const c of cats) {
        const pct = ((totals[c.key] / grand) * 100).toFixed(1);
        legendHTML += `<div><span class="treasury-pie-swatch" style="background:${c.color}"></span>${c.label}: ${pct}%</div>`;
      }

      return `<div class="treasury-pie-wrap pixel-panel">
        <div class="treasury-pie" style="background:${gradient}"></div>
        <div class="treasury-pie-legend pixel-font">${legendHTML}</div>
      </div>`;
    }

    function renderTreasuryItemRows(items) {
      if (items.length === 0) return '<div style="padding:12px;text-align:center;font-size:10px;color:var(--text-dim)">No items found</div>';
      return items.map(item => {
        const imgUrl = ITEM_ICON_BASE + encodeURIComponent(item.name) + ".png";
        return `<div class="treasury-item-row">
          <img class="treasury-item-img" src="${imgUrl}" onerror="this.style.display='none'" alt="">
          <div class="treasury-item-name" title="${escHTML(item.name)}">${escHTML(item.name)}</div>
          <div class="treasury-item-qty">√ó${item.qty}</div>
          <div class="treasury-item-unit">${formatSFL(item.unitPrice)}</div>
          <div class="treasury-item-total">${formatSFL(item.total)}</div>
        </div>`;
      }).join("");
    }

    function renderCategoryCard(key, icon, label, total, grandTotal, items) {
      const pct = grandTotal > 0 ? ((total / grandTotal) * 100) : 0;
      const color = TREASURY_CAT_COLORS[key];
      const top5 = items.slice(0, 5);
      let topHTML = "";
      for (const item of top5) {
        const imgUrl = ITEM_ICON_BASE + encodeURIComponent(item.name) + ".png";
        topHTML += `<div class="treasury-cat-top-item">
          <img src="${imgUrl}" onerror="this.style.display='none'" alt="" style="width:16px;height:16px;image-rendering:pixelated">
          <span style="flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap">${escHTML(item.name)}</span>
          <span style="color:var(--sunpetal)">${formatSFL(item.total)}</span>
        </div>`;
      }
      return `<div class="treasury-cat-card pixel-panel" onclick="toggleTreasuryDetail('${key}')">
        <div class="treasury-cat-header">
          <span class="treasury-cat-icon">${icon}</span>
          <span class="treasury-cat-name pixel-font">${label}</span>
        </div>
        <div class="treasury-cat-value pixel-font">${formatSFL(total)} SFL</div>
        <div class="treasury-cat-pct pixel-font">${pct.toFixed(1)}%</div>
        <div class="treasury-cat-bar"><div class="treasury-cat-bar-fill" style="width:${pct.toFixed(1)}%;background:${color}"></div></div>
        <div class="treasury-cat-top">${topHTML}</div>
      </div>`;
    }

    function renderTreasuryWithData(data, td) {
      const app = document.getElementById("app");
      const farm = data.farm;
      const val = computeFarmValue(farm, td, treasuryCoinMode);
      const { totals, rates, resources, treasures, collectibles, wearables, liquid, treasureBoost } = val;

      const usdTotal = totals.grand * rates.sflUsd;
      const btcTotal = rates.btcUsd > 0 ? usdTotal / rates.btcUsd : 0;

      const coinModeLabel = treasuryCoinMode === "betty"
        ? `Betty (${escHTML(rates.bettyItem)}: ${Math.round(rates.coinsPerSFL_betty)}/SFL)`
        : treasuryCoinMode === "api"
          ? `Exchange API (${Math.round(rates.coinsPerSFL_api)}/SFL)`
          : "0 (no value)";

      let html = `<div class="bumpkin-dev-banner pixel-panel pixel-font">‚ö† UNDER DEVELOPMENT ‚Äî might show incorrect data</div>
      <div class="treasury-header pixel-panel pixel-font">
        <h1>TREASURY</h1>
        <div class="farm-id">Farm #${escHTML(FARM_ID)}</div>
        <div class="treasury-total">
          <img src="${SFL_ICON_URL}" onerror="this.style.display='none'" alt="SFL">
          ${formatSFL(totals.grand)} SFL
        </div>
        <div class="treasury-secondary">${formatUSD(usdTotal)} &nbsp;|&nbsp; ${formatBTC(btcTotal)}</div>
        <div class="treasury-rates">1 SFL = ${rates.sflUsd.toFixed(4)} USD &nbsp;|&nbsp; 1 BTC = ${formatUSD(rates.btcUsd)}</div>
        <div style="margin-top:8px;font-size:9px">
          <span style="color:var(--text-dim)">Coin rate:</span>
          <select onchange="setCoinMode(this.value)" style="font-family:'Courier New',monospace;font-size:9px;background:#111;color:var(--text-primary);border:2px solid var(--border-brown);padding:2px 4px">
            <option value="betty" ${treasuryCoinMode === "betty" ? "selected" : ""}>Betty (${escHTML(rates.bettyItem)} ${Math.round(rates.coinsPerSFL_betty)}/SFL)</option>
            <option value="api" ${treasuryCoinMode === "api" ? "selected" : ""}>Exchange API (${Math.round(rates.coinsPerSFL_api)}/SFL)</option>
            <option value="zero" ${treasuryCoinMode === "zero" ? "selected" : ""}>0 (no real value)</option>
          </select>
        </div>
      </div>`;

      // Pie chart
      html += renderPieChart(totals);

      // Category cards
      html += '<div class="treasury-categories">';
      html += renderCategoryCard("resources", "‚õèÔ∏è", "RESOURCES", totals.resources, totals.grand, resources);
      html += renderCategoryCard("treasures", "üè¥‚Äç‚ò†Ô∏è", "TREASURES", totals.treasures, totals.grand, treasures);
      html += renderCategoryCard("collectibles", "üèÜ", "COLLECTIBLES", totals.collectibles, totals.grand, collectibles);
      html += renderCategoryCard("wearables", "üëï", "WEARABLES", totals.wearables, totals.grand, wearables);

      // Liquid card
      const liqPct = totals.grand > 0 ? ((totals.liquid / totals.grand) * 100) : 0;
      html += `<div class="treasury-cat-card pixel-panel">
        <div class="treasury-cat-header">
          <span class="treasury-cat-icon">üíß</span>
          <span class="treasury-cat-name pixel-font">LIQUID</span>
        </div>
        <div class="treasury-cat-value pixel-font">${formatSFL(totals.liquid)} SFL</div>
        <div class="treasury-cat-pct pixel-font">${liqPct.toFixed(1)}%</div>
        <div class="treasury-cat-bar"><div class="treasury-cat-bar-fill" style="width:${liqPct.toFixed(1)}%;background:${TREASURY_CAT_COLORS.liquid}"></div></div>
        <div class="treasury-cat-top" style="line-height:2.2">
          <div>SFL Balance: <span style="color:var(--sunpetal)">${formatSFL(liquid.sflBalance)}</span></div>
          <div>Coins: <span style="color:var(--text-secondary)">${Math.floor(liquid.coinBalance).toLocaleString()}</span> <span style="color:var(--text-dim)">(‚âà ${formatSFL(liquid.coinsAsSFL)} SFL)</span></div>
          <div>Gems: <span style="color:var(--text-secondary)">${Math.floor(liquid.gemBalance).toLocaleString()}</span> <span style="color:var(--text-dim)">(‚âà ${formatSFL(liquid.gemsAsSFL)} SFL)</span></div>
        </div>
      </div>`;
      html += '</div>';

      // Detail sections
      const boostLabel = treasureBoost > 1 ? ` (√ó${treasureBoost.toFixed(1)} boost)` : "";
      const sections = [
        { key: "resources", icon: "‚õèÔ∏è", label: "Resources", items: resources },
        { key: "treasures", icon: "üè¥‚Äç‚ò†Ô∏è", label: `Treasures${boostLabel}`, items: treasures },
        { key: "collectibles", icon: "üèÜ", label: "Collectibles", items: collectibles },
        { key: "wearables", icon: "üëï", label: "Wearables", items: wearables },
      ];
      for (const sec of sections) {
        const isOpen = treasuryDetailOpen[sec.key];
        html += `<div class="treasury-detail-section">
          <div class="treasury-detail-header pixel-panel pixel-font" onclick="toggleTreasuryDetail('${sec.key}')">
            <span>${sec.icon}</span>
            <h3>${sec.label} (${sec.items.length})</h3>
            <span class="treasury-detail-arrow" id="treasury-arrow-${sec.key}">${isOpen ? "‚ñº" : "‚ñ∂"}</span>
          </div>
          <div class="treasury-detail-grid" id="treasury-detail-${sec.key}" style="display:${isOpen ? "block" : "none"}">
            ${renderTreasuryItemRows(sec.items)}
          </div>
        </div>`;
      }

      app.innerHTML = html;
    }

    async function renderTreasury(data) {
      const app = document.getElementById("app");

      app.innerHTML = `<div class="bumpkin-dev-banner pixel-panel pixel-font">‚ö† UNDER DEVELOPMENT ‚Äî might show incorrect data</div>
      <div class="header pixel-panel pixel-font">
        <h1>TREASURY</h1>
        <div class="farm-id">Farm #${escHTML(FARM_ID)}</div>
      </div>
      <div class="loading-screen pixel-font" style="min-height:30vh">
        <div class="loading-flower">üí∞</div>
        <div class="loading-text">Fetching market data...</div>
      </div>`;

      try {
        cachedTreasuryData = await fetchTreasuryData();
        renderTreasuryWithData(data, cachedTreasuryData);
      } catch (err) {
        console.error("Treasury error:", err);
        app.innerHTML = `<div class="header pixel-panel pixel-font">
          <h1>TREASURY</h1>
          <div class="farm-id">Farm #${escHTML(FARM_ID)}</div>
        </div>
        <div class="error-screen pixel-panel pixel-font">
          <div class="icon">‚ö†Ô∏è</div>
          <h2>Failed to load market data</h2>
          <p>${escHTML(err.message)}</p>
          <button class="refresh-btn" onclick="refresh()">RETRY</button>
        </div>`;
      }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  RENDER: SALES
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    async function fetchMarketPrices() {
      const proxyFetch = async (url) => {
        try {
          const resp = await fetch(`/api/proxy?url=${encodeURIComponent(url)}`);
          if (resp.ok) return resp.json();
        } catch {}
        const resp = await fetch(url);
        if (!resp.ok) throw new Error(`Fetch failed: ${resp.status}`);
        return resp.json();
      };

      const [nftData, priceData] = await Promise.all([
        proxyFetch("https://sfl.world/api/v1/nfts"),
        proxyFetch("https://sfl.world/api/v1/prices"),
      ]);

      const nfts = {};
      for (const c of (nftData.collectibles || [])) {
        if (c.name) nfts[c.name] = { floor: parseFloat(c.floor) || 0, lastSale: parseFloat(c.lastSalePrice) || 0, type: "collectible" };
      }
      for (const w of (nftData.wearables || [])) {
        if (w.name) nfts[w.name] = { floor: parseFloat(w.floor) || 0, lastSale: parseFloat(w.lastSalePrice) || 0, type: "wearable" };
      }

      const p2p = priceData?.data?.p2p || {};
      return { nfts, p2p };
    }

    function formatAge(ms) {
      const h = Math.floor(ms / 3600000);
      if (h < 24) return `${h}h`;
      const d = Math.floor(h / 24);
      if (d < 7) return `${d}d`;
      const w = Math.floor(d / 7);
      return `${w}w`;
    }

    async function renderSales(data) {
      const app = document.getElementById("app");
      const { trades } = data;
      const listings = trades.listings || {};
      const offers = trades.offers || {};

      let html = `<div class="header pixel-panel pixel-font">
        <h1>SALES TRACKER</h1>
        <div class="farm-id">Farm #${escHTML(FARM_ID)}</div>
      </div>`;

      html += `<div class="under-dev-banner pixel-font" style="background:linear-gradient(180deg,#3b1768,#2a1050);padding:8px 12px;border:3px solid #000;margin-bottom:16px;text-align:center;font-size:9px;color:var(--lily)">
        ‚ö†Ô∏è UNDER DEVELOPMENT ‚ö†Ô∏è
      </div>`;

      // Show loading while fetching market data
      html += `<div id="sales-content"><div class="loading-screen pixel-font" style="padding:20px"><div class="loading-text">Loading market prices...</div></div></div>`;
      app.innerHTML = html;

      // Fetch market data
      let market;
      try {
        market = await fetchMarketPrices();
      } catch (err) {
        document.getElementById("sales-content").innerHTML = `<div class="error-screen pixel-panel pixel-font"><p>Failed to load prices: ${escHTML(err.message)}</p></div>`;
        return;
      }

      const now = Date.now();

      // Process listings
      const activeListings = [];
      const soldListings = [];

      for (const [id, listing] of Object.entries(listings)) {
        const items = Object.entries(listing.items || {});
        if (items.length === 0) continue;
        const [itemName, qty] = items[0];
        const priceSFL = listing.sfl || 0;
        const unitPrice = qty > 0 ? priceSFL / qty : priceSFL;
        const createdAt = toMs(listing.createdAt || 0);
        const age = now - createdAt;
        const collection = listing.collection || "unknown";

        // Get market price
        let marketPrice = 0;
        let priceSource = "";
        if (market.p2p[itemName]) {
          marketPrice = market.p2p[itemName];
          priceSource = "P2P";
        } else if (market.nfts[itemName]) {
          marketPrice = market.nfts[itemName].floor;
          priceSource = "Floor";
        }

        const delta = marketPrice > 0 ? ((unitPrice - marketPrice) / marketPrice) * 100 : 0;

        const entry = {
          id, itemName, qty, priceSFL, unitPrice, createdAt, age,
          marketPrice, priceSource, delta, collection,
          tradeType: listing.tradeType || "onchain",
        };

        if (listing.fulfilledAt || listing.boughtAt) {
          entry.soldAt = toMs(listing.fulfilledAt || listing.boughtAt);
          soldListings.push(entry);
        } else {
          activeListings.push(entry);
        }
      }

      // Process offers (buy orders)
      const activeOffers = [];
      for (const [id, offer] of Object.entries(offers)) {
        const items = Object.entries(offer.items || {});
        if (items.length === 0) continue;
        const [itemName, qty] = items[0];
        const priceSFL = offer.sfl || 0;
        const unitPrice = qty > 0 ? priceSFL / qty : priceSFL;
        const createdAt = toMs(offer.createdAt || 0);
        const age = now - createdAt;

        let marketPrice = 0;
        let priceSource = "";
        if (market.p2p[itemName]) {
          marketPrice = market.p2p[itemName];
          priceSource = "P2P";
        } else if (market.nfts[itemName]) {
          marketPrice = market.nfts[itemName].floor;
          priceSource = "Floor";
        }

        const delta = marketPrice > 0 ? ((unitPrice - marketPrice) / marketPrice) * 100 : 0;

        if (!offer.fulfilledAt) {
          activeOffers.push({
            id, itemName, qty, priceSFL, unitPrice, createdAt, age,
            marketPrice, priceSource, delta, collection: offer.collection || "unknown",
          });
        }
      }

      // Sort: most overpriced first (for listings), cheapest first (for offers)
      activeListings.sort((a, b) => b.delta - a.delta);
      activeOffers.sort((a, b) => a.delta - b.delta);
      soldListings.sort((a, b) => (b.soldAt || 0) - (a.soldAt || 0));

      // Summary stats
      const totalListedSFL = activeListings.reduce((s, l) => s + l.priceSFL, 0);
      const totalOfferSFL = activeOffers.reduce((s, o) => s + o.priceSFL, 0);
      const overpricedCount = activeListings.filter(l => l.delta > 20).length;
      const staleCount = activeListings.filter(l => l.age > 7 * 24 * 3600000).length;

      let content = "";

      // Summary
      content += `<div class="sales-summary-grid pixel-font">
        <div class="sales-stat"><div class="sales-stat-label">ACTIVE LISTINGS</div><div class="sales-stat-value">${activeListings.length}</div></div>
        <div class="sales-stat"><div class="sales-stat-label">TOTAL LISTED</div><div class="sales-stat-value">${totalListedSFL.toFixed(1)} SFL</div></div>
        <div class="sales-stat"><div class="sales-stat-label">OVERPRICED</div><div class="sales-stat-value" style="color:${overpricedCount > 0 ? 'var(--red)' : 'var(--green)'}">${overpricedCount}</div></div>
        <div class="sales-stat"><div class="sales-stat-label">STALE (>7d)</div><div class="sales-stat-value" style="color:${staleCount > 0 ? 'var(--yellow)' : 'var(--green)'}">${staleCount}</div></div>
        <div class="sales-stat"><div class="sales-stat-label">ACTIVE OFFERS</div><div class="sales-stat-value">${activeOffers.length}</div></div>
        <div class="sales-stat"><div class="sales-stat-label">TOTAL OFFERED</div><div class="sales-stat-value">${totalOfferSFL.toFixed(1)} SFL</div></div>
        ${trades.tradePoints ? `<div class="sales-stat"><div class="sales-stat-label">TRADE POINTS</div><div class="sales-stat-value">${trades.tradePoints}</div></div>` : ""}
      </div>`;

      // Render listing rows helper
      const renderListingRow = (l, isSell) => {
        const imgUrl = ITEM_ICON_BASE + encodeURIComponent(l.itemName) + ".png";
        const badges = [];
        if (isSell && l.delta > 20) badges.push(`<span class="sales-badge overpriced">+${Math.round(l.delta)}%</span>`);
        else if (isSell && l.delta < -10) badges.push(`<span class="sales-badge good">${Math.round(l.delta)}%</span>`);
        if (l.age > 7 * 24 * 3600000) badges.push(`<span class="sales-badge stale">STALE</span>`);
        if (l.soldAt) badges.push(`<span class="sales-badge sold">SOLD</span>`);

        return `<div class="sales-listing">
          <img class="sales-listing-img" src="${imgUrl}" onerror="this.style.display='none'" alt="">
          <div class="sales-listing-info">
            <div class="sales-listing-name">${escHTML(l.itemName)}${l.qty > 1 ? ` x${l.qty}` : ""} ${badges.join("")}</div>
            <div class="sales-listing-detail">${formatAge(l.age)} ago ¬∑ ${l.tradeType || l.collection}${l.marketPrice > 0 ? ` ¬∑ market: ${l.marketPrice.toFixed(3)} SFL/${l.priceSource}` : ""}</div>
          </div>
          <div class="sales-listing-prices">
            <div class="sales-price-yours">${l.priceSFL.toFixed(2)} SFL</div>
            ${l.marketPrice > 0 && l.qty > 0 ? `<div class="sales-price-market">${l.unitPrice.toFixed(3)}/ea vs ${l.marketPrice.toFixed(3)}</div>` : ""}
          </div>
        </div>`;
      };

      // Active Listings section
      content += `<div style="margin-bottom:16px">
        <div class="sales-section-header pixel-font" onclick="this.nextElementSibling.style.display=this.nextElementSibling.style.display==='none'?'block':'none'">
          <h3>üì§ ACTIVE LISTINGS</h3>
          <span class="sales-section-count">${activeListings.length} items</span>
        </div>
        <div class="sales-section-body">`;
      if (activeListings.length === 0) {
        content += `<div style="padding:16px;text-align:center;font-size:10px;color:var(--text-dim)">No active listings</div>`;
      } else {
        for (const l of activeListings) content += renderListingRow(l, true);
      }
      content += `</div></div>`;

      // Active Offers section
      if (activeOffers.length > 0) {
        content += `<div style="margin-bottom:16px">
          <div class="sales-section-header pixel-font" onclick="this.nextElementSibling.style.display=this.nextElementSibling.style.display==='none'?'block':'none'">
            <h3>üì• ACTIVE OFFERS</h3>
            <span class="sales-section-count">${activeOffers.length} items</span>
          </div>
          <div class="sales-section-body">`;
        for (const o of activeOffers) content += renderListingRow(o, false);
        content += `</div></div>`;
      }

      // Sold / Fulfilled section
      if (soldListings.length > 0) {
        content += `<div style="margin-bottom:16px">
          <div class="sales-section-header pixel-font" onclick="this.nextElementSibling.style.display=this.nextElementSibling.style.display==='none'?'block':'none'">
            <h3>‚úÖ SOLD</h3>
            <span class="sales-section-count">${soldListings.length} items</span>
          </div>
          <div class="sales-section-body" style="display:none">`;
        for (const l of soldListings) content += renderListingRow(l, true);
        content += `</div></div>`;
      }

      // Weekly stats
      const weeklySales = trades.weeklySales || {};
      const weeklyPurchases = trades.weeklyPurchases || {};
      const weekKeys = [...new Set([...Object.keys(weeklySales), ...Object.keys(weeklyPurchases)])].sort().reverse();

      if (weekKeys.length > 0) {
        content += `<div style="margin-bottom:16px">
          <div class="sales-section-header pixel-font" onclick="this.nextElementSibling.style.display=this.nextElementSibling.style.display==='none'?'block':'none'">
            <h3>üìä WEEKLY HISTORY</h3>
            <span class="sales-section-count">${weekKeys.length} weeks</span>
          </div>
          <div class="sales-section-body" style="display:none;padding:10px 14px">`;

        for (const week of weekKeys.slice(0, 8)) {
          const sales = weeklySales[week] || {};
          const purchases = weeklyPurchases[week] || {};
          const saleItems = Object.entries(sales).map(([n, q]) => `${n} x${q}`).join(", ");
          const purchItems = Object.entries(purchases).map(([n, q]) => `${n} x${q}`).join(", ");
          const weekDate = new Date(parseInt(week)).toLocaleDateString("en-GB");

          content += `<div style="margin-bottom:8px;padding-bottom:8px;border-bottom:1px solid rgba(92,58,30,0.2)">
            <div style="font-size:10px;color:var(--text-secondary);margin-bottom:3px">${weekDate}</div>
            ${saleItems ? `<div style="font-size:9px;color:var(--green)">Sold: ${escHTML(saleItems)}</div>` : ""}
            ${purchItems ? `<div style="font-size:9px;color:var(--blue)">Bought: ${escHTML(purchItems)}</div>` : ""}
            ${!saleItems && !purchItems ? `<div style="font-size:9px;color:var(--text-dim)">No activity</div>` : ""}
          </div>`;
        }

        content += `</div></div>`;
      }

      // Debug: log raw trade data
      console.log("[Sales] trades:", trades);
      console.log("[Sales] listings:", Object.keys(listings).length, "offers:", Object.keys(offers).length);

      content += `<div class="footer">
        <button class="refresh-btn" onclick="refresh()">REFRESH</button>
        <div class="timestamp pixel-font">Updated: ${new Date().toLocaleTimeString("cs-CZ")}</div>
      </div>`;

      document.getElementById("sales-content").innerHTML = content;
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  POWER ANALYZER: PARSER & CALC ENGINE
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function parseBoostEffects(boostText) {
      if (!boostText) return [];
      const effects = [];
      const lines = boostText.split("\n").map(l => l.trim()).filter(Boolean);
      for (const line of lines) {
        let matched = false;
        for (const rule of BOOST_PARSE_RULES) {
          const m = line.match(rule.rx);
          if (m) {
            const eff = rule.fn(m);
            if (eff) {
              eff.raw = line;
              effects.push(eff);
              // If alsoApply, duplicate for other categories
              if (eff.alsoApply) {
                for (const extraCat of eff.alsoApply) {
                  effects.push({ ...eff, cat: extraCat, alsoApply: undefined });
                }
              }
            }
            matched = true;
            break;
          }
        }
        if (!matched) {
          effects.push({ type: "qualitative", cat: "other", raw: line });
        }
      }
      return effects;
    }

    function classifyToCategories(effects) {
      const cats = new Set();
      for (const e of effects) {
        if (e.cat) cats.add(e.cat);
      }
      if (cats.size === 0) cats.add("other");
      return [...cats];
    }

    // Sum effective base nodes accounting for merged nodes (tier/multiplier)
    function sumMergedNodes(resourceObj) {
      if (!resourceObj || typeof resourceObj !== "object") return 0;
      let total = 0;
      for (const node of Object.values(resourceObj)) {
        total += node.multiplier || 1; // unmerged nodes have no multiplier field ‚Üí count as 1
      }
      return total;
    }

    function detectFarmCapacity(farm) {
      // Count animals from henHouse and barn structures
      let chickens = 0, cows = 0, sheep = 0;

      // Hen House: farm.henHouse.animals OR farm.buildings["Hen House"][].animals
      const henAnimals = farm.henHouse?.animals;
      if (henAnimals && typeof henAnimals === "object") {
        chickens = Object.keys(henAnimals).length;
      }
      if (chickens === 0) {
        const henBuildings = farm.buildings?.["Hen House"] || [];
        for (const b of henBuildings) {
          chickens += Object.keys(b.animals || {}).length;
        }
      }

      // Barn: farm.barn.animals OR farm.buildings["Barn"][].animals
      const barnAnimals = farm.barn?.animals;
      if (barnAnimals && typeof barnAnimals === "object") {
        for (const a of Object.values(barnAnimals)) {
          const t = (a.type || "").toLowerCase();
          if (t === "cow") cows++;
          else if (t === "sheep") sheep++;
          else cows++; // default to cow if type unknown
        }
      }
      if (cows === 0 && sheep === 0) {
        const barnBuildings = farm.buildings?.["Barn"] || [];
        for (const b of barnBuildings) {
          for (const a of Object.values(b.animals || {})) {
            const t = (a.type || "").toLowerCase();
            if (t === "cow") cows++;
            else if (t === "sheep") sheep++;
            else cows++;
          }
        }
      }

      // Debug log for animal detection
      console.log("[Power] Animal detection:", { chickens, cows, sheep,
        henHouse: !!farm.henHouse, barn: !!farm.barn,
        henBuildings: (farm.buildings?.["Hen House"] || []).length,
        barnBuildings: (farm.buildings?.["Barn"] || []).length });

      return {
        crops: Object.keys(farm.crops || {}).length,
        fruitPatches: Object.keys(farm.fruitPatches || {}).length,
        chickens, cows, sheep,
        bees: Object.keys(farm.beehives || {}).length,
        flowers: Object.keys(farm.flowers?.flowerBeds || {}).length,
        stones: sumMergedNodes(farm.stones),
        iron: sumMergedNodes(farm.iron),
        gold: sumMergedNodes(farm.gold),
        crimstones: sumMergedNodes(farm.crimstones),
        trees: sumMergedNodes(farm.trees),
      };
    }

    // Get base production per day (units, not SFL) for a category + selected product
    function getBaseProductionPerDay(catId, product, capacity) {
      switch (catId) {
        case "crops": {
          const growSec = CROP_GROW_DATA[product];
          if (!growSec) return 0;
          const n = capacity.crops || 0;
          return n * (86400 / growSec) * 1; // yield=1 per harvest
        }
        case "fruits": {
          const growSec = FRUIT_GROW_DATA[product];
          if (!growSec) return 0;
          const n = capacity.fruitPatches || 0;
          return n * (86400 / growSec) * 1;
        }
        case "chickens": {
          const d = ANIMAL_CYCLE_DATA["Chicken"];
          return (capacity.chickens || 0) * (86400 / d.cycleSec) * 1;
        }
        case "cows": {
          const d = ANIMAL_CYCLE_DATA["Cow"];
          return (capacity.cows || 0) * (86400 / d.cycleSec) * 1;
        }
        case "sheep": {
          const d = ANIMAL_CYCLE_DATA["Sheep"];
          return (capacity.sheep || 0) * (86400 / d.cycleSec) * 1;
        }
        case "bees": {
          return (capacity.bees || 0) * 1; // ~1 honey/day per hive
        }
        case "stone": case "iron": case "gold": case "crimstone": {
          const rKey = catId === "stone" ? "Stone" : catId === "iron" ? "Iron" : catId === "gold" ? "Gold" : "Crimstone";
          const d = RESOURCE_RESPAWN_DATA[rKey];
          const capKey = catId === "stone" ? "stones" : catId === "crimstone" ? "crimstones" : catId;
          const n = capacity[capKey] || 0;
          return n * (86400 / d.respawnSec) * d.yield;
        }
        case "trees": {
          const d = RESOURCE_RESPAWN_DATA["Wood"];
          return (capacity.trees || 0) * (86400 / d.respawnSec) * d.yield;
        }
        case "flowers": {
          // Use generic flower grow time (Sunpetal = 86400s base)
          const n = capacity.flowers || 0;
          return n * (86400 / 86400) * 1; // 1 flower/bed/day base
        }
        case "fishing": return 20; // ~20 catches/day estimate
        default: return 0;
      }
    }

    // Get the grow/cycle seconds for a category's selected product
    function getCycleSec(catId, product) {
      switch (catId) {
        case "crops": return CROP_GROW_DATA[product] || 43200;
        case "fruits": return FRUIT_GROW_DATA[product] || 43200;
        case "chickens": return ANIMAL_CYCLE_DATA["Chicken"].cycleSec;
        case "cows": return ANIMAL_CYCLE_DATA["Cow"].cycleSec;
        case "sheep": return ANIMAL_CYCLE_DATA["Sheep"].cycleSec;
        case "bees": return 86400;
        case "stone": return RESOURCE_RESPAWN_DATA["Stone"].respawnSec;
        case "iron": return RESOURCE_RESPAWN_DATA["Iron"].respawnSec;
        case "gold": return RESOURCE_RESPAWN_DATA["Gold"].respawnSec;
        case "crimstone": return RESOURCE_RESPAWN_DATA["Crimstone"].respawnSec;
        case "trees": return RESOURCE_RESPAWN_DATA["Wood"].respawnSec;
        case "flowers": return 86400;
        default: return 86400;
      }
    }

    function getCapacityCount(catId, capacity) {
      switch (catId) {
        case "crops": return capacity.crops;
        case "fruits": return capacity.fruitPatches;
        case "chickens": return capacity.chickens;
        case "cows": return capacity.cows;
        case "sheep": return capacity.sheep;
        case "bees": return capacity.bees;
        case "flowers": return capacity.flowers;
        case "stone": return capacity.stones;
        case "iron": return capacity.iron;
        case "gold": return capacity.gold;
        case "crimstone": return capacity.crimstones;
        case "trees": return capacity.trees;
        default: return 0;
      }
    }

    function getDefaultProduct(catId) {
      switch (catId) {
        case "crops": return "Kale";
        case "fruits": return "Blueberry";
        case "chickens": return "Egg";
        case "cows": return "Milk";
        case "sheep": return "Wool";
        case "bees": return "Honey";
        case "stone": return "Stone";
        case "iron": return "Iron";
        case "gold": return "Gold";
        case "crimstone": return "Crimstone";
        case "trees": return "Wood";
        case "flowers": return "Sunpetal Seed";
        case "fishing": return "Fish";
        default: return null;
      }
    }

    function getBaseYield(catId) {
      switch (catId) {
        case "stone": return RESOURCE_RESPAWN_DATA["Stone"].yield;
        case "iron": return RESOURCE_RESPAWN_DATA["Iron"].yield;
        case "gold": return RESOURCE_RESPAWN_DATA["Gold"].yield;
        case "crimstone": return RESOURCE_RESPAWN_DATA["Crimstone"].yield;
        case "trees": return RESOURCE_RESPAWN_DATA["Wood"].yield;
        default: return 1;
      }
    }

    // Apply a set of boost effects to calculate boosted production
    // Returns { unitsPerDay, speedMult, yieldMult, yieldFlat, details }
    function applyBoosts(catId, product, capacity, boostEffects) {
      const baseCycleSec = getCycleSec(catId, product);
      const baseYield = getBaseYield(catId);
      const n = getCapacityCount(catId, capacity);
      if (n === 0 && catId !== "fishing") return { unitsPerDay: 0, speedMult: 1, yieldMult: 1, yieldFlat: 0 };

      let speedMult = 1; // multiplied to cycle time (< 1 = faster)
      let yieldMult = 1; // multiplied to output
      let yieldFlat = 0; // added per cycle per slot

      for (const eff of boostEffects) {
        // Only apply effects that match this category
        if (eff.cat !== catId) continue;
        // For product-specific boosts, check if product matches
        if (eff.product && PRODUCT_TO_CATEGORY[eff.product] === catId) {
          // Specific product boost ‚Äî only if it's a crop/fruit that doesn't match selector, skip
          if ((catId === "crops" || catId === "fruits") && eff.product !== product && eff.type !== "yield_flat" && eff.type !== "chance") {
            continue; // skip speed/yield% boosts for wrong product
          }
        }

        switch (eff.type) {
          case "speed_pct":
            speedMult *= (1 + eff.value / 100);
            break;
          case "speed_mult":
            speedMult *= eff.value;
            break;
          case "yield_pct":
            yieldMult *= (1 + eff.value / 100);
            break;
          case "yield_flat":
            yieldFlat += eff.value;
            break;
          case "chance":
            // Expected value: pct% chance of +extra per cycle
            yieldFlat += (eff.pct / 100) * eff.extra;
            break;
        }
      }

      const effectiveCycle = baseCycleSec * speedMult;
      const cyclesPerDay = catId === "fishing" ? 1 : (effectiveCycle > 0 ? 86400 / effectiveCycle : 0);
      const outputPerCycle = baseYield * yieldMult + yieldFlat;

      let unitsPerDay;
      if (catId === "fishing") {
        unitsPerDay = 20 + yieldFlat; // flat estimate for fishing
      } else if (catId === "bees") {
        unitsPerDay = n * (baseYield * yieldMult + yieldFlat); // simplified for bees
      } else {
        unitsPerDay = n * cyclesPerDay * outputPerCycle;
      }

      return { unitsPerDay, speedMult, yieldMult, yieldFlat, effectiveCycle };
    }

    // Calculate SFL/day from units/day
    function unitToSfl(unitsPerDay, product, p2pPrices) {
      const price = p2pPrices[product] || 0;
      return unitsPerDay * price;
    }

    // Format seconds to human-readable time
    function fmtSec(s) {
      if (s >= 86400) return (s / 86400).toFixed(1) + "d";
      if (s >= 3600) return (s / 3600).toFixed(1) + "h";
      if (s >= 60) return (s / 60).toFixed(0) + "m";
      return s + "s";
    }

    // Build detailed production breakdown HTML for a category
    function buildProductionBreakdown(catId, product, capacity, p2pPrices, catBoosts) {
      const n = getCapacityCount(catId, capacity);
      const priceProduct = getPriceProduct(catId, product);
      const price = p2pPrices[priceProduct] || 0;
      const baseCycleSec = getCycleSec(catId, product);
      const baseYield = getBaseYield(catId);
      const baseResult = applyBoosts(catId, product, capacity, []);
      const baseSfl = unitToSfl(baseResult.unitsPerDay, priceProduct, p2pPrices);

      // Boosted (all owned)
      const ownedEffects = catBoosts.filter(b => b.has).flatMap(b => getEffectsForCategory(b, catId));
      const boostedResult = applyBoosts(catId, product, capacity, ownedEffects);
      const boostedSfl = unitToSfl(boostedResult.unitsPerDay, priceProduct, p2pPrices);
      const delta = boostedSfl - baseSfl;

      if (n === 0 && catId !== "fishing") {
        return `<div style="padding:8px 12px;font-size:10px;color:var(--text-dim)">No capacity detected on farm.</div>`;
      }

      // Unit label
      const unitLabels = {
        crops: "plots", fruits: "patches", chickens: "chickens", cows: "cows",
        sheep: "sheep", bees: "hives", flowers: "beds", stone: "rocks",
        iron: "nodes", gold: "nodes", crimstone: "nodes", trees: "trees", fishing: "reels"
      };
      const unitLabel = unitLabels[catId] || catId;

      let h = `<div style="padding:8px 12px;font-size:9px;color:var(--text-secondary);line-height:1.8;border-bottom:1px solid var(--border-dark)">`;

      // Base calculation
      const cyclesPerDay = baseCycleSec > 0 ? 86400 / baseCycleSec : 0;
      h += `<div style="color:var(--lily);font-size:10px;margin-bottom:2px"><strong>üìä BASE PRODUCTION</strong></div>`;
      h += `<div>${n} ${unitLabel} √ó ${fmtSec(baseCycleSec)} cycle = <strong>${cyclesPerDay.toFixed(2)} cycles/day</strong></div>`;
      h += `<div>${cyclesPerDay.toFixed(2)} cycles √ó ${baseYield} yield √ó ${n} ${unitLabel} = <strong>${baseResult.unitsPerDay.toFixed(2)} ${priceProduct}/day</strong></div>`;
      h += `<div>P2P price: ${price.toFixed(6)} SFL/${priceProduct}</div>`;
      h += `<div>${baseResult.unitsPerDay.toFixed(2)} √ó ${price.toFixed(6)} = <strong style="color:var(--sunpetal)">${baseSfl.toFixed(4)} SFL/day</strong></div>`;

      // Boosted calculation
      if (ownedEffects.length > 0) {
        const bCyclesPerDay = boostedResult.effectiveCycle > 0 ? 86400 / boostedResult.effectiveCycle : 0;
        const bOutputPerCycle = baseYield * boostedResult.yieldMult + boostedResult.yieldFlat;
        h += `<div style="color:var(--lily);font-size:10px;margin-top:6px;margin-bottom:2px"><strong>‚ö° BOOSTED PRODUCTION</strong></div>`;
        h += `<div>Speed: √ó${boostedResult.speedMult.toFixed(3)} ‚Üí ${fmtSec(boostedResult.effectiveCycle)} cycle ‚Üí <strong>${bCyclesPerDay.toFixed(2)} cycles/day</strong></div>`;
        h += `<div>Yield: √ó${boostedResult.yieldMult.toFixed(3)} ${boostedResult.yieldFlat !== 0 ? `+ ${boostedResult.yieldFlat.toFixed(2)} flat` : ""} ‚Üí <strong>${bOutputPerCycle.toFixed(2)} per cycle</strong></div>`;
        h += `<div>${bCyclesPerDay.toFixed(2)} √ó ${bOutputPerCycle.toFixed(2)} √ó ${n} = <strong>${boostedResult.unitsPerDay.toFixed(2)} ${priceProduct}/day</strong></div>`;
        h += `<div>${boostedResult.unitsPerDay.toFixed(2)} √ó ${price.toFixed(6)} = <strong style="color:var(--green)">${boostedSfl.toFixed(4)} SFL/day</strong>`;
        h += ` <span style="color:var(--sunpetal)">(+${delta.toFixed(4)} | +${baseSfl > 0 ? ((delta / baseSfl) * 100).toFixed(0) : "‚àû"}%)</span></div>`;
      }

      h += `</div>`;
      return h;
    }

    // Get all effects for a specific boost item relevant to a category
    function getEffectsForCategory(boostItem, catId) {
      return boostItem.effects.filter(e => e.cat === catId);
    }

    // Calculate solo + synergy SFL/day for a boost within a category
    function calcBoostValue(boostItem, catId, product, capacity, p2pPrices, allCatBoosts, isOwned) {
      const catEffects = getEffectsForCategory(boostItem, catId);
      if (catEffects.length === 0) return { solo: 0, synergy: 0, roi: Infinity };

      const priceProduct = getPriceProduct(catId, product);
      const baseResult = applyBoosts(catId, product, capacity, []);
      const baseSfl = unitToSfl(baseResult.unitsPerDay, priceProduct, p2pPrices);

      // Solo: just this boost
      const soloResult = applyBoosts(catId, product, capacity, catEffects);
      const soloSfl = unitToSfl(soloResult.unitsPerDay, priceProduct, p2pPrices);
      const solo = soloSfl - baseSfl;

      // Synergy: all owned boosts ¬± this one
      const allEffects = [];
      const allEffectsWithout = [];
      for (const b of allCatBoosts) {
        const eff = getEffectsForCategory(b, catId);
        if (b.has) {
          allEffects.push(...eff);
          if (b.name !== boostItem.name) allEffectsWithout.push(...eff);
        } else if (b.name === boostItem.name) {
          // For missing boost: add it to "with" set
        }
      }

      let synergy;
      if (isOwned) {
        // Marginal: allOwned - allOwned\this
        const withAll = applyBoosts(catId, product, capacity, allEffects);
        const without = applyBoosts(catId, product, capacity, allEffectsWithout);
        synergy = unitToSfl(withAll.unitsPerDay, priceProduct, p2pPrices) - unitToSfl(without.unitsPerDay, priceProduct, p2pPrices);
      } else {
        // For missing: allOwned‚à™this - allOwned
        const ownedEffects = allCatBoosts.filter(b => b.has).flatMap(b => getEffectsForCategory(b, catId));
        const withThis = [...ownedEffects, ...catEffects];
        const withResult = applyBoosts(catId, product, capacity, withThis);
        const ownedResult = applyBoosts(catId, product, capacity, ownedEffects);
        synergy = unitToSfl(withResult.unitsPerDay, priceProduct, p2pPrices) - unitToSfl(ownedResult.unitsPerDay, priceProduct, p2pPrices);
      }

      const roi = (boostItem.floor > 0 && synergy > 0) ? boostItem.floor / synergy : Infinity;

      return { solo, synergy, roi };
    }

    // Get the product name used for P2P price lookup
    function getPriceProduct(catId, product) {
      // For flowers, use the seed label
      if (catId === "flowers") {
        const sd = SEED_DATA[product];
        return sd ? sd.label : "Sunpetal";
      }
      return product;
    }

    // localStorage persistence for product selections
    function getSavedPowerProducts() {
      try { return JSON.parse(localStorage.getItem("sfl_power_products") || "{}"); } catch { return {}; }
    }
    function savePowerProduct(catId, product) {
      const saved = getSavedPowerProducts();
      saved[catId] = product;
      localStorage.setItem("sfl_power_products", JSON.stringify(saved));
    }

    // Build formula HTML for expandable detail
    function buildFormulaHTML(boostItem, catId, product, capacity, p2pPrices, allCatBoosts) {
      const catEffects = getEffectsForCategory(boostItem, catId);
      const priceProduct = getPriceProduct(catId, product);
      const price = p2pPrices[priceProduct] || 0;
      const n = getCapacityCount(catId, capacity);
      const baseCycleSec = getCycleSec(catId, product);
      const baseYield = getBaseYield(catId);

      const { skillCostInfo } = powerState;

      let h = `<div class="power-formula pixel-font">`;
      // Header with type and cost
      if (boostItem.type === "Skill") {
        h += `<div style="margin-bottom:6px"><strong>${escHTML(boostItem.name)}</strong> ‚Äî Skill (${escHTML(boostItem.skillTree)}, Tier ${boostItem.skillTier}, ${boostItem.skillPoints} point${boostItem.skillPoints > 1 ? "s" : ""})`;
        if (boostItem.floor > 0) h += ` | Est. cost: ~${boostItem.floor.toFixed(0)} SFL`;
        h += `</div>`;
      } else {
        h += `<div style="margin-bottom:6px"><strong>${escHTML(boostItem.name)}</strong> ‚Äî ${escHTML(boostItem.type)}${boostItem.floor > 0 ? ` | Floor: ${boostItem.floor.toFixed(1)} SFL` : ""}</div>`;
      }
      h += `<div style="color:var(--green);margin-bottom:6px">${escHTML(boostItem.boost)}</div>`;

      // Skill cost breakdown
      if (boostItem.type === "Skill" && skillCostInfo && skillCostInfo.sflPerPoint > 0) {
        const br = skillCostInfo.bestRecipe;
        h += `<hr style="border-color:var(--border-dark);margin:4px 0">`;
        h += `<div style="margin-bottom:2px;color:var(--lily)"><strong>Skill Cost Calculation:</strong></div>`;
        h += `<div>Bumpkin Level: ${skillCostInfo.level} ‚Üí Total XP: ${(skillCostInfo.totalXP / 1e6).toFixed(1)}M</div>`;
        h += `<div>Best recipe: ${escHTML(br.name)} (base ${br.xp} XP${br.boostedXP !== br.xp ? ` ‚Üí ${br.boostedXP} XP boosted` : ""} / ${br.cost.toFixed(4)} SFL = ${br.ratio.toFixed(0)} XP/SFL)</div>`;
        if (skillCostInfo.xpBoostNames?.length) h += `<div>XP boosts applied: ${escHTML(skillCostInfo.xpBoostNames.join(", "))}</div>`;
        h += `<div>Avg cost per level: ${skillCostInfo.sflPerLevel.toFixed(1)} SFL ‚Üí <strong>1 skill point ‚âà ${skillCostInfo.sflPerPoint.toFixed(1)} SFL</strong></div>`;
        h += `<div style="color:var(--sunpetal)">This skill (${boostItem.skillPoints}pt): <strong>${boostItem.skillPoints} √ó ${skillCostInfo.sflPerPoint.toFixed(1)} = ~${boostItem.floor.toFixed(0)} SFL</strong></div>`;
      }
      h += `<hr style="border-color:var(--border-dark);margin:4px 0">`;

      if (POWER_CATEGORIES[catId]?.quantifiable && n > 0) {
        h += `<div style="margin-bottom:4px"><strong>Farm:</strong> ${n} √ó ${escHTML(product)} (${formatSec(baseCycleSec)} grow | ${price.toFixed(6)} SFL)</div>`;

        // Base production
        const baseResult = applyBoosts(catId, product, capacity, []);
        const baseSfl = unitToSfl(baseResult.unitsPerDay, priceProduct, p2pPrices);
        h += `<div style="margin-bottom:4px"><strong>Base:</strong> ${baseResult.unitsPerDay.toFixed(2)} units/day = ${baseSfl.toFixed(4)} SFL/day</div>`;

        // Solo effect
        const soloResult = applyBoosts(catId, product, capacity, catEffects);
        const soloSfl = unitToSfl(soloResult.unitsPerDay, priceProduct, p2pPrices);
        const soloDelta = soloSfl - baseSfl;
        h += `<div style="margin-bottom:4px"><strong>Solo:</strong>`;
        if (soloResult.speedMult !== 1) h += ` speed √ó${soloResult.speedMult.toFixed(2)}`;
        if (soloResult.yieldMult !== 1) h += ` yield √ó${soloResult.yieldMult.toFixed(2)}`;
        if (soloResult.yieldFlat) h += ` +${soloResult.yieldFlat.toFixed(2)}/cycle`;
        h += ` ‚Üí ${soloSfl.toFixed(4)} SFL/day (<span style="color:var(--green)">+${soloDelta.toFixed(4)}</span>)</div>`;

        // Synergy (marginal/with-all)
        const ownedEffects = allCatBoosts.filter(b => b.has).flatMap(b => getEffectsForCategory(b, catId));
        if (boostItem.has) {
          const allResult = applyBoosts(catId, product, capacity, ownedEffects);
          const withoutEffects = allCatBoosts.filter(b => b.has && b.name !== boostItem.name).flatMap(b => getEffectsForCategory(b, catId));
          const withoutResult = applyBoosts(catId, product, capacity, withoutEffects);
          const allSfl = unitToSfl(allResult.unitsPerDay, priceProduct, p2pPrices);
          const withoutSfl = unitToSfl(withoutResult.unitsPerDay, priceProduct, p2pPrices);
          const marginal = allSfl - withoutSfl;
          h += `<div style="margin-bottom:4px"><strong>Marginal (${ownedEffects.length} active effects):</strong> <span style="color:var(--green)">+${marginal.toFixed(4)} SFL/day</span></div>`;
          if (boostItem.floor > 0 && marginal > 0) {
            const roi = boostItem.floor / marginal;
            h += `<div><strong>ROI:</strong> ${boostItem.floor.toFixed(1)} / ${marginal.toFixed(4)} = <span style="color:var(--sunpetal)">${roi.toFixed(0)} days</span></div>`;
          }
        } else {
          const withThis = [...ownedEffects, ...catEffects];
          const withResult = applyBoosts(catId, product, capacity, withThis);
          const ownedResult = applyBoosts(catId, product, capacity, ownedEffects);
          const withSfl = unitToSfl(withResult.unitsPerDay, priceProduct, p2pPrices);
          const ownedSfl = unitToSfl(ownedResult.unitsPerDay, priceProduct, p2pPrices);
          const synergy = withSfl - ownedSfl;
          h += `<div style="margin-bottom:4px"><strong>Synergy (with your boosts):</strong> <span style="color:var(--green)">+${synergy.toFixed(4)} SFL/day</span></div>`;
          if (boostItem.floor > 0 && synergy > 0) {
            const roi = boostItem.floor / synergy;
            h += `<div><strong>ROI:</strong> ${boostItem.floor.toFixed(1)} / ${synergy.toFixed(4)} = <span style="color:var(--sunpetal)">${roi.toFixed(0)} days</span></div>`;
          }
        }
      } else if (n === 0 && POWER_CATEGORIES[catId]?.quantifiable) {
        h += `<div style="color:var(--text-dim)">No capacity detected for this category. Cannot calculate SFL/day.</div>`;
      } else {
        h += `<div style="color:var(--text-dim)">Qualitative boost ‚Äî cannot calculate SFL/day value.</div>`;
      }

      h += `</div>`;
      return h;
    }

    function formatSec(sec) {
      if (sec < 60) return sec + "s";
      if (sec < 3600) return (sec / 60).toFixed(0) + "m";
      if (sec < 86400) return (sec / 3600).toFixed(1) + "h";
      return (sec / 86400).toFixed(1) + "d";
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  RENDER: POWER
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    // Global state for power page
    let powerState = null;

    async function renderPower(data) {
      const app = document.getElementById("app");
      const { inventory, farm } = data;
      const wardrobe = farm.wardrobe || {};
      const skills = farm.bumpkin?.skills || {};

      let html = `<div class="header pixel-panel pixel-font">
        <h1>POWER ANALYZER</h1>
        <div class="farm-id">Farm #${escHTML(FARM_ID)}</div>
      </div>`;

      html += `<div class="under-dev-banner pixel-font" style="background:linear-gradient(180deg,#3b1768,#2a1050);padding:8px 12px;border:3px solid #000;margin-bottom:16px;text-align:center;font-size:9px;color:var(--lily)">
        ‚ö†Ô∏è UNDER DEVELOPMENT ‚ö†Ô∏è
        <div style="margin-top:6px;font-size:8px;color:var(--text-secondary);line-height:1.5">
          All NFT collectibles, wearables & bumpkin skills with production boosts.<br>
          Shows SFL/day value, synergy with your other boosts, ROI payback time, and expandable formulas.<br>
          Organized by category (Crops, Animals, Mining, etc.) with product selectors and Best Buys ranking.
        </div>
      </div>`;

      html += `<div id="power-content"><div class="loading-screen pixel-font" style="padding:20px"><div class="loading-text">Loading boost data...</div></div></div>`;
      app.innerHTML = html;

      // Fetch NFT data + P2P prices in parallel
      let nftData, p2pPrices = {};
      try {
        const proxyFetch = async (url) => {
          try {
            const resp = await fetch(`/api/proxy?url=${encodeURIComponent(url)}`);
            if (resp.ok) return resp.json();
          } catch {}
          return (await fetch(url)).json();
        };
        const [nftResp, priceResp] = await Promise.all([
          proxyFetch("https://sfl.world/api/v1/nfts"),
          proxyFetch("https://sfl.world/api/v1/prices"),
        ]);
        nftData = nftResp;
        const priceData = priceResp?.data?.p2p || priceResp?.p2p || {};
        for (const [k, v] of Object.entries(priceData)) {
          p2pPrices[k] = parseFloat(v) || 0;
        }
      } catch (err) {
        document.getElementById("power-content").innerHTML = `<div class="error-screen pixel-panel pixel-font"><p>Failed to load: ${escHTML(err.message)}</p></div>`;
        return;
      }

      // Detect farm capacity
      const capacity = detectFarmCapacity(farm);

      // Build boost items with parsed effects
      const boostItems = [];

      for (const item of (nftData.collectibles || [])) {
        if (!item.have_boost || !item.name || !item.boost_text) continue;
        const has = getCount(inventory, item.name) > 0 || findCollectible(farm, item.name).length > 0;
        const effects = parseBoostEffects(item.boost_text);
        const categories = classifyToCategories(effects);
        boostItems.push({
          name: item.name, type: "Collectible", boost: item.boost_text,
          floor: parseFloat(item.floor) || 0, supply: item.supply || 0,
          has, effects, categories,
        });
      }

      for (const item of (nftData.wearables || [])) {
        if (!item.have_boost || !item.name || !item.boost_text) continue;
        const has = (wardrobe[item.name] || 0) > 0;
        const effects = parseBoostEffects(item.boost_text);
        const categories = classifyToCategories(effects);
        boostItems.push({
          name: item.name, type: "Wearable", boost: item.boost_text,
          floor: parseFloat(item.floor) || 0, supply: item.supply || 0,
          has, effects, categories,
        });
      }

      // Add skill boosts from full skill tree
      const skillCostInfo = calcSkillPointCost(farm.bumpkin, p2pPrices, farm);
      for (const [skillName, skill] of Object.entries(SKILL_TREE_DATA)) {
        const has = skills[skillName] !== undefined;
        const boostText = skill.buff + (skill.debuff ? "\n" + skill.debuff : "");
        const effects = parseBoostEffects(boostText);
        const categories = classifyToCategories(effects);
        // Add tree-based categories ONLY for skills the parser couldn't classify (ended up as "other" only)
        const hasOnlyOther = categories.length === 1 && categories[0] === "other";
        if (hasOnlyOther) {
          const TREE_TO_CATS = {
            "Animals": ["chickens", "cows", "sheep"],
            "Crops": ["crops"],
            "Fruit Patch": ["fruits"],
            "Fishing": ["fishing"],
            "Mining": ["stone", "iron", "gold", "crimstone"],
            "Trees": ["trees"],
            "Bees & Flowers": ["bees", "flowers"],
            "Cooking": ["cooking"],
          };
          const treeCats = TREE_TO_CATS[skill.tree];
          if (treeCats) {
            categories.length = 0; // clear "other"
            categories.push(...treeCats);
          }
        }
        // Skill cost = skill points √ó SFL per skill point
        const skillFloor = skillCostInfo.sflPerPoint > 0 ? skill.points * skillCostInfo.sflPerPoint : 0;
        boostItems.push({
          name: skillName, type: "Skill", boost: boostText,
          floor: skillFloor, supply: 0, has, effects, categories,
          skillPoints: skill.points, skillTree: skill.tree, skillTier: skill.tier,
          isPower: skill.power || false,
        });
      }

      // Load saved product selections
      const savedProducts = getSavedPowerProducts();

      // Build category ‚Üí boosts mapping
      const catBoosts = {};
      for (const catId of Object.keys(POWER_CATEGORIES)) {
        catBoosts[catId] = boostItems.filter(b => b.categories.includes(catId));
      }

      // Store state for interactive updates
      powerState = { boostItems, catBoosts, capacity, p2pPrices, savedProducts, farm, skillCostInfo };

      // Render
      renderPowerContent();
    }

    function renderPowerContent() {
      const { boostItems, catBoosts, capacity, p2pPrices, savedProducts } = powerState;

      const ownedCount = boostItems.filter(b => b.has).length;
      const totalCount = boostItems.length;

      // Calculate total boost value across all quantifiable categories
      let totalBaseSfl = 0, totalBoostedSfl = 0;
      const catSummaries = {};
      for (const [catId, catDef] of Object.entries(POWER_CATEGORIES)) {
        if (!catDef.quantifiable) continue;
        const product = savedProducts[catId] || getDefaultProduct(catId);
        const priceProduct = getPriceProduct(catId, product);
        const baseResult = applyBoosts(catId, product, capacity, []);
        const baseSfl = unitToSfl(baseResult.unitsPerDay, priceProduct, p2pPrices);

        const ownedEffects = catBoosts[catId].filter(b => b.has).flatMap(b => getEffectsForCategory(b, catId));
        const boostedResult = applyBoosts(catId, product, capacity, ownedEffects);
        const boostedSfl = unitToSfl(boostedResult.unitsPerDay, priceProduct, p2pPrices);

        totalBaseSfl += baseSfl;
        totalBoostedSfl += boostedSfl;
        catSummaries[catId] = { baseSfl, boostedSfl, delta: boostedSfl - baseSfl, product };
      }

      const totalDelta = totalBoostedSfl - totalBaseSfl;
      const boostPct = totalBaseSfl > 0 ? ((totalDelta / totalBaseSfl) * 100).toFixed(0) : 0;

      let content = "";

      // Summary
      const { skillCostInfo } = powerState;

      content += `<div class="power-summary pixel-font">
        <div class="power-summary-stat"><div class="power-summary-label">OWNED</div><div class="power-summary-value" style="color:var(--green)">${ownedCount} / ${totalCount}</div></div>
        <div class="power-summary-stat"><div class="power-summary-label">BOOST VALUE</div><div class="power-summary-value" style="color:var(--sunpetal)">+${totalDelta.toFixed(2)} SFL/day</div></div>
        <div class="power-summary-stat"><div class="power-summary-label">BASE</div><div class="power-summary-value">${totalBaseSfl.toFixed(2)} SFL/day</div></div>
        <div class="power-summary-stat"><div class="power-summary-label">BOOSTED</div><div class="power-summary-value" style="color:var(--green)">${totalBoostedSfl.toFixed(2)} SFL/day (+${boostPct}%)</div></div>
      </div>`;

      // Skill cost info panel
      if (skillCostInfo && skillCostInfo.sflPerPoint > 0) {
        const br = skillCostInfo.bestRecipe;
        const hasXpBoosts = skillCostInfo.xpBoostNames && skillCostInfo.xpBoostNames.length > 0;
        content += `<div class="pixel-panel" style="padding:8px 12px;margin-bottom:16px;font-size:9px;border:2px solid var(--border-dark)">
          <div class="pixel-font" style="font-size:10px;color:var(--lily);margin-bottom:6px">üß† SKILL POINT COST ESTIMATE</div>
          <div style="color:var(--text-secondary);line-height:1.6">
            Bumpkin Lvl <strong>${skillCostInfo.level}</strong> ‚Üí ${(skillCostInfo.totalXP / 1e6).toFixed(1)}M XP total<br>
            Best recipe: <strong>${escHTML(br.name)}</strong> (${escHTML(br.building)})
            ‚Äî base ${br.xp} XP${hasXpBoosts ? ` ‚Üí <span style="color:var(--green)">${br.boostedXP} XP</span> with boosts` : ""}<br>
            ${hasXpBoosts ? `XP boosts: ${escHTML(skillCostInfo.xpBoostNames.join(", "))}<br>` : ""}
            Ingredients: ${Object.entries(br.ingredients).map(([k, v]) => `${v}√ó ${escHTML(k)}`).join(", ")} = ${br.cost.toFixed(4)} SFL<br>
            Efficiency: <strong>${br.ratio.toFixed(0)} XP/SFL</strong> | Total SFL to lvl ${skillCostInfo.level}: ~${(skillCostInfo.totalSFL).toFixed(0)} SFL<br>
            <span style="color:var(--sunpetal);font-weight:bold">1 skill point ‚âà ${skillCostInfo.sflPerPoint.toFixed(1)} SFL</span>
            <span style="color:var(--text-dim)"> (${skillCostInfo.sflPerLevel.toFixed(1)} SFL/level avg)</span>
          </div>
        </div>`;
      }

      // Best Buys: top 10 missing boosts by ROI
      const bestBuys = [];
      for (const [catId, catDef] of Object.entries(POWER_CATEGORIES)) {
        if (!catDef.quantifiable) continue;
        const product = savedProducts[catId] || getDefaultProduct(catId);
        const missingInCat = catBoosts[catId].filter(b => !b.has && b.floor > 0);
        for (const b of missingInCat) {
          const val = calcBoostValue(b, catId, product, capacity, p2pPrices, catBoosts[catId], false);
          if (val.synergy > 0.0001) {
            bestBuys.push({ boost: b, catId, catLabel: catDef.label, synergy: val.synergy, roi: val.roi, floor: b.floor });
          }
        }
      }
      bestBuys.sort((a, b) => a.roi - b.roi);
      const top10 = bestBuys.slice(0, 10);

      if (top10.length > 0) {
        content += `<div class="power-best-buys pixel-panel">
          <div class="power-section-header pixel-font" onclick="this.nextElementSibling.style.display=this.nextElementSibling.style.display==='none'?'block':'none'">
            <span>üèÜ TOP 10 BEST BUYS (by ROI)</span>
            <span class="power-toggle-arrow">‚ñº</span>
          </div>
          <div class="power-section-body">`;
        for (let i = 0; i < top10.length; i++) {
          const bb = top10[i];
          const imgUrl = bb.boost.type !== "Skill" ? ITEM_ICON_BASE + encodeURIComponent(bb.boost.name) + ".png" : "";
          content += `<div class="power-bb-row">
            <span class="power-bb-rank">${i + 1}.</span>
            ${imgUrl ? `<img class="power-bb-img" src="${imgUrl}" onerror="this.style.display='none'" alt="">` : `<span style="width:20px"></span>`}
            <span class="power-bb-name">${escHTML(bb.boost.name)}</span>
            <span class="power-bb-cat">${escHTML(bb.catLabel)}</span>
            <span class="power-bb-sfl">+${bb.synergy.toFixed(2)}/day</span>
            <span class="power-bb-floor">${bb.floor.toFixed(0)} SFL</span>
            <span class="power-bb-roi">${bb.roi.toFixed(0)}d ROI</span>
          </div>`;
        }
        content += `</div></div>`;
      }

      // Quantifiable categories
      content += `<div class="pixel-font" style="font-size:11px;color:var(--text-secondary);margin:16px 0 8px;border-bottom:2px solid var(--border-dark);padding-bottom:4px">‚ïê‚ïê‚ïê QUANTIFIABLE CATEGORIES ‚ïê‚ïê‚ïê</div>`;

      for (const [catId, catDef] of Object.entries(POWER_CATEGORIES)) {
        if (!catDef.quantifiable) continue;
        const items = catBoosts[catId];
        if (items.length === 0) continue;

        const product = savedProducts[catId] || getDefaultProduct(catId);
        const summary = catSummaries[catId] || { baseSfl: 0, boostedSfl: 0, delta: 0 };
        const n = getCapacityCount(catId, capacity);
        const owned = items.filter(b => b.has);
        const missing = items.filter(b => !b.has);

        content += `<div class="power-category pixel-panel" id="power-cat-${catId}">`;
        content += `<div class="power-cat-header pixel-font" onclick="togglePowerCategory('${catId}')">
          <span>${catDef.emoji} ${catDef.label}</span>
          <span class="power-cat-count">${n} ${({crops:"plots",fruits:"patches",trees:"trees",flowers:"beds",stone:"rocks",iron:"nodes",gold:"nodes",crimstone:"nodes",chickens:"chickens",cows:"cows",sheep:"sheep",bees:"hives",fishing:"reels"})[catId] || catId}</span>`;

        // Product selector
        if (catDef.selector === "crop") {
          content += `<select class="power-product-select" onchange="selectPowerProduct('${catId}',this.value)" onclick="event.stopPropagation()">`;
          for (const crop of Object.keys(CROP_GROW_DATA)) {
            content += `<option value="${crop}"${crop === product ? " selected" : ""}>${crop}</option>`;
          }
          content += `</select>`;
        } else if (catDef.selector === "fruit") {
          content += `<select class="power-product-select" onchange="selectPowerProduct('${catId}',this.value)" onclick="event.stopPropagation()">`;
          for (const fruit of Object.keys(FRUIT_GROW_DATA)) {
            content += `<option value="${fruit}"${fruit === product ? " selected" : ""}>${fruit}</option>`;
          }
          content += `</select>`;
        } else if (catDef.selector === "flower") {
          content += `<select class="power-product-select" onchange="selectPowerProduct('${catId}',this.value)" onclick="event.stopPropagation()">`;
          for (const seed of Object.keys(SEED_DATA)) {
            content += `<option value="${seed}"${seed === product ? " selected" : ""}>${SEED_DATA[seed].label}</option>`;
          }
          content += `</select>`;
        }

        content += `<span class="power-cat-sfl" style="color:var(--sunpetal)">+${summary.delta.toFixed(2)}/day</span>
          <span class="power-toggle-arrow">‚ñº</span>
        </div>`;

        content += `<div class="power-cat-body">`;
        content += buildProductionBreakdown(catId, product, capacity, p2pPrices, items);

        // Owned boosts
        if (owned.length > 0) {
          content += `<div class="power-subsection-label">‚úÖ OWNED (${owned.length})</div>`;
          for (const b of owned) {
            const val = calcBoostValue(b, catId, product, capacity, p2pPrices, items, true);
            content += renderPowerBoostRow(b, catId, product, val, true);
          }
        }

        // Missing boosts
        if (missing.length > 0) {
          const missingWithVal = missing.map(b => {
            const val = calcBoostValue(b, catId, product, capacity, p2pPrices, items, false);
            return { b, val };
          }).sort((a, b) => a.val.roi - b.val.roi);

          content += `<div class="power-subsection-label">‚ùå MISSING (${missing.length})</div>`;
          for (const { b, val } of missingWithVal) {
            content += renderPowerBoostRow(b, catId, product, val, false);
          }
        }

        content += `</div></div>`; // cat-body, power-category
      }

      // Qualitative categories
      content += `<div class="pixel-font" style="font-size:11px;color:var(--text-secondary);margin:16px 0 8px;border-bottom:2px solid var(--border-dark);padding-bottom:4px">‚ïê‚ïê‚ïê QUALITATIVE BOOSTS ‚ïê‚ïê‚ïê</div>`;

      for (const [catId, catDef] of Object.entries(POWER_CATEGORIES)) {
        if (catDef.quantifiable) continue;
        const items = catBoosts[catId];
        if (items.length === 0) continue;

        const owned = items.filter(b => b.has);
        const missing = items.filter(b => !b.has);

        content += `<div class="power-category pixel-panel" id="power-cat-${catId}">`;
        content += `<div class="power-cat-header pixel-font" onclick="togglePowerCategory('${catId}')">
          <span>${catDef.emoji} ${catDef.label}</span>
          <span class="power-cat-count">${owned.length}/${items.length} owned</span>
          <span class="power-toggle-arrow">‚ñº</span>
        </div>`;
        content += `<div class="power-cat-body">`;

        if (owned.length > 0) {
          content += `<div class="power-subsection-label">‚úÖ OWNED (${owned.length})</div>`;
          for (const b of owned) {
            content += renderPowerQualRow(b, true);
          }
        }
        if (missing.length > 0) {
          content += `<div class="power-subsection-label">‚ùå MISSING (${missing.length})</div>`;
          for (const b of missing.sort((a, b) => a.floor - b.floor)) {
            content += renderPowerQualRow(b, false);
          }
        }

        content += `</div></div>`;
      }

      // ‚îÄ‚îÄ DEBUG: All Boosts Mapping Table ‚îÄ‚îÄ
      content += `<div style="margin-top:16px">
        <div class="pixel-font" style="font-size:11px;color:var(--text-secondary);margin-bottom:8px;border-bottom:2px solid var(--border-dark);padding-bottom:4px;cursor:pointer" onclick="document.getElementById('power-debug-table').style.display=document.getElementById('power-debug-table').style.display==='none'?'block':'none'">
          ‚ïê‚ïê‚ïê üîç ALL BOOSTS DEBUG TABLE (${boostItems.length}) ‚ïê‚ïê‚ïê <span style="font-size:9px;color:var(--text-dim)">click to toggle</span>
        </div>
        <div id="power-debug-table" style="display:none;overflow-x:auto">
          <table style="width:100%;border-collapse:collapse;font-size:8px;color:var(--text-secondary)">
            <thead>
              <tr style="background:rgba(92,58,30,0.3);text-align:left">
                <th style="padding:4px 6px;border:1px solid var(--border-dark);min-width:100px">Name</th>
                <th style="padding:4px 6px;border:1px solid var(--border-dark);min-width:55px">Type</th>
                <th style="padding:4px 6px;border:1px solid var(--border-dark)">Own</th>
                <th style="padding:4px 6px;border:1px solid var(--border-dark);min-width:140px">Boost Text</th>
                <th style="padding:4px 6px;border:1px solid var(--border-dark);min-width:65px">Categories</th>
                <th style="padding:4px 6px;border:1px solid var(--border-dark);min-width:180px">Parsed Effects</th>
              </tr>
            </thead>
            <tbody>`;

      const sortedBoosts = [...boostItems].sort((a, b) => a.type.localeCompare(b.type) || a.name.localeCompare(b.name));
      for (const b of sortedBoosts) {
        const ownIcon = b.has ? "‚úÖ" : "‚ùå";
        const effectsDesc = b.effects.map(e => {
          if (e.type === "qualitative") return `<span style="color:var(--text-dim)">qualitative: ${escHTML(e.raw || "?")}</span>`;
          let desc = `<span style="color:var(--lily)">${e.type}</span>`;
          if (e.value !== undefined) desc += ` <strong>${e.value > 0 ? "+" : ""}${e.value}</strong>`;
          if (e.pct !== undefined) desc += ` ${e.pct}%`;
          if (e.extra !== undefined) desc += ` +${e.extra}`;
          if (e.product) desc += ` <span style="color:var(--sunpetal)">${escHTML(e.product)}</span>`;
          desc += ` ‚Üí <span style="color:var(--green)">${e.cat || "?"}</span>`;
          return desc;
        }).join("<br>");
        const catBadges = b.categories.map(c => `<span style="background:rgba(92,58,30,0.3);padding:1px 4px;border-radius:3px;margin:1px">${c}</span>`).join(" ");

        content += `<tr style="border-bottom:1px solid rgba(92,58,30,0.15)">
          <td style="padding:3px 6px;border:1px solid var(--border-dark);font-weight:bold">${escHTML(b.name)}</td>
          <td style="padding:3px 6px;border:1px solid var(--border-dark)">${b.type}${b.skillTree ? ` (${b.skillTree})` : ""}</td>
          <td style="padding:3px 6px;border:1px solid var(--border-dark);text-align:center">${ownIcon}</td>
          <td style="padding:3px 6px;border:1px solid var(--border-dark);white-space:pre-wrap">${escHTML(b.boost)}</td>
          <td style="padding:3px 6px;border:1px solid var(--border-dark)">${catBadges}</td>
          <td style="padding:3px 6px;border:1px solid var(--border-dark)">${effectsDesc || "<em>none</em>"}</td>
        </tr>`;
      }

      content += `</tbody></table></div></div>`;

      content += `<div class="footer" style="margin-top:16px">
        <button class="refresh-btn" onclick="refresh()">REFRESH</button>
        <div class="timestamp pixel-font">Updated: ${new Date().toLocaleTimeString("cs-CZ")}</div>
      </div>`;

      document.getElementById("power-content").innerHTML = content;
    }

    function renderPowerBoostRow(b, catId, product, val, isOwned) {
      const imgUrl = b.type !== "Skill" ? ITEM_ICON_BASE + encodeURIComponent(b.name) + ".png" : "";
      const sflText = val.synergy !== 0 ? `${val.synergy > 0 ? "+" : ""}${val.synergy.toFixed(2)}/day` : "‚Äî";
      const roiText = val.roi < Infinity ? `${val.roi.toFixed(0)}d` : "";
      const typeLabel = b.type === "Skill" ? `Skill (${b.skillTree}, ${b.skillPoints}pt)` : b.type;
      const costLabel = b.type === "Skill" && b.floor > 0
        ? `~${b.floor.toFixed(0)} SFL (${b.skillPoints}pt)`
        : (b.floor > 0 ? `${b.floor.toFixed(0)} SFL` : "");

      return `<div class="power-boost-row ${isOwned ? "has-it" : "missing"}" onclick="togglePowerDetail(this,'${escHTML(b.name).replace(/'/g, "\\'")}','${catId}')">
        ${imgUrl ? `<img class="power-boost-img" src="${imgUrl}" onerror="this.style.display='none'" alt="">` : `<span class="power-boost-icon">üß†</span>`}
        <div class="power-boost-info">
          <div class="power-boost-name">${escHTML(b.name)} <span class="power-boost-type">${escHTML(typeLabel)}</span></div>
          <div class="power-boost-text">${escHTML(b.boost)}</div>
        </div>
        <div class="power-boost-value">
          <div class="power-boost-sfl">${sflText}</div>
          ${roiText ? `<div class="power-boost-roi">${roiText} ROI</div>` : ""}
          ${costLabel ? `<div class="power-boost-floor">${costLabel}</div>` : ""}
        </div>
      </div>`;
    }

    function renderPowerQualRow(b, isOwned) {
      const imgUrl = b.type !== "Skill" ? ITEM_ICON_BASE + encodeURIComponent(b.name) + ".png" : "";
      const typeLabel = b.type === "Skill" ? `Skill (${b.skillTree}, ${b.skillPoints}pt)` : b.type;
      const costLabel = b.type === "Skill" && b.floor > 0
        ? `~${b.floor.toFixed(0)} SFL (${b.skillPoints}pt)`
        : (b.floor > 0 ? `${b.floor.toFixed(0)} SFL` : "");
      return `<div class="power-boost-row ${isOwned ? "has-it" : "missing"}" onclick="togglePowerDetail(this,'${escHTML(b.name).replace(/'/g, "\\'")}','qual')">
        ${imgUrl ? `<img class="power-boost-img" src="${imgUrl}" onerror="this.style.display='none'" alt="">` : `<span class="power-boost-icon">üß†</span>`}
        <div class="power-boost-info">
          <div class="power-boost-name">${escHTML(b.name)} <span class="power-boost-type">${escHTML(typeLabel)}</span></div>
          <div class="power-boost-text">${escHTML(b.boost)}</div>
        </div>
        <div class="power-boost-value">
          ${!isOwned && costLabel ? `<div class="power-boost-floor">${costLabel}</div>` : ""}
        </div>
      </div>`;
    }

    function togglePowerCategory(catId) {
      const cat = document.getElementById("power-cat-" + catId);
      if (!cat) return;
      const body = cat.querySelector(".power-cat-body");
      const arrow = cat.querySelector(".power-toggle-arrow");
      if (body.style.display === "none") {
        body.style.display = "block";
        if (arrow) arrow.textContent = "‚ñº";
      } else {
        body.style.display = "none";
        if (arrow) arrow.textContent = "‚ñ∂";
      }
    }

    function togglePowerDetail(el, boostName, catId) {
      const row = el.closest ? el : el.parentElement;
      // If next sibling is a detail, remove it (toggle off)
      if (row.nextElementSibling && row.nextElementSibling.classList.contains("power-detail")) {
        row.nextElementSibling.remove();
        return;
      }
      // Remove any other open details nearby
      const parentCat = row.closest(".power-category");
      if (parentCat) parentCat.querySelectorAll(".power-detail").forEach(d => d.remove());

      // Find the boost item across all categories
      const { catBoosts, boostItems, capacity, p2pPrices, savedProducts } = powerState;
      let boostItem, effectiveCatId = catId;
      if (catId === "qual") {
        // Qualitative ‚Äî find item in all boosts
        boostItem = boostItems.find(b => b.name === boostName);
        effectiveCatId = boostItem?.categories?.[0] || "other";
      } else {
        const items = catBoosts[catId] || [];
        boostItem = items.find(b => b.name === boostName);
      }
      if (!boostItem) return;

      const product = savedProducts[effectiveCatId] || getDefaultProduct(effectiveCatId);
      const items = catBoosts[effectiveCatId] || [];
      const detailHTML = buildFormulaHTML(boostItem, effectiveCatId, product, capacity, p2pPrices, items);
      const detail = document.createElement("div");
      detail.className = "power-detail";
      detail.innerHTML = detailHTML;
      row.after(detail);
    }

    function selectPowerProduct(catId, product) {
      savePowerProduct(catId, product);
      powerState.savedProducts[catId] = product;
      renderPowerContent();
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  MAIN
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function refresh() {
      cachedFarmData = null;
      main();
    }

    async function main() {
      const cfg = getConfig();
      const page = getPage();

      FARM_ID = cfg.farm;
      LIMIT = cfg.limit;
      FLOWER_BEDS = 4;

      renderNavBar(page);
      renderDonate();

      if (!FARM_ID) {
        renderConfigBar("hub");
        renderHub(null);
        return;
      }

      renderConfigBar(page);

      const app = document.getElementById("app");

      if (!cachedFarmData) {
        app.innerHTML = `<div class="loading-screen pixel-font">
          <div class="loading-flower">üåª</div>
          <div class="loading-text">Loading farm data...</div>
        </div>`;
      }

      try {
        if (!cachedFarmData) {
          cachedFarmData = await fetchFarmData();
        }
        const data = cachedFarmData;

        // Auto-detect bed/trap counts and apply boosts
        FLOWER_BEDS = Math.max(1, Object.keys(data.flowerBeds).length);
        applyFlowerBoosts(data.flowerMultiplier);

        switch (page) {
          case "hub": renderHub(data); break;
          case "flowers": renderFlowers(data); break;
          case "dolls": renderDolls(data); break;
          case "crustaceans": renderCrustaceans(data); break;
          case "bumpkin": renderBumpkin(data); break;
          case "treasury": renderTreasury(data); break;
          case "sales": renderSales(data); break;
          case "power": renderPower(data); break;
          default: renderHub(data);
        }

        if (page === "flowers") {
          startPBTimer();
          startGrowingTimers();
        }
        if (page === "dolls" && data.craftingBox?.readyAt) {
          startGrowingTimers();
        }

        fetch(`/api/track?farm=${FARM_ID}&page=${page}`).catch(() => {});
      } catch (err) {
        console.error(err);
        const needsConfig = !FARM_ID;
        app.innerHTML = `<div class="error-screen pixel-panel pixel-font">
          <div class="icon">${needsConfig ? "üëÜ" : "‚ö†Ô∏è"}</div>
          <h2>${needsConfig ? "Enter your Farm ID above" : "Failed to load data"}</h2>
          <p>${escHTML(err.message)}</p>
          ${needsConfig ? `<p style="font-size:10px;color:var(--text-dim)">
            Enter your farm number to get started.<br>
            Your settings will be saved in the URL for bookmarking.
          </p>` : ""}
          <button class="refresh-btn" onclick="refresh()">RETRY</button>
        </div>`;
      }
    }

    // Enter key in config inputs triggers load
    document.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && e.target.closest(".config-bar")) applyConfig();
    });

    // Init
    migrateApiKey();
    main();

    // Register service worker for PWA
    if ("serviceWorker" in navigator) {
      navigator.serviceWorker.register("/sw.js").catch(() => {});
    }
  </script>
</body>
</html>
